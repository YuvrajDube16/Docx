<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChatHistoryState">
    <option name="toolDurations">
      <map>
        <entry key="call_5sKJrGOWmb4opThGRI4JImlF" value="1" />
        <entry key="call_8FaUeolOBQ8r7yas4tPyujvk" value="12706" />
        <entry key="call_AKP4MEa3Fyuu02DPo7o3NqZu" value="16377" />
        <entry key="call_FyZS4dzh6XHZRklhvlCcLITd" value="1" />
        <entry key="call_kDnxBfMNuU5tgfsF6Sh1ebXy" value="1" />
        <entry key="call_sLvkL1K5eX4bKq8lIqDerCrb" value="29068" />
        <entry key="toolu_bdrk_012rmbF6AezgJPMW9sBAmnSv" value="25" />
        <entry key="toolu_bdrk_015tB3oopEHFmmMVoZ9vpaU4" value="3571" />
        <entry key="toolu_bdrk_016drqda4qL4qxRu2VLEoHJn" value="13759" />
        <entry key="toolu_bdrk_016sFbkNMfDvQSfxqj3fzeHb" value="54" />
        <entry key="toolu_bdrk_016uihUFwc3q6m5THFV8mN5J" value="9123" />
        <entry key="toolu_bdrk_017BJ2L9gMt4K73jxBPEM65D" value="180" />
        <entry key="toolu_bdrk_017cNXzGZ9xHLyP7fApVhX5r" value="19" />
        <entry key="toolu_bdrk_017vu1Cm7g45o5DYqdmEMebP" value="7567" />
        <entry key="toolu_bdrk_0186NkVXrYWUCbJsuKYRK2Ux" value="8478" />
        <entry key="toolu_bdrk_018oPXVWXnLy2MFcqmqbTrAK" value="2" />
        <entry key="toolu_bdrk_01DkqY959TFqAAwKTessrJfN" value="163" />
        <entry key="toolu_bdrk_01EvTMjZKDFQ5MfqYYpsy2TA" value="34019" />
        <entry key="toolu_bdrk_01ExHCKpEjgYZYASdU5o6jo3" value="11470" />
        <entry key="toolu_bdrk_01Fh4viTaKdJFDcYqsuxzDjR" value="6252" />
        <entry key="toolu_bdrk_01GPAuZEEXwjLTpSC4MaMPsz" value="2" />
        <entry key="toolu_bdrk_01HLFq4DaWq1q62G7gDZoKti" value="10373" />
        <entry key="toolu_bdrk_01JL3bLgKPhEQ2jzc9vZipTH" value="27412" />
        <entry key="toolu_bdrk_01M6EPRwz5KYDkZPTyCQyc7K" value="11323" />
        <entry key="toolu_bdrk_01PZAmvjk3gWx1Q45GzZSW8R" value="6" />
        <entry key="toolu_bdrk_01Px7gQjgZZsScmnwGRHy3Tw" value="244" />
        <entry key="toolu_bdrk_01QW3nn4wcZdeTQiLPsTs1zM" value="353" />
        <entry key="toolu_bdrk_01QbiLLiH9SvxPEqSYr7PAG5" value="1045748" />
        <entry key="toolu_bdrk_01SE1gnKi8AXyNq27gjGiA7r" value="1" />
        <entry key="toolu_bdrk_01TU2R7k33hN2b26yXrhrJQU" value="68" />
        <entry key="toolu_bdrk_01UTTtZ7vYsHeVcJDFLAhUQF" value="6296" />
        <entry key="toolu_bdrk_01YW55ugEn1Ugmwfou8VynmW" value="9897" />
      </map>
    </option>
    <option name="chatSessions" value="{&quot;50d6bdc5-6b40-408b-a6e7-85ef7d8f730c&quot;:{&quot;id&quot;:&quot;50d6bdc5-6b40-408b-a6e7-85ef7d8f730c&quot;,&quot;name&quot;:&quot;DOCX Parsing Error After Editing&quot;,&quot;timestamp&quot;:1759468692994,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/ViewDocxScreen.kt, lines\u003dALL(1-253)\npackage com.example.docx.ui\n\nimport android.graphics.Color\nimport android.net.Uri\nimport android.webkit.WebView\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material.icons.filled.Edit\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.viewinterop.AndroidView\nimport androidx.documentfile.provider.DocumentFile\nimport fr.opensagres.poi.xwpf.converter.xhtml.XHTMLConverter\nimport fr.opensagres.poi.xwpf.converter.xhtml.XHTMLOptions\nimport org.apache.poi.xwpf.usermodel.XWPFDocument\nimport java.io.ByteArrayOutputStream\nimport java.io.InputStream\n\n// --- Convert DOCX -\u003e HTML ---\nfun convertDocxToHtml(inputStream: InputStream): String {\n    val document \u003d XWPFDocument(inputStream)\n    val out \u003d ByteArrayOutputStream()\n    val options \u003d XHTMLOptions.create().apply {\n        // You can configure options here (e.g. images handling)\n    }\n    XHTMLConverter.getInstance().convert(document, out, options)\n    return out.toString(\&quot;UTF-8\&quot;)\n}\n\n// --- Composable to show DOCX ---\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun ViewDocxScreen(\n    htmlContent: String,\n    fileUriString: String,\n    onNavigateBack: () -\u003e Unit,\n    onNavigateToEdit: (String) -\u003e Unit,\n\n) {\n    val context \u003d LocalContext.current\n    val documentName \u003d remember(fileUriString) {\n        DocumentFile.fromSingleUri(context, Uri.parse(fileUriString))?.name ?: \&quot;Document\&quot;\n    }\n\n    Scaffold(\n        topBar \u003d {\n            TopAppBar(\n                title \u003d { Text(documentName) },\n                navigationIcon \u003d {\n                    IconButton(onClick \u003d onNavigateBack) {\n                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription \u003d \&quot;Back\&quot;)\n                    }\n                },\n                actions \u003d {\n                    IconButton(onClick \u003d { onNavigateToEdit(fileUriString) }) {\n                        Icon(Icons.Filled.Edit, contentDescription \u003d \&quot;Edit\&quot;)\n                    }\n                }\n            )\n        }\n        ,modifier \u003d Modifier.fillMaxSize()\n    ) { paddingValues -\u003e\n        AndroidView(\n            factory \u003d { ctx -\u003e\n                WebView(ctx).apply {\n                    settings.javaScriptEnabled \u003d true\n                    settings.allowFileAccess \u003d false\n                    settings.setSupportZoom(true)\n                    settings.builtInZoomControls \u003d true\n                    settings.displayZoomControls \u003d false\n                    setBackgroundColor(Color.WHITE)\n                }\n            },\n            update \u003d { webView -\u003e\n                val styledHtml \u003d \&quot;\&quot;\&quot;\n                    \u003c!DOCTYPE html\u003e\n                    \u003chtml\u003e\n                    \u003chead\u003e\n                      \u003cmeta charset\u003d\&quot;UTF-8\&quot;\u003e\n                      \u003cmeta name\u003d\&quot;viewport\&quot; content\u003d\&quot;width\u003ddevice-width, initial-scale\u003d1.0\&quot;\u003e\n                      \u003cstyle\u003e\n                        body { \n                            font-family: \u0027Times New Roman\u0027, serif;\n                            line-height: 1.6;\n                            background: #f0f0f0;\n                            margin: 0;\n                            padding: 20px;\n                        }\n                        .page {\n                            background: white;\n                            margin: 0 auto 20px auto;\n//                            padding: 2.54cm; /* A4 standard margins */\n                            padding-top: 1.00cm; /* A4 standard margins */\n                            padding-bottom: 1.00cm; /* A4 standard margins */\n                            padding-left: 2.54cm; /* A4 standard margins */\n                            padding-right: 2.54cm; /* A4 standard margins */\n                            width: 21cm;   /* A4 width */\n                            min-height: 29.7cm; /* A4 height */\n                            box-shadow: 0 4px 8px rgba(0,0,0,0.15);\n                            page-break-after: always;\n                            position: relative;\n                            overflow: visible;\n                        }\n                        .page:last-child {\n                            page-break-after: auto;\n                        }\n                        .page-number {\n                            position: absolute;\n                            bottom: 1.27cm;\n                            right: 2.54cm;\n                            font-size: 10pt;\n                            color: #666;\n                        }\n\n                        h1, h2, h3, h4, h5 {\n                            margin-top: 0.4em;\n                            margin-bottom: 0.2em;\n                        }\n                        p {\n                            margin: 0.2em 0;\n                        }\n                        ul, ol {\n                            margin: 0.5em 0 0.5em 1em;\n                        }\n                        table {\n                            border-collapse: collapse;\n                            width: 100%;\n                            margin: 1em 0;\n                        }\n                        td, th {\n                            border: 1px solid #444;\n                            padding: 3px;\n                            text-align: left;\n                        }\n                        img {\n                            max-width: 100%;\n                            height: auto;\n                            display: block;\n                            margin: 0.5em auto;\n                        }\n                      \u003c/style\u003e\n                      \u003cscript\u003e\n                        function splitContentIntoPages(content) {\n                            const tempDiv \u003d document.createElement(\u0027div\u0027);\n                            tempDiv.innerHTML \u003d content;\n                            tempDiv.style.cssText \u003d \u0027position: absolute; top: -10000px; width: 21cm;padding: 2.54cm;font-family: Times New Roman; line-height: 1.6;\u0027; \n                            document.body.appendChild(tempDiv);\n                            \n                            const pageHeight \u003d 29.7 * 37.795; // A4 height in pixels\n                            const pages \u003d [];\n                            let currentPageContent \u003d \u0027\u0027;\n                            let currentHeight \u003d 0;\n                            let pageNumber \u003d 1;\n                            \n                            const elements \u003d Array.from(tempDiv.children);\n                            \n                            for (const element of elements) {\n                                const elementHeight \u003d element.offsetHeight;\n                                \n                                if (currentHeight + elementHeight \u003e pageHeight - 200) { // Leave margin for page number and padding\n                                    // Finish current page\n                                    if (currentPageContent) {\n                                        pages.push({\n                                            content: currentPageContent,\n                                            number: pageNumber++\n                                        });\n                                        currentPageContent \u003d \u0027\u0027;\n                                        currentHeight \u003d 0;\n                                    }\n                                }\n                                \n                                currentPageContent +\u003d element.outerHTML;\n                                currentHeight +\u003d elementHeight;\n                            }\n                            \n                            // Add remaining content as last page\n                            if (currentPageContent) {\n                                pages.push({\n                                    content: currentPageContent,\n                                    number: pageNumber\n                                });\n                            }\n                            \n                            // Ensure at least one page\n                            if (pages.length \u003d\u003d\u003d 0) {\n                                pages.push({\n                                    content: content || \u0027\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u0027,\n                                    number: 1\n                                });\n                            }\n                            \n                            document.body.removeChild(tempDiv);\n                            return pages;\n                        }\n                        \n                        function renderPages() {\n                            const container \u003d document.querySelector(\u0027.page\u0027);\n                            if (!container) return;\n                            \n                            const originalContent \u003d container.innerHTML;\n                            const pages \u003d splitContentIntoPages(originalContent);\n                            \n                            // Clear existing content\n                            document.body.innerHTML \u003d \u0027\u0027;\n                            \n                            // Create pages\n                            pages.forEach(page \u003d\u003e {\n                                const pageDiv \u003d document.createElement(\u0027div\u0027);\n                                pageDiv.className \u003d \u0027page\u0027;\n                                pageDiv.innerHTML \u003d page.content;\n                                \n                                const pageNum \u003d document.createElement(\u0027div\u0027);\n                                pageNum.className \u003d \u0027page-number\u0027;\n                                pageNum.textContent \u003d page.number;\n                                pageDiv.appendChild(pageNum);\n                                \n                                document.body.appendChild(pageDiv);\n                            });\n                        }\n                        \n                        window.addEventListener(\u0027load\u0027, function() {\n                            setTimeout(renderPages, 100);\n                        });\n                      \u003c/script\u003e\n                    \u003c/head\u003e\n                    \u003cbody\u003e\n                      \u003cdiv class\u003d\&quot;page\&quot;\u003e\n                        $htmlContent\n                      \u003c/div\u003e\n                    \u003c/body\u003e\n                    \u003c/html\u003e\n                \&quot;\&quot;\&quot;.trimIndent()\n\n                webView.loadDataWithBaseURL(\n                    null,\n                    styledHtml,\n                    \&quot;text/html\&quot;,\n                    \&quot;utf-8\&quot;,\n                    null\n                )\n            },\n            modifier \u003d Modifier\n                .fillMaxSize()\n                .padding(paddingValues)\n        )\n    }\n}\n\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\nafter editing any docx file when i am trying to open it from any other docx reader application it is telling unable to parsing error\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;I see the issue! The problem is likely that your app is modifying the DOCX file in a way that corrupts its structure, making it unreadable by other applications. Let me examine your codebase to understand how you\u0027re handling DOCX editing and identify the root cause.&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01QW3nn4wcZdeTQiLPsTs1zM&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;file_search&quot;,&quot;arguments&quot;:&quot;{\&quot;query\&quot;: \&quot;EditDocxScreen\&quot;, \&quot;explanation\&quot;: \&quot;Looking for the editing screen to understand how DOCX files are being modified\&quot;}&quot;}},{&quot;id&quot;:&quot;toolu_bdrk_01TU2R7k33hN2b26yXrhrJQU&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;grep_search&quot;,&quot;arguments&quot;:&quot;{\&quot;query\&quot;: \&quot;save.*docx|write.*docx|XWPFDocument.*save\&quot;, \&quot;explanation\&quot;: \&quot;Searching for code that saves or writes DOCX files to identify potential corruption issues\&quot;}&quot;}},{&quot;id&quot;:&quot;toolu_bdrk_017cNXzGZ9xHLyP7fApVhX5r&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;list_dir&quot;,&quot;arguments&quot;:&quot;{\&quot;target_directory\&quot;: \&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;file_search&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01QW3nn4wcZdeTQiLPsTs1zM&quot;,&quot;content&quot;:&quot;[file] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt&quot;},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;grep_search&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01TU2R7k33hN2b26yXrhrJQU&quot;,&quot;content&quot;:&quot;File: AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/CreateNewDocxScreen.kt\n\tLine 236: Logger.i(\&quot;Document saved successfully to $newFileUri from CreateNewDocxScreen\&quot;)\n\tLine 249: Logger.d(\&quot;Save As action cancelled by user in CreateNewDocxScreen.\&quot;)\n\tLine 536: Logger.d(\&quot;Starting writeHtmlToDoc for $uri in CreateNewDocxScreen\&quot;)\n\tLine 563: Logger.i(\&quot;DOCX saved successfully to $uri from CreateNewDocxScreen\&quot;)\n\tLine 566: Logger.e(\&quot;Error in writeHtmlToDoc in CreateNewDocxScreen: ${e.message}\&quot;, e)\n\nFile: AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/util/DocxUtil.kt\n\tLine 49: suspend fun writeHtmlToDocx(context: Context, uri: Uri, html: String): Result\u003cUnit\u003e \u003d withCo\n\nFile: AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\n\tLine 72: val result \u003d writeHtmlToDocx(context, newFileUri, htmlContent ?: \&quot;\u003chtml\u003e\u003cbody\u003e\u003c/body\u003e\u003c/html\u003e\&quot;\n\tLine 559: suspend fun writeHtmlToDocx(context: Context, uri: Uri, htmlContent: String): Result\u003cUnit\u003e {\n\tLine 560: Logger.d(\&quot;Starting enhanced writeHtmlToDocx for $uri\&quot;)\n\tLine 588: Logger.e(\&quot;Error in enhanced writeHtmlToDocx: ${e.message}\&quot;, e)&quot;},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;list_dir&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_017cNXzGZ9xHLyP7fApVhX5r&quot;,&quot;content&quot;:&quot;Contents of directory:\n\n[dir] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/data/ - Sept 24, 2025 02:44 pm\n[dir] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/navigation/ - Sept 30, 2025 11:16 am\n[dir] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/repository/ - Sept 24, 2025 02:44 pm\n[dir] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/ - Oct 01, 2025 02:56 pm\n[dir] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/theme/ - Sept 24, 2025 01:23 pm\n[dir] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/util/ - Sept 30, 2025 01:58 pm\n[dir] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/viewmodel/ - Sept 24, 2025 03:18 pm\n[file] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/data/DocxFileInfo.kt (856B, 28 lines) - Sept 24, 2025 02:44 pm\n[file] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/MainActivity.kt (18.5KB, 396 lines) - Oct 01, 2025 12:10 pm\n[file] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/navigation/Screens.kt (311B, 8 lines) - Sept 30, 2025 11:09 am\n[file] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/repository/DocxRepository.kt (1.4KB, 46 lines) - Sept 24, 2025 02:44 pm\n[file] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/CreateNewDocxScreen.kt (33.1KB, 754 lines) - Oct 01, 2025 02:16 pm\n[file] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt (54.9KB, 1482 lines) - Oct 01, 2025 02:15 pm\n[file] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/Homescreens.kt (11.9KB, 281 lines) - Sept 30, 2025 11:09 am\n[file] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/ViewDocxScreen.kt (10.5KB, 252 lines) - Oct 01, 2025 02:56 pm\n[file] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/util/DocxUtil.kt (10.6KB, 279 lines) - Sept 30, 2025 11:42 am\n[file] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/util/Logger.kt (909B, 38 lines) - Sept 25, 2025 03:36 pm\n[file] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/util/ProvidesLogging.kt (358B, 12 lines) - Sept 24, 2025 02:52 pm\n[file] AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/viewmodel/DocxListViewModel.kt (6.4KB, 169 lines) - Sept 24, 2025 03:18 pm&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Now let me examine the key files to understand how you\u0027re editing and saving DOCX files:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01PZAmvjk3gWx1Q45GzZSW8R&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;read_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\&quot;}&quot;}},{&quot;id&quot;:&quot;toolu_bdrk_01SE1gnKi8AXyNq27gjGiA7r&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;read_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/util/DocxUtil.kt\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;read_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01PZAmvjk3gWx1Q45GzZSW8R&quot;,&quot;content&quot;:&quot;package com.example.docx.ui\n\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.net.Uri\nimport android.util.Base64\nimport android.webkit.WebView\nimport androidx.activity.compose.rememberLauncherForActivityResult\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.ColorFilter\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.viewinterop.AndroidView\nimport androidx.documentfile.provider.DocumentFile\nimport androidx.navigation.NavController\nimport com.example.docx.R\nimport com.example.docx.util.Logger\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport org.apache.poi.common.usermodel.PictureType\nimport org.apache.poi.util.Units\nimport org.apache.poi.xwpf.usermodel.*\nimport org.openxmlformats.schemas.officeDocument.x2006.sharedTypes.STVerticalAlignRun as OfficeSTVerticalAlignRun\nimport org.openxmlformats.schemas.wordprocessingml.x2006.main.*\nimport org.jsoup.Jsoup\nimport org.jsoup.nodes.Element\nimport org.jsoup.nodes.Node\nimport org.jsoup.nodes.TextNode\nimport java.io.ByteArrayInputStream\nimport java.io.IOException\nimport java.math.BigInteger\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// EditDocxScreen Composable\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n@OptIn(ExperimentalMaterial3Api::class)\n@SuppressLint(\&quot;SetJavaScriptEnabled\&quot;)\n@Composable\nfun EditDocxScreen(navController: NavController, fileUriString: String) {\n    var documentHtml by remember { mutableStateOf(\&quot;\u003cp\u003e\u003c/p\u003e\&quot;) }\n    var isLoading by remember { mutableStateOf(true) }\n    var isSaving by remember { mutableStateOf(false) }\n    val context \u003d LocalContext.current\n    val scope \u003d rememberCoroutineScope()\n    var errorMessage by remember { mutableStateOf\u003cString?\u003e(null) }\n    var showErrorDialog by remember { mutableStateOf(false) }\n    val webView \u003d remember { WebView(context) }\n\n    val currentFileUri \u003d remember { Uri.parse(fileUriString) }\n\n    val saveAsLauncher \u003d rememberLauncherForActivityResult(\n        contract \u003d ActivityResultContracts.CreateDocument(\&quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document\&quot;),\n        onResult \u003d { newFileUri: Uri? -\u003e\n            if (newFileUri !\u003d null) {\n                webView.evaluateJavascript(\n                    \&quot;(function() { return document.documentElement.outerHTML; })();\&quot;\n                ) { htmlContent -\u003e\n                    scope.launch {\n                        isSaving \u003d true\n                        val result \u003d writeHtmlToDocx(context, newFileUri, htmlContent ?: \&quot;\u003chtml\u003e\u003cbody\u003e\u003c/body\u003e\u003c/html\u003e\&quot;)\n                        result.fold(\n                            onSuccess \u003d {\n                                Logger.i(\&quot;Document saved successfully to $newFileUri\&quot;)\n                                navController.navigateUp()\n                            },\n                            onFailure \u003d { error -\u003e\n                                errorMessage \u003d \&quot;Save failed: ${error.message}\&quot;\n                                showErrorDialog \u003d true\n                            }\n                        )\n                        if(!showErrorDialog) isSaving \u003d false\n                    }\n                }\n            } else {\n                isSaving \u003d false\n                Logger.d(\&quot;Save As action cancelled.\&quot;)\n            }\n        }\n    )\n\n    LaunchedEffect(currentFileUri) {\n        isLoading \u003d true\n        Logger.d(\&quot;LaunchedEffect: Loading DOCX from $currentFileUri\&quot;)\n        withContext(Dispatchers.IO) {\n            try {\n                context.contentResolver.openInputStream(currentFileUri)?.use { inputStream -\u003e\n                    val document \u003d XWPFDocument(inputStream)\n                    val html \u003d convertDocxToHtmlEnhanced(document)\n                    withContext(Dispatchers.Main) {\n                        documentHtml \u003d html\n                        Logger.d(\&quot;Document loaded and converted to HTML successfully.\&quot;)\n                    }\n                    document.close()\n                } ?: throw IOException(\&quot;Failed to open input stream for $currentFileUri\&quot;)\n            } catch (e: Exception) {\n                Logger.e(\&quot;Error loading DOCX: ${e.localizedMessage}\&quot;, e)\n                withContext(Dispatchers.Main) {\n                    errorMessage \u003d \&quot;Load failed: ${e.localizedMessage}\&quot;\n                    showErrorDialog \u003d true\n                }\n            } finally {\n                withContext(Dispatchers.Main) {\n                    isLoading \u003d false\n                }\n            }\n        }\n    }\n\n    if (showErrorDialog) {\n        AlertDialog(\n            onDismissRequest \u003d {\n                showErrorDialog \u003d false\n                isSaving \u003d false\n            },\n            title \u003d { Text(\&quot;Error\&quot;) },\n            text \u003d { Text(errorMessage ?: \&quot;An unknown error occurred.\&quot;) },\n            confirmButton \u003d {\n                TextButton(onClick \u003d {\n                    showErrorDialog \u003d false\n                    isSaving \u003d false\n                    if (errorMessage?.startsWith(\&quot;Load failed\&quot;) \u003d\u003d true) navController.navigateUp()\n                }) { Text(\&quot;OK\&quot;) }\n            }\n        )\n    }\n\n    Scaffold(\n        topBar \u003d {\n            TopAppBar(\n                title \u003d { Text(DocumentFile.fromSingleUri(context, currentFileUri)?.name ?: \&quot;Edit Document\&quot;) },\n                navigationIcon \u003d {\n                    IconButton(onClick \u003d { navController.navigateUp() }, enabled \u003d !isSaving) {\n                        Icon(Icons.AutoMirrored.Filled.ArrowBack, \&quot;Back\&quot;)\n                    }\n                },\n                actions \u003d {\n                    TextButton(\n                        onClick \u003d {\n                            isSaving \u003d true\n                            val originalFileName \u003d DocumentFile.fromSingleUri(context, currentFileUri)?.name ?: \&quot;Untitled.docx\&quot;\n                            saveAsLauncher.launch(originalFileName)\n                        },\n                        enabled \u003d !isLoading \u0026\u0026 !isSaving\n                    ) {\n                        Text(if (isSaving) \&quot;Saving...\&quot; else \&quot;Save\&quot;)\n                    }\n                }\n            )\n        }\n    ) { paddingValues -\u003e\n        Column(\n            modifier \u003d Modifier\n                .fillMaxSize()\n                .padding(paddingValues)\n        ) {\n            FormattingToolbar(webView \u003d webView)\n            Box(modifier \u003d Modifier.weight(1f)) {\n                if (isLoading) {\n                    CircularProgressIndicator(modifier \u003d Modifier.align(Alignment.Center))\n                } else {\n                    AndroidView(\n                        factory \u003d { webViewContext -\u003e\n                            webView.apply {\n                                settings.javaScriptEnabled \u003d true\n                                settings.domStorageEnabled \u003d true\n                                settings.allowFileAccess \u003d true\n                                settings.defaultTextEncodingName \u003d \&quot;utf-8\&quot;\n                                settings.builtInZoomControls \u003d true\n                                settings.displayZoomControls \u003d false\n\n                                webViewClient \u003d object : android.webkit.WebViewClient() {\n                                    override fun onPageFinished(view: WebView?, url: String?) {\n                                        evaluateJavascript(\&quot;document.body.contentEditable \u003d true;\&quot;) {}\n                                    }\n                                }\n                                loadDataWithBaseURL(null, documentHtml, \&quot;text/html\&quot;, \&quot;utf-8\&quot;, null)\n                            }\n                        },\n                        modifier \u003d Modifier\n                            .fillMaxSize()\n                            .padding(horizontal \u003d 16.dp)\n                    )\n                }\n                if (isSaving) {\n                    Surface(modifier \u003d Modifier.fillMaxSize(), color \u003d MaterialTheme.colorScheme.surface.copy(alpha \u003d 0.8f)) {\n                        Column(\n                            modifier \u003d Modifier.fillMaxSize(),\n                            horizontalAlignment \u003d Alignment.CenterHorizontally,\n                            verticalArrangement \u003d Arrangement.Center\n                        ) {\n                            CircularProgressIndicator()\n                            Spacer(modifier \u003d Modifier.height(16.dp))\n                            Text(\&quot;Preparing to save...\&quot;)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun FormattingToolbar(webView: WebView) {\n    val fonts \u003d listOf(\&quot;Arial\&quot;, \&quot;Calibri\&quot;, \&quot;Courier New\&quot;, \&quot;Georgia\&quot;, \&quot;Times New Roman\&quot;, \&quot;Verdana\&quot;)\n    var selectedFont by remember { mutableStateOf(fonts[0]) }\n    var isFontDropdownExpanded by remember { mutableStateOf(false) }\n\n    var isBoldSelected by remember { mutableStateOf(false) }\n    var isItalicSelected by remember { mutableStateOf(false) }\n    var isUnderlineSelected by remember { mutableStateOf(false) }\n\n    Row(\n        modifier \u003d Modifier\n            .fillMaxWidth()\n            .padding(horizontal \u003d 8.dp, vertical \u003d 4.dp),\n        verticalAlignment \u003d Alignment.CenterVertically,\n        horizontalArrangement \u003d Arrangement.spacedBy(8.dp)\n    ) {\n        ExposedDropdownMenuBox(\n            expanded \u003d isFontDropdownExpanded,\n            onExpandedChange \u003d { isFontDropdownExpanded \u003d !isFontDropdownExpanded },\n            modifier \u003d Modifier.weight(1f)\n        ) {\n            OutlinedTextField(\n                value \u003d selectedFont,\n                onValueChange \u003d {},\n                readOnly \u003d true,\n                label \u003d { Text(\&quot;Font\&quot;) },\n                trailingIcon \u003d { ExposedDropdownMenuDefaults.TrailingIcon(expanded \u003d isFontDropdownExpanded) },\n                modifier \u003d Modifier.menuAnchor()\n            )\n            ExposedDropdownMenu(\n                expanded \u003d isFontDropdownExpanded,\n                onDismissRequest \u003d { isFontDropdownExpanded \u003d false }\n            ) {\n                fonts.forEach { fontName -\u003e\n                    DropdownMenuItem(\n                        text \u003d { Text(fontName) },\n                        onClick \u003d {\n                            selectedFont \u003d fontName\n                            isFontDropdownExpanded \u003d false\n                            webView.evaluateJavascript(\&quot;document.execCommand(\u0027fontName\u0027, false, \u0027$fontName\u0027);\&quot;, null)\n                        }\n                    )\n                }\n            }\n        }\n\n        IconButton(onClick \u003d {\n            isBoldSelected \u003d !isBoldSelected\n            webView.evaluateJavascript(\&quot;document.execCommand(\u0027bold\u0027);\&quot;, null)\n        }) {\n            Image(\n                painter \u003d painterResource(id \u003d R.drawable.bold),\n                contentDescription \u003d \&quot;Bold\&quot;,\n                colorFilter \u003d if (isBoldSelected) ColorFilter.tint(MaterialTheme.colorScheme.primary) else null\n            )\n        }\n\n        IconButton(onClick \u003d {\n            isItalicSelected \u003d !isItalicSelected\n            webView.evaluateJavascript(\&quot;document.execCommand(\u0027italic\u0027);\&quot;, null)\n        }) {\n            Icon(\n                painter \u003d painterResource(R.drawable.bold),\n                contentDescription \u003d \&quot;Italic\&quot;,\n                tint \u003d if (isItalicSelected) MaterialTheme.colorScheme.primary else Color.Unspecified\n            )\n        }\n\n        IconButton(onClick \u003d {\n            isUnderlineSelected \u003d !isUnderlineSelected\n            webView.evaluateJavascript(\&quot;document.execCommand(\u0027underline\u0027);\&quot;, null)\n        }) {\n            Icon(\n                painter \u003d painterResource(R.drawable.bold),\n                contentDescription \u003d \&quot;Underline\&quot;,\n                tint \u003d if (isUnderlineSelected) MaterialTheme.colorScheme.primary else Color.Unspecified\n            )\n        }\n    }\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// DOCX -\u003e HTML CONVERSION (Enhanced)\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nfun convertDocxToHtmlEnhanced(document: XWPFDocument): String {\n    val html \u003d StringBuilder()\n    html.append(\&quot;\u003c!DOCTYPE html\u003e\u003chtml\u003e\u003chead\u003e\&quot;)\n    html.append(\&quot;\u003cmeta charset\u003d\\\&quot;UTF-8\\\&quot;\u003e\&quot;)\n    html.append(\&quot;\u003cmeta name\u003d\\\&quot;viewport\\\&quot; content\u003d\\\&quot;width\u003ddevice-width, initial-scale\u003d1.0, user-scalable\u003dyes\\\&quot;\u003e\&quot;)\n    html.append(\&quot;\u003cstyle\u003e\&quot;)\n    html.append(\&quot;body { font-family: Arial, sans-serif; font-size: 12pt; margin: 0; padding: 20px; background: #f0f0f0; word-wrap: break-word; }\&quot;)\n    html.append(\&quot;.page { background: white; width: 21cm; min-height: 29.7cm; margin: 0 auto 20px auto; padding: 2.54cm; box-shadow: 0 4px 8px rgba(0,0,0,0.1); position: relative; page-break-after: always; overflow-wrap: break-word; }\&quot;)\n    html.append(\&quot;.page:last-child { page-break-after: auto; }\&quot;)\n    html.append(\&quot;p { margin-bottom: 0.5em; }\&quot;)\n    html.append(\&quot;table { border-collapse: collapse; width: 100%; margin-bottom: 1em; table-layout: fixed; }\&quot;)\n    html.append(\&quot;td, th { border: 1px solid #BFBFBF; padding: 6px 8px; vertical-align: top; text-align: left; word-wrap: break-word; font-size: 10pt; }\&quot;)\n    html.append(\&quot;img { max-width: 100%; height: auto; display: block; margin: 0.2em 0; }\&quot;)\n    html.append(\&quot;ul, ol { margin: 0.5em 0; padding-left: 2em; }\&quot;)\n    html.append(\&quot;li { margin-bottom: 0.25em; }\&quot;)\n    html.append(\&quot;h1, h2, h3, h4, h5, h6 { margin-top: 1em; margin-bottom: 0.5em; }\&quot;)\n    html.append(\&quot;.page-number { position: absolute; bottom: 1.27cm; right: 2.54cm; font-size: 10pt; color: #666; pointer-events: none; }\&quot;)\n    html.append(\&quot;\u003c/style\u003e\&quot;)\n    html.append(\&quot;\u003cscript\u003e\&quot;)\n    html.append(\&quot;let pageCounter \u003d 1;\&quot;)\n    html.append(\&quot;let isProcessing \u003d false;\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;function createNewPage() {\&quot;)\n    html.append(\&quot;  pageCounter++;\&quot;)\n    html.append(\&quot;  const newPage \u003d document.createElement(\u0027div\u0027);\&quot;)\n    html.append(\&quot;  newPage.className \u003d \u0027page\u0027;\&quot;)\n    html.append(\&quot;  newPage.id \u003d \u0027page\u0027 + pageCounter;\&quot;)\n    html.append(\&quot;  newPage.innerHTML \u003d \u0027\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u0027;\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  // Add page number\&quot;)\n    html.append(\&quot;  const pageNum \u003d document.createElement(\u0027div\u0027);\&quot;)\n    html.append(\&quot;  pageNum.className \u003d \u0027page-number\u0027;\&quot;)\n    html.append(\&quot;  pageNum.textContent \u003d pageCounter;\&quot;)\n    html.append(\&quot;  newPage.appendChild(pageNum);\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  document.body.appendChild(newPage);\&quot;)\n    html.append(\&quot;  return newPage;\&quot;)\n    html.append(\&quot;}\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;function updatePageNumbers() {\&quot;)\n    html.append(\&quot;  const pages \u003d document.querySelectorAll(\u0027.page\u0027);\&quot;)\n    html.append(\&quot;  pages.forEach((page, index) \u003d\u003e {\&quot;)\n    html.append(\&quot;    let pageNum \u003d page.querySelector(\u0027.page-number\u0027);\&quot;)\n    html.append(\&quot;    if (!pageNum) {\&quot;)\n    html.append(\&quot;      pageNum \u003d document.createElement(\u0027div\u0027);\&quot;)\n    html.append(\&quot;      pageNum.className \u003d \u0027page-number\u0027;\&quot;)\n    html.append(\&quot;      page.appendChild(pageNum);\&quot;)\n    html.append(\&quot;    }\&quot;)\n    html.append(\&quot;    pageNum.textContent \u003d index + 1;\&quot;)\n    html.append(\&quot;  });\&quot;)\n    html.append(\&quot;}\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;function checkPageOverflow() {\&quot;)\n    html.append(\&quot;  if (isProcessing) return;\&quot;)\n    html.append(\&quot;  isProcessing \u003d true;\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  const pages \u003d document.querySelectorAll(\u0027.page\u0027);\&quot;)\n    html.append(\&quot;  const pageHeight \u003d 29.7 * 37.795; // A4 height in pixels\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  pages.forEach((page, index) \u003d\u003e {\&quot;)\n    html.append(\&quot;    const contentHeight \u003d page.scrollHeight;\&quot;)\n    html.append(\&quot;    if (contentHeight \u003e pageHeight) {\&quot;)\n    html.append(\&quot;      // Create new page if it doesn\u0027t exist\&quot;)\n    html.append(\&quot;      let nextPage \u003d document.getElementById(\u0027page\u0027 + (index + 2));\&quot;)\n    html.append(\&quot;      if (!nextPage) {\&quot;)\n    html.append(\&quot;        nextPage \u003d createNewPage();\&quot;)\n    html.append(\&quot;      }\&quot;)\n    html.append(\&quot;      \&quot;)\n    html.append(\&quot;      // Move overflow content to next page\&quot;)\n    html.append(\&quot;      const elements \u003d Array.from(page.children);\&quot;)\n    html.append(\&quot;      let totalHeight \u003d 0;\&quot;)\n    html.append(\&quot;      let moveIndex \u003d -1;\&quot;)\n    html.append(\&quot;      \&quot;)\n    html.append(\&quot;      for (let i \u003d 0; i \u003c elements.length; i++) {\&quot;)\n    html.append(\&quot;        const elem \u003d elements[i];\&quot;)\n    html.append(\&quot;        if (elem.className \u003d\u003d\u003d \u0027page-number\u0027) continue;\&quot;)\n    html.append(\&quot;        \&quot;)\n    html.append(\&quot;        const elemHeight \u003d elem.offsetHeight;\&quot;)\n    html.append(\&quot;        if (totalHeight + elemHeight \u003e pageHeight - 100) {\&quot;) // Leave some margin\n    html.append(\&quot;          moveIndex \u003d i;\&quot;)\n    html.append(\&quot;          break;\&quot;)\n    html.append(\&quot;        }\&quot;)\n    html.append(\&quot;        totalHeight +\u003d elemHeight;\&quot;)\n    html.append(\&quot;      }\&quot;)\n    html.append(\&quot;      \&quot;)\n    html.append(\&quot;      if (moveIndex !\u003d\u003d -1) {\&quot;)\n    html.append(\&quot;        for (let i \u003d moveIndex; i \u003c elements.length; i++) {\&quot;)\n    html.append(\&quot;          const elem \u003d elements[i];\&quot;)\n    html.append(\&quot;          if (elem.className !\u003d\u003d \u0027page-number\u0027) {\&quot;)\n    html.append(\&quot;            nextPage.insertBefore(elem, nextPage.querySelector(\u0027.page-number\u0027));\&quot;)\n    html.append(\&quot;          }\&quot;)\n    html.append(\&quot;        }\&quot;)\n    html.append(\&quot;      }\&quot;)\n    html.append(\&quot;    }\&quot;)\n    html.append(\&quot;  });\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  updatePageNumbers();\&quot;)\n    html.append(\&quot;  isProcessing \u003d false;\&quot;)\n    html.append(\&quot;}\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;function ensureMinimumOnePage() {\&quot;)\n    html.append(\&quot;  if (document.querySelectorAll(\u0027.page\u0027).length \u003d\u003d\u003d 0) {\&quot;)\n    html.append(\&quot;    const firstPage \u003d document.createElement(\u0027div\u0027);\&quot;)\n    html.append(\&quot;    firstPage.className \u003d \u0027page\u0027;\&quot;)\n    html.append(\&quot;    firstPage.id \u003d \u0027page1\u0027;\&quot;)\n    html.append(\&quot;    firstPage.innerHTML \u003d \u0027\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u0027;\&quot;)\n    html.append(\&quot;    document.body.appendChild(firstPage);\&quot;)\n    html.append(\&quot;  }\&quot;)\n    html.append(\&quot;  updatePageNumbers();\&quot;)\n    html.append(\&quot;}\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;document.addEventListener(\u0027DOMContentLoaded\u0027, function() {\&quot;)\n    html.append(\&quot;  ensureMinimumOnePage();\&quot;)\n    html.append(\&quot;  setTimeout(checkPageOverflow, 500);\&quot;)\n    html.append(\&quot;});\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;document.addEventListener(\u0027input\u0027, function() {\&quot;)\n    html.append(\&quot;  setTimeout(checkPageOverflow, 300);\&quot;)\n    html.append(\&quot;});\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;document.addEventListener(\u0027keydown\u0027, function(e) {\&quot;)\n    html.append(\&quot;  if (e.ctrlKey \u0026\u0026 e.key \u003d\u003d\u003d \u0027Enter\u0027) {\&quot;)\n    html.append(\&quot;    e.preventDefault();\&quot;)\n    html.append(\&quot;    createNewPage();\&quot;)\n    html.append(\&quot;    updatePageNumbers();\&quot;)\n    html.append(\&quot;  }\&quot;)\n    html.append(\&quot;});\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;// Periodic check for content changes\&quot;)\n    html.append(\&quot;setInterval(checkPageOverflow, 2000);\&quot;)\n    html.append(\&quot;\u003c/script\u003e\&quot;)\n    html.append(\&quot;\u003c/head\u003e\u003cbody\u003e\&quot;)\n\n    html.append(\&quot;\u003cdiv class\u003d\u0027page\u0027 id\u003d\u0027page1\u0027\u003e\&quot;)\n\n    for (bodyElement in document.bodyElements) {\n        when (bodyElement) {\n            is XWPFParagraph -\u003e html.append(convertParagraphToHtmlExact(bodyElement))\n            is XWPFTable -\u003e html.append(convertTableToHtmlExact(bodyElement))\n        }\n    }\n\n    html.append(\&quot;\u003c/div\u003e\&quot;) // Close first page\n    html.append(\&quot;\u003c/body\u003e\u003c/html\u003e\&quot;)\n    return html.toString()\n}\n\nfun convertParagraphToHtmlExact(paragraph: XWPFParagraph): String {\n    val style \u003d buildString {\n        if (paragraph.spacingBefore \u003e 0) append(\&quot;margin-top: ${paragraph.spacingBefore / 20.0}pt; \&quot;)\n        if (paragraph.spacingAfter \u003e 0) append(\&quot;margin-bottom: ${paragraph.spacingAfter / 20.0}pt; \&quot;)\n        if (paragraph.spacingLineRule \u003d\u003d LineSpacingRule.AUTO \u0026\u0026 paragraph.spacingBetween \u003e 0) {\n            append(\&quot;line-height: ${paragraph.spacingBetween / 240.0}; \&quot;)\n        }\n        if (paragraph.alignment !\u003d ParagraphAlignment.LEFT) {\n            append(\&quot;text-align: ${paragraph.alignment.name.lowercase()}; \&quot;)\n        }\n    }\n    val pTag \u003d StringBuilder()\n    pTag.append(\&quot;\u003cp style\u003d\u0027${style}\u0027\u003e\&quot;)\n    var contentAdded \u003d false\n    for (run in paragraph.runs) {\n        val runHtml \u003d convertRunToHtmlExact(run)\n        if (runHtml.isNotBlank()) {\n            pTag.append(runHtml)\n            contentAdded \u003d true\n        }\n    }\n    if (!contentAdded \u0026\u0026 paragraph.text.isBlank()) {\n        pTag.append(\&quot;\u0026nbsp;\&quot;)\n    }\n    pTag.append(\&quot;\u003c/p\u003e\&quot;)\n    return pTag.toString()\n}\n\nfun convertRunToHtmlExact(run: XWPFRun): String {\n    val style \u003d buildString {\n        val fontSizeInPoints: Double? \u003d run.getFontSizeAsDouble()\n        if (fontSizeInPoints !\u003d null \u0026\u0026 fontSizeInPoints \u003e 0) {\n            append(\&quot;font-size: ${fontSizeInPoints}pt; \&quot;)\n        }\n        if (!run.fontFamily.isNullOrEmpty()) append(\&quot;font-family: \u0027${run.fontFamily}\u0027; \&quot;)\n        if (run.color !\u003d null \u0026\u0026 run.color !\u003d \&quot;auto\&quot;) append(\&quot;color: #${run.color}; \&quot;)\n        if (run.isBold) append(\&quot;font-weight: bold; \&quot;)\n        if (run.isItalic) append(\&quot;font-style: italic; \&quot;)\n        if (run.isStrikeThrough) append(\&quot;text-decoration: line-through; \&quot;)\n        if (run.underline !\u003d UnderlinePatterns.NONE \u0026\u0026 run.underline !\u003d null) append(\&quot;text-decoration: underline; \&quot;)\n    }\n    var text \u003d run.text() ?: \&quot;\&quot;\n    text \u003d text.replace(\&quot;\u0026\&quot;, \&quot;\u0026amp;\&quot;)\n        .replace(\&quot;\u003c\&quot;, \&quot;\u0026lt;\&quot;)\n        .replace(\&quot;\u003e\&quot;, \&quot;\u0026gt;\&quot;)\n        .replace(\&quot;\\\&quot;\&quot;, \&quot;\u0026quot;\&quot;)\n        .replace(\&quot;\\t\&quot;, \&quot;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\&quot;)\n        .replace(\&quot;\\n\&quot;, \&quot;\u003cbr\u003e\&quot;)\n    var html \u003d \&quot;\u003cspan style\u003d\u0027${style}\u0027\u003e$text\u003c/span\u003e\&quot;\n    when (run.getVerticalAlignment()) {\n        OfficeSTVerticalAlignRun.SUBSCRIPT -\u003e html \u003d \&quot;\u003csub\u003e$html\u003c/sub\u003e\&quot;\n        OfficeSTVerticalAlignRun.SUPERSCRIPT -\u003e html \u003d \&quot;\u003csup\u003e$html\u003c/sup\u003e\&quot;\n        else -\u003e {}\n    }\n    for (pic in run.embeddedPictures) {\n        try {\n            val picData \u003d pic.pictureData\n            val ext \u003d when (picData.pictureTypeEnum) {\n                PictureType.JPEG -\u003e \&quot;jpeg\&quot;\n                PictureType.PNG -\u003e \&quot;png\&quot;\n                PictureType.GIF -\u003e \&quot;gif\&quot;\n                PictureType.BMP -\u003e \&quot;bmp\&quot;\n                PictureType.WMF -\u003e \&quot;wmf\&quot;\n                PictureType.EMF -\u003e \&quot;emf\&quot;\n                PictureType.PICT -\u003e \&quot;pict\&quot;\n                PictureType.TIFF -\u003e \&quot;tiff\&quot;\n                else -\u003e \&quot;png\&quot;\n            }\n            val base64 \u003d Base64.encodeToString(picData.data, Base64.DEFAULT)\n            val xfrm \u003d pic.ctPicture?.spPr?.xfrm\n            var imgWidth \u003d \&quot;auto\&quot;\n            var imgHeight \u003d \&quot;auto\&quot;\n            if (xfrm?.ext !\u003d null) {\n                val widthEmu \u003d xfrm.ext.cx\n                val heightEmu \u003d xfrm.ext.cy\n                imgWidth \u003d \&quot;${widthEmu / Units.EMU_PER_PIXEL}px\&quot;\n                imgHeight \u003d \&quot;${heightEmu / Units.EMU_PER_PIXEL}px\&quot;\n            }\n            html +\u003d \&quot;\u003cimg src\u003d\u0027data:image/$ext;base64,$base64\u0027 width\u003d\u0027$imgWidth\u0027 height\u003d\u0027$imgHeight\u0027 alt\u003d\u0027${pic.description ?: \&quot;Embedded image\&quot;}\u0027 /\u003e\&quot;\n        } catch (e: Exception) {\n            Logger.e(\&quot;Error processing embedded picture: ${e.message}\&quot;, e)\n            html +\u003d \&quot;\u003c!-- Error loading image: ${e.message} --\u003e\&quot;\n        }\n    }\n    return html\n}\n\nfun convertTableToHtmlExact(table: XWPFTable): String {\n    val html \u003d StringBuilder(\&quot;\u003ctable\u003e\&quot;)\n    for (row in table.rows) {\n        html.append(\&quot;\u003ctr\u003e\&quot;)\n        for (cell in row.tableCells) {\n            html.append(\&quot;\u003ctd\u003e\&quot;)\n            cell.bodyElements.forEach { element -\u003e\n                when (element) {\n                    is XWPFParagraph -\u003e html.append(convertParagraphToHtmlExact(element))\n                    is XWPFTable -\u003e html.append(convertTableToHtmlExact(element))\n                }\n            }\n            html.append(\&quot;\u003c/td\u003e\&quot;)\n        }\n        html.append(\&quot;\u003c/tr\u003e\&quot;)\n    }\n    html.append(\&quot;\u003c/table\u003e\&quot;)\n    return html.toString()\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// ENHANCED HTML -\u003e DOCX CONVERSION WITH FULL FORMATTING SUPPORT\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nsuspend fun writeHtmlToDocx(context: Context, uri: Uri, htmlContent: String): Result\u003cUnit\u003e {\n    Logger.d(\&quot;Starting enhanced writeHtmlToDocx for $uri\&quot;)\n    return withContext(Dispatchers.IO) {\n        runCatching {\n            val rawHtml \u003d cleanHtmlContent(htmlContent)\n            Logger.d(\&quot;Cleaned HTML (first 500 chars): ${rawHtml.take(500)}\&quot;)\n\n            val jsoupDoc \u003d Jsoup.parse(rawHtml)\n\n            context.contentResolver.openOutputStream(uri)?.use { outputStream -\u003e\n                val document \u003d XWPFDocument()\n\n                // Set document defaults\n                setDocumentDefaults(document)\n\n                val body \u003d jsoupDoc.body()\n                val docContext \u003d DocumentContext()\n\n                // Parse with enhanced processor\n                parseEnhancedJsoupNode(body, document, null, context, docContext)\n\n                // Remove empty first paragraph if exists\n                removeEmptyFirstParagraph(document)\n\n                document.write(outputStream)\n                document.close()\n                Logger.i(\&quot;DOCX saved successfully to $uri with enhanced formatting\&quot;)\n            } ?: throw IOException(\&quot;Unable to open output stream for $uri\&quot;)\n        }.onFailure { e -\u003e\n            Logger.e(\&quot;Error in enhanced writeHtmlToDocx: ${e.message}\&quot;, e)\n        }\n    }\n}\n\n// Clean HTML content\nprivate fun cleanHtmlContent(htmlContent: String): String {\n    var cleaned \u003d htmlContent\n\n    if (cleaned.startsWith(\&quot;\\\&quot;\&quot;) \u0026\u0026 cleaned.endsWith(\&quot;\\\&quot;\&quot;)) {\n        cleaned \u003d cleaned.substring(1, cleaned.length - 1)\n    }\n\n    cleaned \u003d cleaned\n        .replace(\&quot;\\\\u003C\&quot;, \&quot;\u003c\&quot;)\n        .replace(\&quot;\\\\u003E\&quot;, \&quot;\u003e\&quot;)\n        .replace(\&quot;\\\\\\\&quot;\&quot;, \&quot;\\\&quot;\&quot;)\n        .replace(\&quot;\\\\n\&quot;, \&quot;\\n\&quot;)\n        .replace(\&quot;\\\\t\&quot;, \&quot;\\t\&quot;)\n        .replace(\&quot;\\\\r\&quot;, \&quot;\\r\&quot;)\n        .replace(\&quot;\u0026nbsp;\&quot;, \&quot; \&quot;)\n\n    return cleaned\n}\n\n// Set document defaults\nprivate fun setDocumentDefaults(document: XWPFDocument) {\n    try {\n        val ctDocument \u003d document.document\n        val ctBody \u003d ctDocument.body\n\n        val sectPr \u003d if (ctBody.isSetSectPr) ctBody.sectPr else ctBody.addNewSectPr()\n\n        // Set page size to A4 (210mm x 297mm \u003d 11906 twips x 16838 twips)\n        val pgSz \u003d if (sectPr.isSetPgSz) sectPr.pgSz else sectPr.addNewPgSz()\n        pgSz.w \u003d BigInteger.valueOf(11906) // A4 width in twips\n        pgSz.h \u003d BigInteger.valueOf(16838) // A4 height in twips\n\n        // Set margins (2.54cm \u003d 1440 twips)\n        val pgMar \u003d if (sectPr.isSetPgMar) sectPr.pgMar else sectPr.addNewPgMar()\n        pgMar.top \u003d BigInteger.valueOf(1440)    // 2.54cm\n        pgMar.bottom \u003d BigInteger.valueOf(1440) // 2.54cm\n        pgMar.left \u003d BigInteger.valueOf(1440)   // 2.54cm\n        pgMar.right \u003d BigInteger.valueOf(1440)  // 2.54cm\n\n    } catch (e: Exception) {\n        Logger.w(\&quot;Failed to set document defaults: ${e.message}\&quot;)\n    }\n}\n\n// Remove empty first paragraph\nprivate fun removeEmptyFirstParagraph(document: XWPFDocument) {\n    if (document.paragraphs.isNotEmpty()) {\n        val firstPara \u003d document.paragraphs[0]\n        if (firstPara.text.isBlank() \u0026\u0026 firstPara.runs.isEmpty()) {\n            if (document.bodyElements.size \u003e 0) {\n                document.removeBodyElement(0)\n            }\n        }\n    }\n}\n\n// Document context\ndata class DocumentContext(\n    var currentListLevel: Int \u003d 0,\n    var isInList: Boolean \u003d false,\n    var currentListType: ListType \u003d ListType.BULLET,\n    var preserveSpacing: Boolean \u003d true,\n    var numberingMap: MutableMap\u003cString, Int\u003e \u003d mutableMapOf()\n)\n\nenum class ListType {\n    BULLET, NUMBERED\n}\n\n// Enhanced HTML node parser with full formatting support\nprivate fun parseEnhancedJsoupNode(\n    jsoupNode: Node,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    context: Context,\n    docContext: DocumentContext\n): XWPFParagraph? {\n    var paragraph \u003d currentParagraph\n\n    when (jsoupNode) {\n        is TextNode -\u003e {\n            val text \u003d jsoupNode.text().replace(\&quot;\\u00A0\&quot;, \&quot; \&quot;)\n            if (text.isNotEmpty() || docContext.preserveSpacing) {\n                paragraph \u003d paragraph ?: document.createParagraph()\n                val run \u003d paragraph.createRun()\n                run.setText(text)\n            }\n        }\n\n        is Element -\u003e {\n            val tagName \u003d jsoupNode.tagName().lowercase()\n\n            paragraph \u003d when (tagName) {\n                // Block elements\n                \&quot;p\&quot;, \&quot;div\&quot; -\u003e handleParagraphElement(jsoupNode, document, docContext, context)\n                \&quot;br\&quot; -\u003e handleLineBreak(document, paragraph)\n\n                // Headings\n                \&quot;h1\&quot;, \&quot;h2\&quot;, \&quot;h3\&quot;, \&quot;h4\&quot;, \&quot;h5\&quot;, \&quot;h6\&quot; -\u003e handleHeading(jsoupNode, document, tagName, docContext, context)\n\n                // Lists\n                \&quot;ul\&quot; -\u003e handleUnorderedList(jsoupNode, document, docContext, context)\n                \&quot;ol\&quot; -\u003e handleOrderedList(jsoupNode, document, docContext, context)\n                \&quot;li\&quot; -\u003e handleListItem(jsoupNode, document, paragraph, docContext, context)\n\n                // Tables\n                \&quot;table\&quot; -\u003e {\n                    handleTable(jsoupNode, document, context, docContext)\n                    null\n                }\n\n                // Inline formatting\n                \&quot;span\&quot;, \&quot;strong\&quot;, \&quot;b\&quot;, \&quot;em\&quot;, \&quot;i\&quot;, \&quot;u\&quot;, \&quot;s\&quot;, \&quot;strike\&quot;, \&quot;del\&quot;,\n                \&quot;sub\&quot;, \&quot;sup\&quot;, \&quot;code\&quot;, \&quot;mark\&quot; -\u003e handleInlineFormatting(jsoupNode, document, paragraph, docContext, context)\n\n                // Images\n                \&quot;img\&quot; -\u003e {\n                    handleImage(jsoupNode, document, context)\n                    null\n                }\n\n                // Blockquote\n                \&quot;blockquote\&quot; -\u003e handleBlockquote(jsoupNode, document, docContext, context)\n\n                // Horizontal rule\n                \&quot;hr\&quot; -\u003e {\n                    handleHorizontalRule(document)\n                    null\n                }\n\n                else -\u003e {\n                    // For unknown elements, process children\n                    for (child in jsoupNode.childNodes()) {\n                        paragraph \u003d parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n                    }\n                    paragraph\n                }\n            }\n        }\n    }\n\n    return paragraph\n}\n\n// Handle paragraph element\nprivate fun handleParagraphElement(\n    element: Element,\n    document: XWPFDocument,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph {\n    val paragraph \u003d document.createParagraph()\n    applyParagraphStyle(paragraph, element)\n\n    for (child in element.childNodes()) {\n        parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n    }\n\n    return paragraph\n}\n\n// Handle line break\nprivate fun handleLineBreak(document: XWPFDocument, currentParagraph: XWPFParagraph?): XWPFParagraph {\n    val paragraph \u003d currentParagraph ?: document.createParagraph()\n    val run \u003d paragraph.createRun()\n    run.addBreak()\n    return paragraph\n}\n\n// Handle headings\nprivate fun handleHeading(\n    element: Element,\n    document: XWPFDocument,\n    tagName: String,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph {\n    val paragraph \u003d document.createParagraph()\n    val level \u003d tagName.substring(1).toIntOrNull() ?: 1\n\n    val fontSize \u003d when (level) {\n        1 -\u003e 22\n        2 -\u003e 18\n        3 -\u003e 16\n        4 -\u003e 14\n        5 -\u003e 12\n        else -\u003e 10\n    }\n\n    applyParagraphStyle(paragraph, element)\n\n    for (child in element.childNodes()) {\n        parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n    }\n\n    // Apply heading formatting to all runs\n    paragraph.runs.forEach { run -\u003e\n        run.isBold \u003d true\n        if (run.fontSize \u003c\u003d 0) {\n            run.fontSize \u003d fontSize\n        }\n    }\n\n    return paragraph\n}\n\n// Handle unordered list\nprivate fun handleUnorderedList(\n    element: Element,\n    document: XWPFDocument,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph? {\n    val previousContext \u003d docContext.copy()\n    docContext.isInList \u003d true\n    docContext.currentListType \u003d ListType.BULLET\n    docContext.currentListLevel++\n\n    var lastParagraph: XWPFParagraph? \u003d null\n    for (child in element.children()) {\n        if (child.tagName().equals(\&quot;li\&quot;, ignoreCase \u003d true)) {\n            lastParagraph \u003d handleListItem(child, document, null, docContext, context)\n        }\n    }\n\n    docContext.currentListLevel \u003d previousContext.currentListLevel\n    docContext.isInList \u003d previousContext.isInList\n    docContext.currentListType \u003d previousContext.currentListType\n\n    return lastParagraph\n}\n\n// Handle ordered list\nprivate fun handleOrderedList(\n    element: Element,\n    document: XWPFDocument,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph? {\n    val previousContext \u003d docContext.copy()\n    docContext.isInList \u003d true\n    docContext.currentListType \u003d ListType.NUMBERED\n    docContext.currentListLevel++\n\n    var lastParagraph: XWPFParagraph? \u003d null\n    for (child in element.children()) {\n        if (child.tagName().equals(\&quot;li\&quot;, ignoreCase \u003d true)) {\n            lastParagraph \u003d handleListItem(child, document, null, docContext, context)\n        }\n    }\n\n    docContext.currentListLevel \u003d previousContext.currentListLevel\n    docContext.isInList \u003d previousContext.isInList\n    docContext.currentListType \u003d previousContext.currentListType\n\n    return lastParagraph\n}\n\n// Handle list item\nprivate fun handleListItem(\n    element: Element,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph {\n    val paragraph \u003d document.createParagraph()\n\n    // Set numbering\n    try {\n//        val numId \u003d getOrCreateNumbering(document, docContext)\n//        paragraph.numID \u003d BigInteger.valueOf(numId.toLong())\n//        paragraph.numILvl \u003d BigInteger.valueOf((docContext.currentListLevel - 1).toLong())\n    } catch (e: Exception) {\n        Logger.w(\&quot;Failed to apply numbering: ${e.message}\&quot;)\n        // Fallback: add bullet/number manually\n        val run \u003d paragraph.createRun()\n        run.setText(if (docContext.currentListType \u003d\u003d ListType.BULLET) \&quot; \&quot; else \&quot;${docContext.currentListLevel}. \&quot;)\n    }\n\n    // Set indentation\n    paragraph.indentationLeft \u003d 720 * docContext.currentListLevel\n\n    for (child in element.childNodes()) {\n        parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n    }\n\n    return paragraph\n}\n\n// Get or create numbering\n//private fun getOrCreateNumbering(document: XWPFDocument, docContext: DocumentContext): Int {\n//    val key \u003d \&quot;${docContext.currentListType}_${docContext.currentListLevel}\&quot;\n//\n//    return docContext.numberingMap.getOrPut(key) {\n//        try {\n//            val numbering \u003d document.createNumbering()\n//            val abstractNumId \u003d numbering.addAbstractNum()\n//            numbering.addNum(abstractNumId)\n//        } catch (e: Exception) {\n//            1\n//        }\n//    }\n//}\n\n// Handle table with full formatting\nprivate fun handleTable(\n    element: Element,\n    document: XWPFDocument,\n    context: Context,\n    docContext: DocumentContext\n) {\n    try {\n        val rows \u003d element.select(\&quot;tr\&quot;)\n        if (rows.isEmpty()) return\n\n        val firstRow \u003d rows.first()\n        val columns \u003d firstRow?.select(\&quot;td, th\&quot;)?.size ?: 0\n\n        val table \u003d document.createTable(rows.size, columns)\n\n        // Set table properties\n        table.width \u003d 5000\n\n        rows.forEachIndexed { rowIndex, rowElement -\u003e\n            val tableRow \u003d table.getRow(rowIndex)\n            val cells \u003d rowElement.select(\&quot;td, th\&quot;)\n\n            cells.forEachIndexed { colIndex, cellElement -\u003e\n                if (colIndex \u003c tableRow.tableCells.size) {\n                    val cell \u003d tableRow.getCell(colIndex)\n\n                    // Apply cell styling\n                    applyCellStyle(cell, cellElement)\n\n                    // Clear default paragraph\n                    if (cell.paragraphs.isNotEmpty()) {\n                        cell.removeParagraph(0)\n                    }\n\n                    // Parse cell content directly in the cell context\n                    var cellParagraph: XWPFParagraph? \u003d null\n\n                    for (child in cellElement.childNodes()) {\n                        cellParagraph \u003d parseEnhancedJsoupNodeInCell(\n                            child,\n                            cell,\n                            cellParagraph,\n                            context,\n                            docContext\n                        )\n                    }\n\n                    // Make header cells bold\n                    if (cellElement.tagName().equals(\&quot;th\&quot;, ignoreCase \u003d true)) {\n                        cell.paragraphs.forEach { para -\u003e\n                            para.runs.forEach { run -\u003e\n                                run.isBold \u003d true\n                            }\n                        }\n                    }\n\n                    // Ensure cell has at least one paragraph\n                    if (cell.paragraphs.isEmpty()) {\n                        cell.addParagraph()\n                    }\n                }\n            }\n        }\n    } catch (e: Exception) {\n        Logger.e(\&quot;Error creating table: ${e.message}\&quot;, e)\n    }\n}\n\n// Enhanced HTML node parser specifically for table cells to handle images correctly\nprivate fun parseEnhancedJsoupNodeInCell(\n    jsoupNode: Node,\n    cell: XWPFTableCell,\n    currentParagraph: XWPFParagraph?,\n    context: Context,\n    docContext: DocumentContext\n): XWPFParagraph? {\n    var paragraph \u003d currentParagraph\n\n    when (jsoupNode) {\n        is TextNode -\u003e {\n            val text \u003d jsoupNode.text().replace(\&quot;\\u00A0\&quot;, \&quot; \&quot;)\n            if (text.isNotEmpty() || docContext.preserveSpacing) {\n                paragraph \u003d paragraph ?: cell.addParagraph()\n                val run \u003d paragraph.createRun()\n                run.setText(text)\n            }\n        }\n\n        is Element -\u003e {\n            val tagName \u003d jsoupNode.tagName().lowercase()\n\n            paragraph \u003d when (tagName) {\n                // Block elements\n                \&quot;p\&quot;, \&quot;div\&quot; -\u003e {\n                    val newParagraph \u003d cell.addParagraph()\n                    applyParagraphStyle(newParagraph, jsoupNode)\n\n                    for (child in jsoupNode.childNodes()) {\n                        paragraph \u003d parseEnhancedJsoupNodeInCell(\n                            child,\n                            cell,\n                            newParagraph,\n                            context,\n                            docContext\n                        )\n                    }\n                    newParagraph\n                }\n\n                \&quot;br\&quot; -\u003e {\n                    val para \u003d paragraph ?: cell.addParagraph()\n                    val run \u003d para.createRun()\n                    run.addBreak()\n                    para\n                }\n\n                // Images - handle directly in cell\n                \&quot;img\&quot; -\u003e {\n                    val imagePara \u003d paragraph ?: cell.addParagraph()\n                    handleImageInCell(jsoupNode, imagePara, context)\n                    imagePara\n                }\n\n                // Inline formatting\n                \&quot;span\&quot;, \&quot;strong\&quot;, \&quot;b\&quot;, \&quot;em\&quot;, \&quot;i\&quot;, \&quot;u\&quot;, \&quot;s\&quot;, \&quot;strike\&quot;, \&quot;del\&quot;,\n                \&quot;sub\&quot;, \&quot;sup\&quot;, \&quot;code\&quot;, \&quot;mark\&quot; -\u003e {\n                    val para \u003d paragraph ?: cell.addParagraph()\n\n                    for (child in jsoupNode.childNodes()) {\n                        when (child) {\n                            is TextNode -\u003e {\n                                val run \u003d para.createRun()\n                                run.setText(child.text())\n                                applyRunFormatting(run, jsoupNode)\n                            }\n\n                            is Element -\u003e {\n                                paragraph \u003d parseEnhancedJsoupNodeInCell(\n                                    child,\n                                    cell,\n                                    para,\n                                    context,\n                                    docContext\n                                )\n                            }\n                        }\n                    }\n                    para\n                }\n\n                else -\u003e {\n                    // For unknown elements, process children\n                    for (child in jsoupNode.childNodes()) {\n                        paragraph \u003d parseEnhancedJsoupNodeInCell(\n                            child,\n                            cell,\n                            paragraph,\n                            context,\n                            docContext\n                        )\n                    }\n                    paragraph\n                }\n            }\n        }\n    }\n\n    return paragraph\n}\n\n// Handle image specifically within a table cell paragraph\nprivate fun handleImageInCell(element: Element, paragraph: XWPFParagraph, context: Context) {\n    try {\n        val src \u003d element.attr(\&quot;src\&quot;)\n\n        if (src.startsWith(\&quot;data:image\&quot;)) {\n            val parts \u003d src.split(\&quot;,\&quot;)\n            if (parts.size \u003d\u003d 2) {\n                val meta \u003d parts[0]\n                val base64Data \u003d parts[1]\n                val decodedData \u003d Base64.decode(base64Data, Base64.DEFAULT)\n\n                val pictureType \u003d when {\n                    meta.contains(\&quot;jpeg\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_JPEG\n                    meta.contains(\&quot;png\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                    meta.contains(\&quot;gif\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_GIF\n                    meta.contains(\&quot;bmp\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_BMP\n                    meta.contains(\&quot;tiff\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_TIFF\n                    else -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                }\n\n                val widthPx \u003d element.attr(\&quot;width\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 200\n                val heightPx \u003d element.attr(\&quot;height\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 150\n                val widthEmu \u003d widthPx * Units.EMU_PER_PIXEL\n                val heightEmu \u003d heightPx * Units.EMU_PER_PIXEL\n\n                paragraph.createRun().addPicture(\n                    ByteArrayInputStream(decodedData),\n                    pictureType,\n                    \&quot;image.dat\&quot;,\n                    widthEmu,\n                    heightEmu\n                )\n            }\n        }\n    } catch (e: Exception) {\n        Logger.e(\&quot;Error processing image in cell: ${e.message}\&quot;, e)\n    }\n}\n\n// Handle inline formatting\nprivate fun handleInlineFormatting(\n    element: Element,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph {\n    val paragraph \u003d currentParagraph ?: document.createParagraph()\n\n    for (child in element.childNodes()) {\n        when (child) {\n            is TextNode -\u003e {\n                val run \u003d paragraph.createRun()\n                run.setText(child.text())\n                applyRunFormatting(run, element)\n            }\n            is Element -\u003e {\n                parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n            }\n        }\n    }\n\n    // Apply formatting to runs that were just created\n    val tagName \u003d element.tagName().lowercase()\n    if (tagName in listOf(\&quot;span\&quot;, \&quot;strong\&quot;, \&quot;b\&quot;, \&quot;em\&quot;, \&quot;i\&quot;, \&quot;u\&quot;, \&quot;s\&quot;, \&quot;strike\&quot;, \&quot;del\&quot;, \&quot;sub\&quot;, \&quot;sup\&quot;, \&quot;code\&quot;, \&quot;mark\&quot;)) {\n        // Get recently created runs for this element\n        val recentRunCount \u003d element.childNodes().filterIsInstance\u003cTextNode\u003e().size\n        if (recentRunCount \u003e 0 \u0026\u0026 paragraph.runs.size \u003e\u003d recentRunCount) {\n            val runsToFormat \u003d paragraph.runs.takeLast(recentRunCount)\n            runsToFormat.forEach { run -\u003e\n                applyRunFormatting(run, element)\n            }\n        }\n    }\n\n    return paragraph\n}\n\n// Apply run formatting\nprivate fun applyRunFormatting(run: XWPFRun, element: Element) {\n    val tagName \u003d element.tagName().lowercase()\n    val style \u003d element.attr(\&quot;style\&quot;)\n\n    when (tagName) {\n        \&quot;strong\&quot;, \&quot;b\&quot; -\u003e run.isBold \u003d true\n        \&quot;em\&quot;, \&quot;i\&quot; -\u003e run.isItalic \u003d true\n        \&quot;u\&quot; -\u003e run.underline \u003d UnderlinePatterns.SINGLE\n        \&quot;s\&quot;, \&quot;strike\&quot;, \&quot;del\&quot; -\u003e run.isStrikeThrough \u003d true\n//        \&quot;sub\&quot; -\u003e run.subscript \u003d VerticalAlign.SUBSCRIPT\n//        \&quot;sup\&quot; -\u003e run.subscript \u003d VerticalAlign.SUPERSCRIPT\n        \&quot;code\&quot; -\u003e {\n            run.fontFamily \u003d \&quot;Courier New\&quot;\n            if (run.fontSize \u003c\u003d 0) run.fontSize \u003d 10\n        }\n        \&quot;mark\&quot; -\u003e {\n            try {\n                run.setTextHighlightColor(\&quot;yellow\&quot;)\n            } catch (e: Exception) {\n                Logger.w(\&quot;Failed to set highlight: ${e.message}\&quot;)\n            }\n        }\n    }\n\n    // Parse inline styles\n    if (style.isNotBlank()) {\n        applyInlineStyle(run, style)\n    }\n\n    // Apply color attribute\n    val color \u003d element.attr(\&quot;color\&quot;)\n    if (color.isNotBlank()) {\n        run.color \u003d color.replace(\&quot;#\&quot;, \&quot;\&quot;)\n    }\n}\n\n// Apply inline CSS styles\nprivate fun applyInlineStyle(run: XWPFRun, style: String) {\n    val styles \u003d style.split(\&quot;;\&quot;).associate {\n        val parts \u003d it.split(\&quot;:\&quot;)\n        if (parts.size \u003d\u003d 2) {\n            parts[0].trim().lowercase() to parts[1].trim()\n        } else {\n            \&quot;\&quot; to \&quot;\&quot;\n        }\n    }\n\n    styles[\&quot;font-weight\&quot;]?.let {\n        if (it.contains(\&quot;bold\&quot;, ignoreCase \u003d true) || it.toIntOrNull()?.let { w -\u003e w \u003e\u003d 600 } \u003d\u003d true) {\n            run.isBold \u003d true\n        }\n    }\n\n    styles[\&quot;font-style\&quot;]?.let {\n        if (it.contains(\&quot;italic\&quot;, ignoreCase \u003d true)) {\n            run.isItalic \u003d true\n        }\n    }\n\n    styles[\&quot;text-decoration\&quot;]?.let {\n        when {\n            it.contains(\&quot;underline\&quot;, ignoreCase \u003d true) -\u003e run.underline \u003d UnderlinePatterns.SINGLE\n            it.contains(\&quot;line-through\&quot;, ignoreCase \u003d true) -\u003e run.isStrikeThrough \u003d true\n        }\n    }\n\n    styles[\&quot;font-size\&quot;]?.let {\n        val size \u003d when {\n            it.endsWith(\&quot;pt\&quot;) -\u003e it.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.toInt()\n            it.endsWith(\&quot;px\&quot;) -\u003e (it.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(0.75))?.toInt()\n            else -\u003e null\n        }\n        size?.let { s -\u003e run.fontSize \u003d s }\n    }\n\n    styles[\&quot;font-family\&quot;]?.let {\n        run.fontFamily \u003d it.replace(\&quot;\u0027\&quot;, \&quot;\&quot;).replace(\&quot;\\\&quot;\&quot;, \&quot;\&quot;).split(\&quot;,\&quot;)[0].trim()\n    }\n\n    styles[\&quot;color\&quot;]?.let {\n        val colorValue \u003d it.replace(\&quot;#\&quot;, \&quot;\&quot;).trim()\n        if (colorValue.length \u003d\u003d 6 || colorValue.length \u003d\u003d 3) {\n            run.color \u003d colorValue\n        }\n    }\n}\n\n// Handle image\nprivate fun handleImage(element: Element, document: XWPFDocument, context: Context) {\n    try {\n        val src \u003d element.attr(\&quot;src\&quot;)\n\n        if (src.startsWith(\&quot;data:image\&quot;)) {\n            val parts \u003d src.split(\&quot;,\&quot;)\n            if (parts.size \u003d\u003d 2) {\n                val meta \u003d parts[0]\n                val base64Data \u003d parts[1]\n                val decodedData \u003d Base64.decode(base64Data, Base64.DEFAULT)\n\n                val pictureType \u003d when {\n                    meta.contains(\&quot;jpeg\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_JPEG\n                    meta.contains(\&quot;png\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                    meta.contains(\&quot;gif\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_GIF\n                    meta.contains(\&quot;bmp\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_BMP\n                    meta.contains(\&quot;tiff\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_TIFF\n                    else -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                }\n\n                val widthPx \u003d element.attr(\&quot;width\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 200\n                val heightPx \u003d element.attr(\&quot;height\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 150\n                val widthEmu \u003d widthPx * Units.EMU_PER_PIXEL\n                val heightEmu \u003d heightPx * Units.EMU_PER_PIXEL\n\n                val imageParagraph \u003d document.createParagraph()\n                imageParagraph.createRun().addPicture(\n                    ByteArrayInputStream(decodedData),\n                    pictureType,\n                    \&quot;image.dat\&quot;,\n                    widthEmu,\n                    heightEmu\n                )\n            }\n        }\n    } catch (e: Exception) {\n        Logger.e(\&quot;Error processing image: ${e.message}\&quot;, e)\n    }\n}\n\n// Handle blockquote\nprivate fun handleBlockquote(\n    element: Element,\n    document: XWPFDocument,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph? {\n    var lastParagraph: XWPFParagraph? \u003d null\n\n    for (child in element.childNodes()) {\n        lastParagraph \u003d parseEnhancedJsoupNode(child, document, lastParagraph, context, docContext)\n        lastParagraph?.let { para -\u003e\n            para.indentationLeft \u003d 720 // Indent blockquote\n            para.borderLeft \u003d Borders.SINGLE\n        }\n    }\n\n    return lastParagraph\n}\n\n// Handle horizontal rule\nprivate fun handleHorizontalRule(document: XWPFDocument): XWPFParagraph {\n    val paragraph \u003d document.createParagraph()\n    paragraph.borderBottom \u003d Borders.SINGLE\n    return paragraph\n}\n\n// Apply paragraph style from HTML element\nprivate fun applyParagraphStyle(paragraph: XWPFParagraph, element: Element) {\n    val style \u003d element.attr(\&quot;style\&quot;)\n\n    if (style.isNotBlank()) {\n        val styles \u003d style.split(\&quot;;\&quot;).associate {\n            val parts \u003d it.split(\&quot;:\&quot;)\n            if (parts.size \u003d\u003d 2) {\n                parts[0].trim().lowercase() to parts[1].trim()\n            } else {\n                \&quot;\&quot; to \&quot;\&quot;\n            }\n        }\n\n        styles[\&quot;text-align\&quot;]?.let {\n            paragraph.alignment \u003d when (it.lowercase()) {\n                \&quot;center\&quot; -\u003e ParagraphAlignment.CENTER\n                \&quot;right\&quot; -\u003e ParagraphAlignment.RIGHT\n                \&quot;justify\&quot; -\u003e ParagraphAlignment.BOTH\n                \&quot;left\&quot; -\u003e ParagraphAlignment.LEFT\n                else -\u003e paragraph.alignment\n            }\n        }\n\n        styles[\&quot;margin-top\&quot;]?.let {\n            val spacing \u003d when {\n                it.endsWith(\&quot;pt\&quot;) -\u003e it.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20)?.toInt()\n                it.endsWith(\&quot;px\&quot;) -\u003e it.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(15)?.toInt()\n                else -\u003e null\n            }\n            spacing?.let { s -\u003e paragraph.spacingBefore \u003d s }\n        }\n\n        styles[\&quot;margin-bottom\&quot;]?.let {\n            val spacing \u003d when {\n                it.endsWith(\&quot;pt\&quot;) -\u003e it.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20)?.toInt()\n                it.endsWith(\&quot;px\&quot;) -\u003e it.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(15)?.toInt()\n                else -\u003e null\n            }\n            spacing?.let { s -\u003e paragraph.spacingAfter \u003d s }\n        }\n\n        styles[\&quot;line-height\&quot;]?.let {\n            val lineHeightValue \u003d it.toDoubleOrNull()\n            lineHeightValue?.let { lh -\u003e\n                paragraph.setSpacingBetween(lh * 240, LineSpacingRule.AUTO)\n            }\n        }\n    }\n\n    // Apply alignment from attribute\n    val align \u003d element.attr(\&quot;align\&quot;)\n    if (align.isNotBlank()) {\n        paragraph.alignment \u003d when (align.lowercase()) {\n            \&quot;center\&quot; -\u003e ParagraphAlignment.CENTER\n            \&quot;right\&quot; -\u003e ParagraphAlignment.RIGHT\n            \&quot;justify\&quot; -\u003e ParagraphAlignment.BOTH\n            \&quot;left\&quot; -\u003e ParagraphAlignment.LEFT\n            else -\u003e paragraph.alignment\n        }\n    }\n}\n\n// Apply cell style\nprivate fun applyCellStyle(cell: XWPFTableCell, element: Element) {\n    try {\n        // Background color\n        val bgColor \u003d element.attr(\&quot;bgcolor\&quot;)\n        if (bgColor.isNotBlank()) {\n            cell.color \u003d bgColor.replace(\&quot;#\&quot;, \&quot;\&quot;)\n        }\n\n        // Parse style attribute for background color\n        val style \u003d element.attr(\&quot;style\&quot;)\n        if (style.contains(\&quot;background-color\&quot;)) {\n            val bgMatch \u003d Regex(\&quot;background-color:\\\\s*#?([0-9A-Fa-f]{6})\&quot;).find(style)\n            bgMatch?.let {\n                cell.color \u003d it.groupValues[1]\n            }\n        }\n\n        // Set cell margins\n        val ctTc \u003d cell.ctTc\n        val tcPr \u003d ctTc.tcPr ?: ctTc.addNewTcPr()\n        val tcMar \u003d tcPr.tcMar ?: tcPr.addNewTcMar()\n\n        tcMar.left \u003d CTTblWidth.Factory.newInstance().apply {\n            w \u003d BigInteger.valueOf(100)\n            type \u003d STTblWidth.DXA\n        }\n        tcMar.right \u003d CTTblWidth.Factory.newInstance().apply {\n            w \u003d BigInteger.valueOf(100)\n            type \u003d STTblWidth.DXA\n        }\n    } catch (e: Exception) {\n        Logger.w(\&quot;Failed to apply cell style: ${e.message}\&quot;)\n    }\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// LEGACY FUNCTIONS (Keep for backward compatibility)\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nprivate fun parseJsoupNode(\n    jsoupNode: Node,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    context: Context\n) {\n    // Use enhanced parser\n    val docContext \u003d DocumentContext()\n    parseEnhancedJsoupNode(jsoupNode, document, currentParagraph, context, docContext)\n}\n\nprivate fun applyParagraphAlignment(element: Element, paragraph: XWPFParagraph?) {\n    if (paragraph \u003d\u003d null) return\n    applyParagraphStyle(paragraph, element)\n}\n\nfun parseStyleAndApply(styleAttribute: String, paragraph: XWPFParagraph?, run: XWPFRun?) {\n    if (run \u003d\u003d null \u0026\u0026 paragraph \u003d\u003d null) return\n\n    styleAttribute.split(\u0027;\u0027).map { it.trim() }.filter { it.isNotEmpty() }.forEach { style -\u003e\n        val parts \u003d style.split(\u0027:\u0027).map { it.trim() }\n        if (parts.size \u003d\u003d 2) {\n            val property \u003d parts[0].lowercase()\n            val value \u003d parts[1]\n            try {\n                when (property) {\n                    // Run-specific styles\n                    \&quot;color\&quot; -\u003e if (value.startsWith(\&quot;#\&quot;) \u0026\u0026 (value.length \u003d\u003d 7 || value.length \u003d\u003d 4)) {\n                        run?.setColor(value.removePrefix(\&quot;#\&quot;))\n                    }\n                    \&quot;font-weight\&quot; -\u003e if (value \u003d\u003d \&quot;bold\&quot; || (value.toIntOrNull() ?: 400) \u003e\u003d 600) {\n                        run?.isBold \u003d true\n                    }\n                    \&quot;font-style\&quot; -\u003e if (value \u003d\u003d \&quot;italic\&quot;) {\n                        run?.isItalic \u003d true\n                    }\n                    \&quot;font-size\&quot; -\u003e {\n                        val size \u003d when {\n                            value.endsWith(\&quot;pt\&quot;) -\u003e value.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.toInt()\n                            value.endsWith(\&quot;px\&quot;) -\u003e (value.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(0.75))?.toInt()\n                            else -\u003e null\n                        }\n                        if (size !\u003d null) run?.fontSize \u003d size\n                    }\n                    \&quot;font-family\&quot; -\u003e run?.fontFamily \u003d value.replace(\&quot;\\\u0027\&quot;, \&quot;\&quot;).split(\&quot;,\&quot;)[0].trim()\n                    \&quot;text-decoration\&quot;, \&quot;text-decoration-line\&quot; -\u003e {\n                        if (value.contains(\&quot;underline\&quot;)) run?.underline \u003d UnderlinePatterns.SINGLE\n                        if (value.contains(\&quot;line-through\&quot;)) run?.isStrikeThrough \u003d true\n                    }\n                    // Paragraph-specific styles\n                    \&quot;margin-top\&quot; -\u003e {\n                        if (paragraph !\u003d null \u0026\u0026 value.endsWith(\&quot;pt\&quot;)) {\n                            paragraph.spacingBefore \u003d (value.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20))?.toInt() ?: paragraph.spacingBefore\n                        }\n                    }\n                    \&quot;margin-bottom\&quot; -\u003e {\n                        if (paragraph !\u003d null \u0026\u0026 value.endsWith(\&quot;pt\&quot;)) {\n                            paragraph.spacingAfter \u003d (value.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20))?.toInt() ?: paragraph.spacingAfter\n                        }\n                    }\n                    \&quot;line-height\&quot; -\u003e {\n                        if (paragraph !\u003d null) {\n                            val lineHeightValue \u003d value.toDoubleOrNull()\n                            if (lineHeightValue !\u003d null) {\n                                paragraph.setSpacingBetween(lineHeightValue * 240, LineSpacingRule.AUTO)\n                            }\n                        }\n                    }\n                }\n            } catch (e: Exception) {\n                Logger.w(\&quot;Failed to parse style: $property \u003d $value. Error: ${e.message}\&quot;)\n            }\n        }\n    }\n}&quot;},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;read_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01SE1gnKi8AXyNq27gjGiA7r&quot;,&quot;content&quot;:&quot;// util/DocxUtil.kt\npackage com.example.docx.util\n\nimport android.content.Context\nimport android.net.Uri\nimport android.util.Base64\nimport android.widget.Toast\nimport androidx.documentfile.provider.DocumentFile\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\nimport org.apache.commons.text.StringEscapeUtils\nimport org.apache.poi.xwpf.usermodel.*\nimport org.jsoup.Jsoup\nimport org.jsoup.nodes.Element\nimport org.jsoup.nodes.TextNode\nimport java.io.ByteArrayOutputStream\nimport java.io.IOException\nimport java.util.*\n\n// Existing functions (read/write) remain unchanged\nsuspend fun readDocxContent(context: Context, uri: Uri): Result\u003cString\u003e \u003d withContext(Dispatchers.IO) {\n    try {\n        val documentFile \u003d DocumentFile.fromSingleUri(context, uri)\n        if (documentFile?.exists() !\u003d true) {\n            return@withContext Result.failure(Exception(\&quot;Document not found or inaccessible\&quot;))\n        }\n\n        context.contentResolver.openInputStream(uri)?.use { inputStream -\u003e\n            val document \u003d XWPFDocument(inputStream)\n            val textBuilder \u003d StringBuilder()\n\n            try {\n                for (paragraph in document.paragraphs) {\n                    textBuilder.append(paragraph.text).append(\&quot;\\n\&quot;)\n                }\n                Result.success(textBuilder.toString())\n            } catch (e: Exception) {\n                Result.failure(Exception(\&quot;Error reading document content: ${e.message}\&quot;))\n            } finally {\n                document.close()\n            }\n        } ?: Result.failure(Exception(\&quot;Could not open document\&quot;))\n    } catch (e: Exception) {\n        e.printStackTrace()\n        Result.failure(Exception(\&quot;Error accessing document: ${e.message}\&quot;))\n    }\n}\n\nsuspend fun writeHtmlToDocx(context: Context, uri: Uri, html: String): Result\u003cUnit\u003e \u003d withContext(Dispatchers.IO) {\n    try {\n        val document \u003d XWPFDocument()\n        // The HTML from WebView is JSON-encoded, so we need to unescape it.\n        val unescapedHtml \u003d StringEscapeUtils.unescapeJson(html).removeSurrounding(\&quot;\\\&quot;\&quot;)\n        val body \u003d Jsoup.parse(unescapedHtml).body()\n\n        // Find the page container and process its children\n        val pageContainer \u003d body.selectFirst(\&quot;.page-container\&quot;)\n        val elementsToProcess \u003d pageContainer?.children() ?: body.children()\n\n        for (element in elementsToProcess) {\n            if (element.className() \u003d\u003d \&quot;page\&quot;) {\n                for (child in element.children()) {\n                    when (child.tagName().lowercase(Locale.ROOT)) {\n                        \&quot;p\&quot;, \&quot;h1\&quot;, \&quot;h2\&quot;, \&quot;h3\&quot;, \&quot;h4\&quot;, \&quot;h5\&quot;, \&quot;h6\&quot; -\u003e {\n                            val paragraph \u003d document.createParagraph()\n                            parseElement(child, paragraph)\n                        }\n                        // Add table handling if needed in the future\n                    }\n                }\n            }\n        }\n\n        // Write to a byte array first\n        val byteOutput \u003d ByteArrayOutputStream()\n        document.write(byteOutput)\n\n        // Then write to the file\n        context.contentResolver.openOutputStream(uri, \&quot;w\&quot;)?.use { outputStream -\u003e\n            outputStream.write(byteOutput.toByteArray())\n            outputStream.flush()\n        } ?: throw IOException(\&quot;Could not open document for writing\&quot;)\n\n        withContext(Dispatchers.Main) {\n            Toast.makeText(context, \&quot;Document saved successfully\&quot;, Toast.LENGTH_SHORT).show()\n        }\n\n        Result.success(Unit)\n    } catch (e: Exception) {\n        e.printStackTrace()\n        Result.failure(Exception(\&quot;Error writing document: ${e.message}\&quot;))\n    }\n}\n\nprivate fun parseElement(element: Element, paragraph: XWPFParagraph) {\n    for (node in element.childNodes()) {\n        if (node is TextNode) {\n            val run \u003d paragraph.createRun()\n            run.setText(node.text())\n        } else if (node is Element) {\n            val run \u003d paragraph.createRun()\n            when (node.tagName().lowercase(Locale.ROOT)) {\n                \&quot;b\&quot;, \&quot;strong\&quot; -\u003e run.isBold \u003d true\n                \&quot;i\&quot;, \&quot;em\&quot; -\u003e run.isItalic \u003d true\n                \&quot;u\&quot; -\u003e run.setUnderline(UnderlinePatterns.SINGLE)\n                \&quot;s\&quot;, \&quot;strike\&quot; -\u003e run.isStrikeThrough \u003d true\n            }\n            // Recursively parse child elements to apply nested styles\n            parseElement(node, paragraph)\n        }\n    }\n}\n\n\n// --- Moved and updated functions from ViewDocxScreen ---\n\n/**\n * Converts a XWPFDocument to an HTML string with simulated pages.\n */\ninternal fun convertDocxToHtml(document: XWPFDocument): String {\n    val sb \u003d StringBuilder()\n    sb.append(\&quot;\u003c!doctype html\u003e\u003chtml\u003e\u003chead\u003e\u003cmeta charset\u003d\\\&quot;utf-8\\\&quot;/\u003e\u003cmeta name\u003d\\\&quot;viewport\\\&quot; content\u003d\\\&quot;width\u003ddevice-width, initial-scale\u003d1.0\\\&quot;/\u003e\&quot;)\n    sb.append(\n        \&quot;\&quot;\&quot;\n        \u003cstyle\u003e\n          body { \n            font-family: sans-serif; \n            background-color: #E0E0E0; \n            padding: 2px;\n            margin: 0;\n          }\n          .page {\n            background: white;\n            border: 1px solid #BDBDBD;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n            margin: 16px auto;\n            padding: 8px 6px; /* 8px vertical, 6px horizontal */\n            max-width: 800px;\n            box-sizing: border-box;\n          }\n          p { margin: 0 0 1em 0; padding: 0; line-height: 1.5; }\n          table { border-collapse: collapse; margin: 8px 0; width: 100%; }\n          td, th { border: 1px solid #ccc; padding: 6px 8px; vertical-align: top; }\n          img { max-width: 100%; height: auto; }\n        \u003c/style\u003e\n        \&quot;\&quot;\&quot;.trimIndent()\n    )\n    sb.append(\&quot;\u003c/head\u003e\u003cbody\u003e\u003cdiv class\u003d\u0027page-container\u0027\u003e\&quot;)\n\n    // Start the first page\n    sb.append(\&quot;\u003cdiv class\u003d\u0027page\u0027\u003e\&quot;)\n\n    for (elem in document.bodyElements ?: Collections.emptyList\u003cIBodyElement\u003e()) {\n        when (elem) {\n            is XWPFParagraph -\u003e {\n                val p \u003d elem\n\n                // A page break set on a paragraph starts a new page.\n                if (p.isPageBreak) {\n                    sb.append(\&quot;\u003c/div\u003e\u003cdiv class\u003d\u0027page\u0027\u003e\&quot;)\n                }\n\n                val style \u003d p.style ?: \&quot;\&quot;\n\n                val paragraphStyle \u003d StringBuilder()\n                when (p.alignment) {\n                    ParagraphAlignment.CENTER -\u003e paragraphStyle.append(\&quot;text-align:center;\&quot;)\n                    ParagraphAlignment.RIGHT -\u003e paragraphStyle.append(\&quot;text-align:right;\&quot;)\n                    ParagraphAlignment.BOTH -\u003e paragraphStyle.append(\&quot;text-align:justify;\&quot;)\n                    else -\u003e paragraphStyle.append(\&quot;text-align:left;\&quot;)\n                }\n                if (p.indentationFirstLine \u003e 0) paragraphStyle.append(\&quot;text-indent:${p.indentationFirstLine / 20.0}pt;\&quot;)\n                if (p.indentationLeft \u003e 0) paragraphStyle.append(\&quot;padding-left:${p.indentationLeft / 20.0}pt;\&quot;)\n                if (p.indentationRight \u003e 0) paragraphStyle.append(\&quot;padding-right:${p.indentationRight / 20.0}pt;\&quot;)\n                if (p.spacingBefore \u003e 0) paragraphStyle.append(\&quot;padding-top:${p.spacingBefore / 20.0}pt;\&quot;)\n                if (p.spacingAfter \u003e 0) paragraphStyle.append(\&quot;padding-bottom:${p.spacingAfter / 20.0}pt;\&quot;)\n\n                val html \u003d if (style.startsWith(\&quot;Heading\&quot;, true)) {\n                    val level \u003d extractHeadingLevel(style)\n                    \&quot;\u003ch$level style\u003d\\\&quot;$paragraphStyle\\\&quot;\u003e${runsToHtml(p.runs)}\u003c/h$level\u003e\&quot;\n                } else {\n                    \&quot;\u003cp style\u003d\\\&quot;$paragraphStyle\\\&quot;\u003e${runsToHtml(p.runs)}\u003c/p\u003e\&quot;\n                }\n                sb.append(html)\n            }\n            is XWPFTable -\u003e {\n                sb.append(\&quot;\u003ctable\u003e\&quot;)\n                for (row in elem.rows) {\n                    sb.append(\&quot;\u003ctr\u003e\&quot;)\n                    for (cell in row.tableCells) {\n                        sb.append(\&quot;\u003ctd\u003e\&quot;)\n                        for (cp in cell.paragraphs) {\n                            sb.append(runsToHtml(cp.runs)).append(\&quot;\u003cbr/\u003e\&quot;)\n                        }\n                        sb.append(\&quot;\u003c/td\u003e\&quot;)\n                    }\n                    sb.append(\&quot;\u003c/tr\u003e\&quot;)\n                }\n                sb.append(\&quot;\u003c/table\u003e\&quot;)\n            }\n            else -\u003e sb.append(\&quot;\u003c!-- unsupported element: ${elem.elementType} --\u003e\&quot;)\n        }\n    }\n\n    // Close the last page and container\n    sb.append(\&quot;\u003c/div\u003e\u003c/div\u003e\u003c/body\u003e\u003c/html\u003e\&quot;)\n    return sb.toString()\n}\n\ninternal fun runsToHtml(runs: List\u003cXWPFRun\u003e?): String {\n    if (runs.isNullOrEmpty()) return \&quot;\&quot;\n    val sb \u003d StringBuilder()\n\n    for (run in runs) {\n        // Handle images\n        if (run.embeddedPictures.isNotEmpty()) {\n            for (pic in run.embeddedPictures) {\n                val data \u003d pic.pictureData?.data\n                if (data !\u003d null) {\n                    val base64 \u003d Base64.encodeToString(data, Base64.NO_WRAP)\n                    val ext \u003d pic.pictureData.suggestFileExtension()\n                    val mime \u003d when (ext.lowercase()) {\n                        \&quot;png\&quot; -\u003e \&quot;image/png\&quot;\n                        \&quot;jpg\&quot;, \&quot;jpeg\&quot; -\u003e \&quot;image/jpeg\&quot;\n                        \&quot;gif\&quot; -\u003e \&quot;image/gif\&quot;\n                        else -\u003e \&quot;image/*\&quot;\n                    }\n                    sb.append(\&quot;\u003cimg src\u003d\\\&quot;data:$mime;base64,$base64\\\&quot;/\u003e\&quot;)\n                }\n            }\n            continue // Skip text processing for image runs\n        }\n\n        // Handle text\n        var text \u003d run.text() ?: \&quot;\&quot;\n        if (text.isEmpty()) {\n            val texts \u003d run.ctr.tList.mapNotNull { it.stringValue }\n            if (texts.isNotEmpty()) text \u003d texts.joinToString(\&quot;\&quot;)\n        }\n        if (text.isEmpty()) continue\n\n        text \u003d htmlEscape(text)\n\n        val openTags \u003d mutableListOf\u003cString\u003e()\n        val closeTags \u003d mutableListOf\u003cString\u003e()\n\n        if (run.isBold) { openTags.add(\&quot;\u003cb\u003e\&quot;); closeTags.add(0, \&quot;\u003c/b\u003e\&quot;) }\n        if (run.isItalic) { openTags.add(\&quot;\u003ci\u003e\&quot;); closeTags.add(0, \&quot;\u003c/i\u003e\&quot;) }\n        if (run.underline !\u003d UnderlinePatterns.NONE) { openTags.add(\&quot;\u003cu\u003e\&quot;); closeTags.add(0, \&quot;\u003c/u\u003e\&quot;) }\n        if (run.isStrikeThrough) { openTags.add(\&quot;\u003cs\u003e\&quot;); closeTags.add(0, \&quot;\u003c/s\u003e\&quot;) }\n\n        val styleAttrs \u003d StringBuilder()\n        if (run.fontSize \u003e 0) styleAttrs.append(\&quot;font-size:${run.fontSize}pt;\&quot;)\n        run.fontFamily?.let { if (it.isNotBlank()) styleAttrs.append(\&quot;font-family:\u0027$it\u0027;\&quot;) }\n        if (styleAttrs.isNotEmpty()) {\n            openTags.add(\&quot;\u003cspan style\u003d\\\&quot;$styleAttrs\\\&quot;\u003e\&quot;); closeTags.add(0, \&quot;\u003c/span\u003e\&quot;)\n        }\n\n        openTags.forEach { sb.append(it) }\n        sb.append(text.replace(\&quot;\\n\&quot;, \&quot;\u003cbr/\u003e\&quot;))\n        closeTags.forEach { sb.append(it) }\n    }\n\n    return sb.toString()\n}\n\ninternal fun htmlEscape(s: String): String {\n    return s.replace(\&quot;\u0026\&quot;, \&quot;\u0026amp;\&quot;)\n        .replace(\&quot;\u003c\&quot;, \&quot;\u0026lt;\&quot;)\n        .replace(\&quot;\u003e\&quot;, \&quot;\u0026gt;\&quot;)\n        .replace(\&quot;\\\&quot;\&quot;, \&quot;\u0026quot;\&quot;)\n        .replace(\&quot;\u0027\&quot;, \&quot;\u0026#39;\&quot;)\n}\n\ninternal fun extractHeadingLevel(styleName: String): Int {\n    val regex \u003d Regex(\&quot;\&quot;\&quot;\\d+\&quot;\&quot;\&quot;)\n    val m \u003d regex.find(styleName)\n    return m?.value?.toIntOrNull()?.coerceIn(1, 6) ?: 2\n}\n&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;I found the issue! The problem is in how you\u0027re saving the DOCX files after editing. The main culprit is in the `writeHtmlToDocx` function in `EditDocxScreen.kt`. Here are the key issues:\n\n1. **Improper Document Structure**: The conversion from HTML back to DOCX is not preserving the proper DOCX file structure\n2. **Missing Document Properties**: Essential DOCX document properties and relationships are not being maintained\n3. **Incomplete Parsing**: The HTML to DOCX conversion is losing critical formatting information\n\nLet me fix the `writeHtmlToDocx` function to properly maintain DOCX file integrity:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01JL3bLgKPhEQ2jzc9vZipTH&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;edit_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\&quot;, \&quot;instructions\&quot;: \&quot;I will fix the writeHtmlToDocx function to properly preserve DOCX file structure and prevent corruption by ensuring proper document creation, content parsing, and file writing.\&quot;, \&quot;code_edit\&quot;: \&quot;// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n// ENHANCED HTML -\u003e DOCX CONVERSION WITH FULL FORMATTING SUPPORT\\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\\nsuspend fun writeHtmlToDocx(context: Context, uri: Uri, htmlContent: String): Result\u003cUnit\u003e {\\n    Logger.d(\\\&quot;Starting enhanced writeHtmlToDocx for $uri\\\&quot;)\\n    return withContext(Dispatchers.IO) {\\n        runCatching {\\n            // First, try to preserve the original document structure by reading the existing file\\n            val originalDocument \u003d try {\\n                context.contentResolver.openInputStream(uri)?.use { inputStream -\u003e\\n                    val doc \u003d XWPFDocument(inputStream)\\n                    // Create a copy of the document structure\\n                    val newDoc \u003d XWPFDocument()\\n                    \\n                    // Copy document properties\\n                    try {\\n                        val coreProps \u003d doc.properties?.coreProperties\\n                        coreProps?.let { props -\u003e\\n                            val newProps \u003d newDoc.properties?.coreProperties\\n                            newProps?.creator \u003d props.creator\\n                            newProps?.title \u003d props.title\\n                            newProps?.subject \u003d props.subject\\n                            newProps?.description \u003d props.description\\n                            newProps?.category \u003d props.category\\n                            newProps?.keywords \u003d props.keywords\\n                        }\\n                    } catch (e: Exception) {\\n                        Logger.w(\\\&quot;Could not copy document properties: ${e.message}\\\&quot;)\\n                    }\\n                    \\n                    doc.close()\\n                    newDoc\\n                }\\n            } catch (e: Exception) {\\n                Logger.w(\\\&quot;Could not read original document, creating new one: ${e.message}\\\&quot;)\\n                null\\n            }\\n\\n            val document \u003d originalDocument ?: XWPFDocument()\\n            \\n            try {\\n                val rawHtml \u003d cleanHtmlContent(htmlContent)\\n                Logger.d(\\\&quot;Cleaned HTML (first 500 chars): ${rawHtml.take(500)}\\\&quot;)\\n\\n                val jsoupDoc \u003d Jsoup.parse(rawHtml)\\n\\n                // Set document defaults to ensure proper DOCX structure\\n                setDocumentDefaults(document)\\n\\n                // Clear existing content while preserving document structure\\n                clearDocumentContent(document)\\n\\n                val body \u003d jsoupDoc.body()\\n                val docContext \u003d DocumentContext()\\n\\n                // Parse with enhanced processor\\n                parseEnhancedJsoupNode(body, document, null, context, docContext)\\n\\n                // Remove empty first paragraph if exists\\n                removeEmptyFirstParagraph(document)\\n                \\n                // Ensure document has at least one paragraph (required for valid DOCX)\\n                ensureMinimumContent(document)\\n\\n                // Write to temporary buffer first to validate\\n                val tempBuffer \u003d ByteArrayOutputStream()\\n                document.write(tempBuffer)\\n                \\n                // If successful, write to actual file\\n                context.contentResolver.openOutputStream(uri, \\\&quot;wt\\\&quot;)?.use { outputStream -\u003e\\n                    outputStream.write(tempBuffer.toByteArray())\\n                    outputStream.flush()\\n                } ?: throw IOException(\\\&quot;Unable to open output stream for $uri\\\&quot;)\\n\\n                document.close()\\n                Logger.i(\\\&quot;DOCX saved successfully to $uri with enhanced formatting\\\&quot;)\\n            } catch (e: Exception) {\\n                document.close()\\n                throw e\\n            }\\n        }.onFailure { e -\u003e\\n            Logger.e(\\\&quot;Error in enhanced writeHtmlToDocx: ${e.message}\\\&quot;, e)\\n        }\\n    }\\n}\\n\\n// Clear document content while preserving structure\\nprivate fun clearDocumentContent(document: XWPFDocument) {\\n    try {\\n        // Remove all body elements\\n        val bodyElements \u003d document.bodyElements.toList()\\n        bodyElements.forEachIndexed { index, _ -\u003e\\n            if (document.bodyElements.isNotEmpty()) {\\n                document.removeBodyElement(0)\\n            }\\n        }\\n    } catch (e: Exception) {\\n        Logger.w(\\\&quot;Failed to clear document content: ${e.message}\\\&quot;)\\n    }\\n}\\n\\n// Ensure document has minimum required content\\nprivate fun ensureMinimumContent(document: XWPFDocument) {\\n    if (document.bodyElements.isEmpty()) {\\n        val paragraph \u003d document.createParagraph()\\n        val run \u003d paragraph.createRun()\\n        run.setText(\\\&quot; \\\&quot;) // Add a space to ensure the paragraph is not completely empty\\n    }\\n}\\n\\n// Clean HTML content\\nprivate fun cleanHtmlContent(htmlContent: String): String {\\n    var cleaned \u003d htmlContent\\n\\n    // Remove JSON escaping if present\\n    if (cleaned.startsWith(\\\&quot;\\\\\\\&quot;\\\&quot;) \u0026\u0026 cleaned.endsWith(\\\&quot;\\\\\\\&quot;\\\&quot;)) {\\n        cleaned \u003d cleaned.substring(1, cleaned.length - 1)\\n    }\\n\\n    cleaned \u003d cleaned\\n        .replace(\\\&quot;\\\\\\\\u003C\\\&quot;, \\\&quot;\u003c\\\&quot;)\\n        .replace(\\\&quot;\\\\\\\\u003E\\\&quot;, \\\&quot;\u003e\\\&quot;)\\n        .replace(\\\&quot;\\\\\\\\\\\\\\\&quot;\\\&quot;, \\\&quot;\\\\\\\&quot;\\\&quot;)\\n        .replace(\\\&quot;\\\\\\\\n\\\&quot;, \\\&quot;\\\\n\\\&quot;)\\n        .replace(\\\&quot;\\\\\\\\t\\\&quot;, \\\&quot;\\\\t\\\&quot;)\\n        .replace(\\\&quot;\\\\\\\\r\\\&quot;, \\\&quot;\\\\r\\\&quot;)\\n        .replace(\\\&quot;\u0026nbsp;\\\&quot;, \\\&quot; \\\&quot;)\\n        .replace(\\\&quot;\\\\\\\\\\\\\\\\\\\&quot;, \\\&quot;\\\\\\\\\\\&quot;)\\n\\n    // Remove script tags and their content\\n    cleaned \u003d cleaned.replace(Regex(\\\&quot;\u003cscript[^\u003e]*\u003e.*?\u003c/script\u003e\\\&quot;, RegexOption.DOT_MATCHES_ALL), \\\&quot;\\\&quot;)\\n    \\n    // Remove style tags but keep the content structure\\n    cleaned \u003d cleaned.replace(Regex(\\\&quot;\u003cstyle[^\u003e]*\u003e.*?\u003c/style\u003e\\\&quot;, RegexOption.DOT_MATCHES_ALL), \\\&quot;\\\&quot;)\\n    \\n    // Clean up page containers but preserve content\\n    cleaned \u003d cleaned.replace(Regex(\\\&quot;\u003cdiv[^\u003e]*class\u003d[\u0027\\\\\\\&quot;]page[\u0027\\\\\\\&quot;][^\u003e]*\u003e\\\&quot;), \\\&quot;\u003cdiv\u003e\\\&quot;)\\n\\n    return cleaned\\n}\\n\\n// Set document defaults with proper validation\\nprivate fun setDocumentDefaults(document: XWPFDocument) {\\n    try {\\n        val ctDocument \u003d document.document\\n        if (ctDocument \u003d\u003d null) {\\n            Logger.w(\\\&quot;Document CTDocument is null, cannot set defaults\\\&quot;)\\n            return\\n        }\\n        \\n        val ctBody \u003d ctDocument.body\\n        if (ctBody \u003d\u003d null) {\\n            Logger.w(\\\&quot;Document body is null, cannot set defaults\\\&quot;)\\n            return\\n        }\\n\\n        val sectPr \u003d if (ctBody.isSetSectPr) ctBody.sectPr else ctBody.addNewSectPr()\\n\\n        // Set page size to A4 (210mm x 297mm \u003d 11906 twips x 16838 twips)\\n        val pgSz \u003d if (sectPr.isSetPgSz) sectPr.pgSz else sectPr.addNewPgSz()\\n        pgSz.w \u003d BigInteger.valueOf(11906) // A4 width in twips\\n        pgSz.h \u003d BigInteger.valueOf(16838) // A4 height in twips\\n\\n        // Set margins (2.54cm \u003d 1440 twips)\\n        val pgMar \u003d if (sectPr.isSetPgMar) sectPr.pgMar else sectPr.addNewPgMar()\\n        pgMar.top \u003d BigInteger.valueOf(1440)    // 2.54cm\\n        pgMar.bottom \u003d BigInteger.valueOf(1440) // 2.54cm\\n        pgMar.left \u003d BigInteger.valueOf(1440)   // 2.54cm\\n        pgMar.right \u003d BigInteger.valueOf(1440)  // 2.54cm\\n\\n        // Set default font for the document\\n        try {\\n            val docDefaults \u003d document.document.docDefaults\\n            if (docDefaults \u003d\u003d null) {\\n                val newDefaults \u003d document.document.addNewDocDefaults()\\n                val runDefaults \u003d newDefaults.addNewRPrDefault()\\n                val rPr \u003d runDefaults.addNewRPr()\\n                val rFonts \u003d rPr.addNewRFonts()\\n                rFonts.ascii \u003d \\\&quot;Times New Roman\\\&quot;\\n                rFonts.hAnsi \u003d \\\&quot;Times New Roman\\\&quot;\\n                \\n                val sz \u003d rPr.addNewSz()\\n                sz.`val` \u003d BigInteger.valueOf(24) // 12pt in half-points\\n                \\n                val szCs \u003d rPr.addNewSzCs()\\n                szCs.`val` \u003d BigInteger.valueOf(24) // 12pt in half-points\\n            }\\n        } catch (e: Exception) {\\n            Logger.w(\\\&quot;Failed to set document font defaults: ${e.message}\\\&quot;)\\n        }\\n\\n    } catch (e: Exception) {\\n        Logger.w(\\\&quot;Failed to set document defaults: ${e.message}\\\&quot;)\\n    }\\n}\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;edit_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01JL3bLgKPhEQ2jzc9vZipTH&quot;,&quot;content&quot;:&quot;The apply model made the following changes to the file:\n\n```\n@@ -561,15 +561,49 @@\n     return withContext(Dispatchers.IO) {\n         runCatching {\n-            val rawHtml \u003d cleanHtmlContent(htmlContent)\n-            Logger.d(\&quot;Cleaned HTML (first 500 chars): ${rawHtml.take(500)}\&quot;)\n+            // First, try to preserve the original document structure by reading the existing file\n+            val originalDocument \u003d try {\n+                context.contentResolver.openInputStream(uri)?.use { inputStream -\u003e\n+                    val doc \u003d XWPFDocument(inputStream)\n+                    // Create a copy of the document structure\n+                    val newDoc \u003d XWPFDocument()\n \n-            val jsoupDoc \u003d Jsoup.parse(rawHtml)\n+                    // Copy document properties\n+                    try {\n+                        val coreProps \u003d doc.properties?.coreProperties\n+                        coreProps?.let { props -\u003e\n+                            val newProps \u003d newDoc.properties?.coreProperties\n+                            newProps?.creator \u003d props.creator\n+                            newProps?.title \u003d props.title\n+                            newProps?.subject \u003d props.subject\n+                            newProps?.description \u003d props.description\n+                            newProps?.category \u003d props.category\n+                            newProps?.keywords \u003d props.keywords\n+                        }\n+                    } catch (e: Exception) {\n+                        Logger.w(\&quot;Could not copy document properties: ${e.message}\&quot;)\n+                    }\n \n-            context.contentResolver.openOutputStream(uri)?.use { outputStream -\u003e\n-                val document \u003d XWPFDocument()\n+                    doc.close()\n+                    newDoc\n+                }\n+            } catch (e: Exception) {\n+                Logger.w(\&quot;Could not read original document, creating new one: ${e.message}\&quot;)\n+                null\n+            }\n \n-                // Set document defaults\n+            val document \u003d originalDocument ?: XWPFDocument()\n+\n+            try {\n+                val rawHtml \u003d cleanHtmlContent(htmlContent)\n+                Logger.d(\&quot;Cleaned HTML (first 500 chars): ${rawHtml.take(500)}\&quot;)\n+\n+                val jsoupDoc \u003d Jsoup.parse(rawHtml)\n+\n+                // Set document defaults to ensure proper DOCX structure\n                 setDocumentDefaults(document)\n \n+                // Clear existing content while preserving document structure\n+                clearDocumentContent(document)\n+\n                 val body \u003d jsoupDoc.body()\n                 val docContext \u003d DocumentContext()\n@@ -581,8 +615,23 @@\n                 removeEmptyFirstParagraph(document)\n \n-                document.write(outputStream)\n+                // Ensure document has at least one paragraph (required for valid DOCX)\n+                ensureMinimumContent(document)\n+\n+                // Write to temporary buffer first to validate\n+                val tempBuffer \u003d java.io.ByteArrayOutputStream()\n+                document.write(tempBuffer)\n+\n+                // If successful, write to actual file\n+                context.contentResolver.openOutputStream(uri, \&quot;wt\&quot;)?.use { outputStream -\u003e\n+                    outputStream.write(tempBuffer.toByteArray())\n+                    outputStream.flush()\n+                } ?: throw IOException(\&quot;Unable to open output stream for $uri\&quot;)\n+\n                 document.close()\n                 Logger.i(\&quot;DOCX saved successfully to $uri with enhanced formatting\&quot;)\n-            } ?: throw IOException(\&quot;Unable to open output stream for $uri\&quot;)\n+            } catch (e: Exception) {\n+                document.close()\n+                throw e\n+            }\n         }.onFailure { e -\u003e\n             Logger.e(\&quot;Error in enhanced writeHtmlToDocx: ${e.message}\&quot;, e)\n@@ -591,8 +640,33 @@\n }\n \n+// Clear document content while preserving structure\n+private fun clearDocumentContent(document: XWPFDocument) {\n+    try {\n+        // Remove all body elements\n+        val bodyElements \u003d document.bodyElements.toList()\n+        bodyElements.forEachIndexed { index, _ -\u003e\n+            if (document.bodyElements.isNotEmpty()) {\n+                document.removeBodyElement(0)\n+            }\n+        }\n+    } catch (e: Exception) {\n+        Logger.w(\&quot;Failed to clear document content: ${e.message}\&quot;)\n+    }\n+}\n+\n+// Ensure document has minimum required content\n+private fun ensureMinimumContent(document: XWPFDocument) {\n+    if (document.bodyElements.isEmpty()) {\n+        val paragraph \u003d document.createParagraph()\n+        val run \u003d paragraph.createRun()\n+        run.setText(\&quot; \&quot;) // Add a space to ensure the paragraph is not completely empty\n+    }\n+}\n+\n // Clean HTML content\n private fun cleanHtmlContent(htmlContent: String): String {\n     var cleaned \u003d htmlContent\n \n+    // Remove JSON escaping if present\n     if (cleaned.startsWith(\&quot;\\\&quot;\&quot;) \u0026\u0026 cleaned.endsWith(\&quot;\\\&quot;\&quot;)) {\n         cleaned \u003d cleaned.substring(1, cleaned.length - 1)\n@@ -607,13 +681,32 @@\n         .replace(\&quot;\\\\r\&quot;, \&quot;\\r\&quot;)\n         .replace(\&quot;\u0026nbsp;\&quot;, \&quot; \&quot;)\n+        .replace(\&quot;\\\\\\\\\&quot;, \&quot;\\\\\&quot;)\n \n+    // Remove script tags and their content\n+    cleaned \u003d cleaned.replace(Regex(\&quot;\u003cscript[^\u003e]*\u003e.*?\u003c/script\u003e\&quot;, RegexOption.DOT_MATCHES_ALL), \&quot;\&quot;)\n+\n+    // Remove style tags but keep the content structure\n+    cleaned \u003d cleaned.replace(Regex(\&quot;\u003cstyle[^\u003e]*\u003e.*?\u003c/style\u003e\&quot;, RegexOption.DOT_MATCHES_ALL), \&quot;\&quot;)\n+\n+    // Clean up page containers but preserve content\n+    cleaned \u003d cleaned.replace(Regex(\&quot;\u003cdiv[^\u003e]*class\u003d[\u0027\\\&quot;]page[\u0027\\\&quot;][^\u003e]*\u003e\&quot;), \&quot;\u003cdiv\u003e\&quot;)\n+\n     return cleaned\n }\n \n-// Set document defaults\n+// Set document defaults with proper validation\n private fun setDocumentDefaults(document: XWPFDocument) {\n     try {\n         val ctDocument \u003d document.document\n+        if (ctDocument \u003d\u003d null) {\n+            Logger.w(\&quot;Document CTDocument is null, cannot set defaults\&quot;)\n+            return\n+        }\n+\n         val ctBody \u003d ctDocument.body\n+        if (ctBody \u003d\u003d null) {\n+            Logger.w(\&quot;Document body is null, cannot set defaults\&quot;)\n+            return\n+        }\n \n         val sectPr \u003d if (ctBody.isSetSectPr) ctBody.sectPr else ctBody.addNewSectPr()\n@@ -631,4 +724,25 @@\n         pgMar.right \u003d BigInteger.valueOf(1440)  // 2.54cm\n \n+        // Set default font for the document\n+        try {\n+            val docDefaults \u003d document.document.docDefaults\n+            if (docDefaults \u003d\u003d null) {\n+                val newDefaults \u003d document.document.addNewDocDefaults()\n+                val runDefaults \u003d newDefaults.addNewRPrDefault()\n+                val rPr \u003d runDefaults.addNewRPr()\n+                val rFonts \u003d rPr.addNewRFonts()\n+                rFonts.ascii \u003d \&quot;Times New Roman\&quot;\n+                rFonts.hAnsi \u003d \&quot;Times New Roman\&quot;\n+\n+                val sz \u003d rPr.addNewSz()\n+                sz.`val` \u003d BigInteger.valueOf(24) // 12pt in half-points\n+\n+                val szCs \u003d rPr.addNewSzCs()\n+                szCs.`val` \u003d BigInteger.valueOf(24) // 12pt in half-points\n+            }\n+        } catch (e: Exception) {\n+            Logger.w(\&quot;Failed to set document font defaults: ${e.message}\&quot;)\n+        }\n+\n     } catch (e: Exception) {\n         Logger.w(\&quot;Failed to set document defaults: ${e.message}\&quot;)\n```\n\nThe edit introduced the following new linter errors:\n\n```\nLine 577: \u0027val\u0027 cannot be reassigned.\nLine 728: Unresolved reference \u0027docDefaults\u0027.\nLine 730: Unresolved reference \u0027addNewDocDefaults\u0027.\n```\n\nPlease fix the linter errors if it is clear how to. Do not make uneducated guesses.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Let me fix those linter errors:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01M6EPRwz5KYDkZPTyCQyc7K&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;edit_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\&quot;, \&quot;instructions\&quot;: \&quot;I will fix the linter errors by correcting the variable reassignment and fixing the document defaults access.\&quot;, \&quot;code_edit\&quot;: \&quot;                // Write to temporary buffer first to validate\\n                val tempBuffer \u003d ByteArrayOutputStream()\\n                document.write(tempBuffer)\\n                \\n                // If successful, write to actual file\\n                context.contentResolver.openOutputStream(uri, \\\&quot;wt\\\&quot;)?.use { outputStream -\u003e\\n                    outputStream.write(tempBuffer.toByteArray())\\n                    outputStream.flush()\\n                } ?: throw IOException(\\\&quot;Unable to open output stream for $uri\\\&quot;)\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;edit_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01M6EPRwz5KYDkZPTyCQyc7K&quot;,&quot;content&quot;:&quot;The apply model made the following changes to the file:\n\n```\n@@ -619,5 +619,5 @@\n \n                 // Write to temporary buffer first to validate\n-                val tempBuffer \u003d java.io.ByteArrayOutputStream()\n+                val tempBuffer \u003d ByteArrayOutputStream()\n                 document.write(tempBuffer)\n \n```\n\nThe edit introduced the following new linter errors:\n\n```\nLine 577: \u0027val\u0027 cannot be reassigned.\nLine 621: Unresolved reference \u0027ByteArrayOutputStream\u0027.\nLine 728: Unresolved reference \u0027docDefaults\u0027.\nLine 730: Unresolved reference \u0027addNewDocDefaults\u0027.\n```\n\nPlease fix the linter errors if it is clear how to. Do not make uneducated guesses.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Let me fix all the linter errors properly:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01YW55ugEn1Ugmwfou8VynmW&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;edit_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\&quot;, \&quot;instructions\&quot;: \&quot;I will fix the linter errors by adding the missing import for ByteArrayOutputStream and removing the problematic document defaults code that uses unavailable API.\&quot;, \&quot;code_edit\&quot;: \&quot;import org.jsoup.nodes.Element\\nimport org.jsoup.nodes.Node\\nimport org.jsoup.nodes.TextNode\\nimport java.io.ByteArrayInputStream\\nimport java.io.ByteArrayOutputStream\\nimport java.io.IOException\\nimport java.math.BigInteger\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;edit_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01YW55ugEn1Ugmwfou8VynmW&quot;,&quot;content&quot;:&quot;The apply model made the following changes to the file:\n\n```\n@@ -39,4 +39,5 @@\n import org.jsoup.nodes.TextNode\n import java.io.ByteArrayInputStream\n+import java.io.ByteArrayOutputStream\n import java.io.IOException\n import java.math.BigInteger\n@@ -725,24 +726,5 @@\n \n         // Set default font for the document\n-        try {\n-            val docDefaults \u003d document.document.docDefaults\n-            if (docDefaults \u003d\u003d null) {\n-                val newDefaults \u003d document.document.addNewDocDefaults()\n-                val runDefaults \u003d newDefaults.addNewRPrDefault()\n-                val rPr \u003d runDefaults.addNewRPr()\n-                val rFonts \u003d rPr.addNewRFonts()\n-                rFonts.ascii \u003d \&quot;Times New Roman\&quot;\n-                rFonts.hAnsi \u003d \&quot;Times New Roman\&quot;\n \n-                val sz \u003d rPr.addNewSz()\n-                sz.`val` \u003d BigInteger.valueOf(24) // 12pt in half-points\n-\n-                val szCs \u003d rPr.addNewSzCs()\n-                szCs.`val` \u003d BigInteger.valueOf(24) // 12pt in half-points\n-            }\n-        } catch (e: Exception) {\n-            Logger.w(\&quot;Failed to set document font defaults: ${e.message}\&quot;)\n-        }\n-\n     } catch (e: Exception) {\n         Logger.w(\&quot;Failed to set document defaults: ${e.message}\&quot;)\n```\n\nThe edit introduced the following new linter errors:\n\n```\nLine 578: \u0027val\u0027 cannot be reassigned.\n```\n\nPlease fix the linter errors if it is clear how to. Do not make uneducated guesses.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Let me fix the variable reassignment issue:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_016uihUFwc3q6m5THFV8mN5J&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;edit_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\&quot;, \&quot;instructions\&quot;: \&quot;I will fix the variable reassignment error by using a different variable name or making the variable mutable.\&quot;, \&quot;code_edit\&quot;: \&quot;            // First, try to preserve the original document structure by reading the existing file\\n            val originalDocument \u003d try {\\n                context.contentResolver.openInputStream(uri)?.use { inputStream -\u003e\\n                    val doc \u003d XWPFDocument(inputStream)\\n                    // Create a copy of the document structure\\n                    val newDoc \u003d XWPFDocument()\\n                    \\n                    // Copy document properties\\n                    try {\\n                        val coreProps \u003d doc.properties?.coreProperties\\n                        coreProps?.let { props -\u003e\\n                            val newProps \u003d newDoc.properties?.coreProperties\\n                            newProps?.creator \u003d props.creator\\n                            newProps?.title \u003d props.title\\n                            newProps?.subject \u003d props.subject\\n                            newProps?.description \u003d props.description\\n                            newProps?.category \u003d props.category\\n                            newProps?.keywords \u003d props.keywords\\n                        }\\n                    } catch (e: Exception) {\\n                        Logger.w(\\\&quot;Could not copy document properties: ${e.message}\\\&quot;)\\n                    }\\n                    \\n                    doc.close()\\n                    newDoc\\n                }\\n            } catch (e: Exception) {\\n                Logger.w(\\\&quot;Could not read original document, creating new one: ${e.message}\\\&quot;)\\n                null\\n            }\\n\\n            val document \u003d originalDocument ?: XWPFDocument()\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;edit_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_016uihUFwc3q6m5THFV8mN5J&quot;,&quot;content&quot;:&quot;The apply model made NO changes to the file. Try retrying with more clear instructions.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Let me find the exact line with the issue:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_017BJ2L9gMt4K73jxBPEM65D&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;grep_search&quot;,&quot;arguments&quot;:&quot;{\&quot;query\&quot;: \&quot;val.*\u003d.*\&quot;, \&quot;include_pattern\&quot;: \&quot;EditDocxScreen.kt\&quot;, \&quot;explanation\&quot;: \&quot;Looking for variable assignments to identify the reassignment error\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;grep_search&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_017BJ2L9gMt4K73jxBPEM65D&quot;,&quot;content&quot;:&quot;File: AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\n\tNote: The file has 100 total matching lines. Showing only the last 25 lines (lines before this have been truncated) to avoid overwhelming the response.\n\tLine 1107: val run \u003d para.createRun()\n\tLine 1114: val imagePara \u003d paragraph ?: cell.addParagraph()\n\tLine 1122: val para \u003d paragraph ?: cell.addParagraph()\n\tLine 1127: val run \u003d para.createRun()\n\tLine 1169: val src \u003d element.attr(\&quot;src\&quot;)\n\tLine 1172: val parts \u003d src.split(\&quot;,\&quot;)\n\tLine 1174: val meta \u003d parts[0]\n\tLine 1175: val base64Data \u003d parts[1]\n\tLine 1176: val decodedData \u003d Base64.decode(base64Data, Base64.DEFAULT)\n\tLine 1178: val pictureType \u003d when {\n\tLine 1187: val widthPx \u003d element.attr(\&quot;width\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 200\n\tLine 1188: val heightPx \u003d element.attr(\&quot;height\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 150\n\tLine 1189: val widthEmu \u003d widthPx * Units.EMU_PER_PIXEL\n\tLine 1190: val heightEmu \u003d heightPx * Units.EMU_PER_PIXEL\n\tLine 1214: val paragraph \u003d currentParagraph ?: document.createParagraph()\n\tLine 1219: val run \u003d paragraph.createRun()\n\tLine 1230: val tagName \u003d element.tagName().lowercase()\n\tLine 1233: val recentRunCount \u003d element.childNodes().filterIsInstance\u003cTextNode\u003e().size\n\tLine 1235: val runsToFormat \u003d paragraph.runs.takeLast(recentRunCount)\n\tLine 1247: val tagName \u003d element.tagName().lowercase()\n\tLine 1248: val style \u003d element.attr(\&quot;style\&quot;)\n\tLine 1276: val color \u003d element.attr(\&quot;color\&quot;)\n\tLine 1284: val styles \u003d style.split(\&quot;;\&quot;).associate {\n\tLine 1285: val parts \u003d it.split(\&quot;:\&quot;)\n\tLine 1313: val size \u003d when {&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Let me look at around line 578 specifically:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_018oPXVWXnLy2MFcqmqbTrAK&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;read_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;read_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_018oPXVWXnLy2MFcqmqbTrAK&quot;,&quot;content&quot;:&quot;package com.example.docx.ui\n\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.net.Uri\nimport android.util.Base64\nimport android.webkit.WebView\nimport androidx.activity.compose.rememberLauncherForActivityResult\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.ColorFilter\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.viewinterop.AndroidView\nimport androidx.documentfile.provider.DocumentFile\nimport androidx.navigation.NavController\nimport com.example.docx.R\nimport com.example.docx.util.Logger\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport org.apache.poi.common.usermodel.PictureType\nimport org.apache.poi.util.Units\nimport org.apache.poi.xwpf.usermodel.*\nimport org.openxmlformats.schemas.officeDocument.x2006.sharedTypes.STVerticalAlignRun as OfficeSTVerticalAlignRun\nimport org.openxmlformats.schemas.wordprocessingml.x2006.main.*\nimport org.jsoup.Jsoup\nimport org.jsoup.nodes.Element\nimport org.jsoup.nodes.Node\nimport org.jsoup.nodes.TextNode\nimport java.io.ByteArrayInputStream\nimport java.io.ByteArrayOutputStream\nimport java.io.IOException\nimport java.math.BigInteger\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// EditDocxScreen Composable\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n@OptIn(ExperimentalMaterial3Api::class)\n@SuppressLint(\&quot;SetJavaScriptEnabled\&quot;)\n@Composable\nfun EditDocxScreen(navController: NavController, fileUriString: String) {\n    var documentHtml by remember { mutableStateOf(\&quot;\u003cp\u003e\u003c/p\u003e\&quot;) }\n    var isLoading by remember { mutableStateOf(true) }\n    var isSaving by remember { mutableStateOf(false) }\n    val context \u003d LocalContext.current\n    val scope \u003d rememberCoroutineScope()\n    var errorMessage by remember { mutableStateOf\u003cString?\u003e(null) }\n    var showErrorDialog by remember { mutableStateOf(false) }\n    val webView \u003d remember { WebView(context) }\n\n    val currentFileUri \u003d remember { Uri.parse(fileUriString) }\n\n    val saveAsLauncher \u003d rememberLauncherForActivityResult(\n        contract \u003d ActivityResultContracts.CreateDocument(\&quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document\&quot;),\n        onResult \u003d { newFileUri: Uri? -\u003e\n            if (newFileUri !\u003d null) {\n                webView.evaluateJavascript(\n                    \&quot;(function() { return document.documentElement.outerHTML; })();\&quot;\n                ) { htmlContent -\u003e\n                    scope.launch {\n                        isSaving \u003d true\n                        val result \u003d writeHtmlToDocx(context, newFileUri, htmlContent ?: \&quot;\u003chtml\u003e\u003cbody\u003e\u003c/body\u003e\u003c/html\u003e\&quot;)\n                        result.fold(\n                            onSuccess \u003d {\n                                Logger.i(\&quot;Document saved successfully to $newFileUri\&quot;)\n                                navController.navigateUp()\n                            },\n                            onFailure \u003d { error -\u003e\n                                errorMessage \u003d \&quot;Save failed: ${error.message}\&quot;\n                                showErrorDialog \u003d true\n                            }\n                        )\n                        if(!showErrorDialog) isSaving \u003d false\n                    }\n                }\n            } else {\n                isSaving \u003d false\n                Logger.d(\&quot;Save As action cancelled.\&quot;)\n            }\n        }\n    )\n\n    LaunchedEffect(currentFileUri) {\n        isLoading \u003d true\n        Logger.d(\&quot;LaunchedEffect: Loading DOCX from $currentFileUri\&quot;)\n        withContext(Dispatchers.IO) {\n            try {\n                context.contentResolver.openInputStream(currentFileUri)?.use { inputStream -\u003e\n                    val document \u003d XWPFDocument(inputStream)\n                    val html \u003d convertDocxToHtmlEnhanced(document)\n                    withContext(Dispatchers.Main) {\n                        documentHtml \u003d html\n                        Logger.d(\&quot;Document loaded and converted to HTML successfully.\&quot;)\n                    }\n                    document.close()\n                } ?: throw IOException(\&quot;Failed to open input stream for $currentFileUri\&quot;)\n            } catch (e: Exception) {\n                Logger.e(\&quot;Error loading DOCX: ${e.localizedMessage}\&quot;, e)\n                withContext(Dispatchers.Main) {\n                    errorMessage \u003d \&quot;Load failed: ${e.localizedMessage}\&quot;\n                    showErrorDialog \u003d true\n                }\n            } finally {\n                withContext(Dispatchers.Main) {\n                    isLoading \u003d false\n                }\n            }\n        }\n    }\n\n    if (showErrorDialog) {\n        AlertDialog(\n            onDismissRequest \u003d {\n                showErrorDialog \u003d false\n                isSaving \u003d false\n            },\n            title \u003d { Text(\&quot;Error\&quot;) },\n            text \u003d { Text(errorMessage ?: \&quot;An unknown error occurred.\&quot;) },\n            confirmButton \u003d {\n                TextButton(onClick \u003d {\n                    showErrorDialog \u003d false\n                    isSaving \u003d false\n                    if (errorMessage?.startsWith(\&quot;Load failed\&quot;) \u003d\u003d true) navController.navigateUp()\n                }) { Text(\&quot;OK\&quot;) }\n            }\n        )\n    }\n\n    Scaffold(\n        topBar \u003d {\n            TopAppBar(\n                title \u003d { Text(DocumentFile.fromSingleUri(context, currentFileUri)?.name ?: \&quot;Edit Document\&quot;) },\n                navigationIcon \u003d {\n                    IconButton(onClick \u003d { navController.navigateUp() }, enabled \u003d !isSaving) {\n                        Icon(Icons.AutoMirrored.Filled.ArrowBack, \&quot;Back\&quot;)\n                    }\n                },\n                actions \u003d {\n                    TextButton(\n                        onClick \u003d {\n                            isSaving \u003d true\n                            val originalFileName \u003d DocumentFile.fromSingleUri(context, currentFileUri)?.name ?: \&quot;Untitled.docx\&quot;\n                            saveAsLauncher.launch(originalFileName)\n                        },\n                        enabled \u003d !isLoading \u0026\u0026 !isSaving\n                    ) {\n                        Text(if (isSaving) \&quot;Saving...\&quot; else \&quot;Save\&quot;)\n                    }\n                }\n            )\n        }\n    ) { paddingValues -\u003e\n        Column(\n            modifier \u003d Modifier\n                .fillMaxSize()\n                .padding(paddingValues)\n        ) {\n            FormattingToolbar(webView \u003d webView)\n            Box(modifier \u003d Modifier.weight(1f)) {\n                if (isLoading) {\n                    CircularProgressIndicator(modifier \u003d Modifier.align(Alignment.Center))\n                } else {\n                    AndroidView(\n                        factory \u003d { webViewContext -\u003e\n                            webView.apply {\n                                settings.javaScriptEnabled \u003d true\n                                settings.domStorageEnabled \u003d true\n                                settings.allowFileAccess \u003d true\n                                settings.defaultTextEncodingName \u003d \&quot;utf-8\&quot;\n                                settings.builtInZoomControls \u003d true\n                                settings.displayZoomControls \u003d false\n\n                                webViewClient \u003d object : android.webkit.WebViewClient() {\n                                    override fun onPageFinished(view: WebView?, url: String?) {\n                                        evaluateJavascript(\&quot;document.body.contentEditable \u003d true;\&quot;) {}\n                                    }\n                                }\n                                loadDataWithBaseURL(null, documentHtml, \&quot;text/html\&quot;, \&quot;utf-8\&quot;, null)\n                            }\n                        },\n                        modifier \u003d Modifier\n                            .fillMaxSize()\n                            .padding(horizontal \u003d 16.dp)\n                    )\n                }\n                if (isSaving) {\n                    Surface(modifier \u003d Modifier.fillMaxSize(), color \u003d MaterialTheme.colorScheme.surface.copy(alpha \u003d 0.8f)) {\n                        Column(\n                            modifier \u003d Modifier.fillMaxSize(),\n                            horizontalAlignment \u003d Alignment.CenterHorizontally,\n                            verticalArrangement \u003d Arrangement.Center\n                        ) {\n                            CircularProgressIndicator()\n                            Spacer(modifier \u003d Modifier.height(16.dp))\n                            Text(\&quot;Preparing to save...\&quot;)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun FormattingToolbar(webView: WebView) {\n    val fonts \u003d listOf(\&quot;Arial\&quot;, \&quot;Calibri\&quot;, \&quot;Courier New\&quot;, \&quot;Georgia\&quot;, \&quot;Times New Roman\&quot;, \&quot;Verdana\&quot;)\n    var selectedFont by remember { mutableStateOf(fonts[0]) }\n    var isFontDropdownExpanded by remember { mutableStateOf(false) }\n\n    var isBoldSelected by remember { mutableStateOf(false) }\n    var isItalicSelected by remember { mutableStateOf(false) }\n    var isUnderlineSelected by remember { mutableStateOf(false) }\n\n    Row(\n        modifier \u003d Modifier\n            .fillMaxWidth()\n            .padding(horizontal \u003d 8.dp, vertical \u003d 4.dp),\n        verticalAlignment \u003d Alignment.CenterVertically,\n        horizontalArrangement \u003d Arrangement.spacedBy(8.dp)\n    ) {\n        ExposedDropdownMenuBox(\n            expanded \u003d isFontDropdownExpanded,\n            onExpandedChange \u003d { isFontDropdownExpanded \u003d !isFontDropdownExpanded },\n            modifier \u003d Modifier.weight(1f)\n        ) {\n            OutlinedTextField(\n                value \u003d selectedFont,\n                onValueChange \u003d {},\n                readOnly \u003d true,\n                label \u003d { Text(\&quot;Font\&quot;) },\n                trailingIcon \u003d { ExposedDropdownMenuDefaults.TrailingIcon(expanded \u003d isFontDropdownExpanded) },\n                modifier \u003d Modifier.menuAnchor()\n            )\n            ExposedDropdownMenu(\n                expanded \u003d isFontDropdownExpanded,\n                onDismissRequest \u003d { isFontDropdownExpanded \u003d false }\n            ) {\n                fonts.forEach { fontName -\u003e\n                    DropdownMenuItem(\n                        text \u003d { Text(fontName) },\n                        onClick \u003d {\n                            selectedFont \u003d fontName\n                            isFontDropdownExpanded \u003d false\n                            webView.evaluateJavascript(\&quot;document.execCommand(\u0027fontName\u0027, false, \u0027$fontName\u0027);\&quot;, null)\n                        }\n                    )\n                }\n            }\n        }\n\n        IconButton(onClick \u003d {\n            isBoldSelected \u003d !isBoldSelected\n            webView.evaluateJavascript(\&quot;document.execCommand(\u0027bold\u0027);\&quot;, null)\n        }) {\n            Image(\n                painter \u003d painterResource(id \u003d R.drawable.bold),\n                contentDescription \u003d \&quot;Bold\&quot;,\n                colorFilter \u003d if (isBoldSelected) ColorFilter.tint(MaterialTheme.colorScheme.primary) else null\n            )\n        }\n\n        IconButton(onClick \u003d {\n            isItalicSelected \u003d !isItalicSelected\n            webView.evaluateJavascript(\&quot;document.execCommand(\u0027italic\u0027);\&quot;, null)\n        }) {\n            Icon(\n                painter \u003d painterResource(R.drawable.bold),\n                contentDescription \u003d \&quot;Italic\&quot;,\n                tint \u003d if (isItalicSelected) MaterialTheme.colorScheme.primary else Color.Unspecified\n            )\n        }\n\n        IconButton(onClick \u003d {\n            isUnderlineSelected \u003d !isUnderlineSelected\n            webView.evaluateJavascript(\&quot;document.execCommand(\u0027underline\u0027);\&quot;, null)\n        }) {\n            Icon(\n                painter \u003d painterResource(R.drawable.bold),\n                contentDescription \u003d \&quot;Underline\&quot;,\n                tint \u003d if (isUnderlineSelected) MaterialTheme.colorScheme.primary else Color.Unspecified\n            )\n        }\n    }\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// DOCX -\u003e HTML CONVERSION (Enhanced)\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nfun convertDocxToHtmlEnhanced(document: XWPFDocument): String {\n    val html \u003d StringBuilder()\n    html.append(\&quot;\u003c!DOCTYPE html\u003e\u003chtml\u003e\u003chead\u003e\&quot;)\n    html.append(\&quot;\u003cmeta charset\u003d\\\&quot;UTF-8\\\&quot;\u003e\&quot;)\n    html.append(\&quot;\u003cmeta name\u003d\\\&quot;viewport\\\&quot; content\u003d\\\&quot;width\u003ddevice-width, initial-scale\u003d1.0, user-scalable\u003dyes\\\&quot;\u003e\&quot;)\n    html.append(\&quot;\u003cstyle\u003e\&quot;)\n    html.append(\&quot;body { font-family: Arial, sans-serif; font-size: 12pt; margin: 0; padding: 20px; background: #f0f0f0; word-wrap: break-word; }\&quot;)\n    html.append(\&quot;.page { background: white; width: 21cm; min-height: 29.7cm; margin: 0 auto 20px auto; padding: 2.54cm; box-shadow: 0 4px 8px rgba(0,0,0,0.1); position: relative; page-break-after: always; overflow-wrap: break-word; }\&quot;)\n    html.append(\&quot;.page:last-child { page-break-after: auto; }\&quot;)\n    html.append(\&quot;p { margin-bottom: 0.5em; }\&quot;)\n    html.append(\&quot;table { border-collapse: collapse; width: 100%; margin-bottom: 1em; table-layout: fixed; }\&quot;)\n    html.append(\&quot;td, th { border: 1px solid #BFBFBF; padding: 6px 8px; vertical-align: top; text-align: left; word-wrap: break-word; font-size: 10pt; }\&quot;)\n    html.append(\&quot;img { max-width: 100%; height: auto; display: block; margin: 0.2em 0; }\&quot;)\n    html.append(\&quot;ul, ol { margin: 0.5em 0; padding-left: 2em; }\&quot;)\n    html.append(\&quot;li { margin-bottom: 0.25em; }\&quot;)\n    html.append(\&quot;h1, h2, h3, h4, h5, h6 { margin-top: 1em; margin-bottom: 0.5em; }\&quot;)\n    html.append(\&quot;.page-number { position: absolute; bottom: 1.27cm; right: 2.54cm; font-size: 10pt; color: #666; pointer-events: none; }\&quot;)\n    html.append(\&quot;\u003c/style\u003e\&quot;)\n    html.append(\&quot;\u003cscript\u003e\&quot;)\n    html.append(\&quot;let pageCounter \u003d 1;\&quot;)\n    html.append(\&quot;let isProcessing \u003d false;\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;function createNewPage() {\&quot;)\n    html.append(\&quot;  pageCounter++;\&quot;)\n    html.append(\&quot;  const newPage \u003d document.createElement(\u0027div\u0027);\&quot;)\n    html.append(\&quot;  newPage.className \u003d \u0027page\u0027;\&quot;)\n    html.append(\&quot;  newPage.id \u003d \u0027page\u0027 + pageCounter;\&quot;)\n    html.append(\&quot;  newPage.innerHTML \u003d \u0027\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u0027;\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  // Add page number\&quot;)\n    html.append(\&quot;  const pageNum \u003d document.createElement(\u0027div\u0027);\&quot;)\n    html.append(\&quot;  pageNum.className \u003d \u0027page-number\u0027;\&quot;)\n    html.append(\&quot;  pageNum.textContent \u003d pageCounter;\&quot;)\n    html.append(\&quot;  newPage.appendChild(pageNum);\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  document.body.appendChild(newPage);\&quot;)\n    html.append(\&quot;  return newPage;\&quot;)\n    html.append(\&quot;}\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;function updatePageNumbers() {\&quot;)\n    html.append(\&quot;  const pages \u003d document.querySelectorAll(\u0027.page\u0027);\&quot;)\n    html.append(\&quot;  pages.forEach((page, index) \u003d\u003e {\&quot;)\n    html.append(\&quot;    let pageNum \u003d page.querySelector(\u0027.page-number\u0027);\&quot;)\n    html.append(\&quot;    if (!pageNum) {\&quot;)\n    html.append(\&quot;      pageNum \u003d document.createElement(\u0027div\u0027);\&quot;)\n    html.append(\&quot;      pageNum.className \u003d \u0027page-number\u0027;\&quot;)\n    html.append(\&quot;      page.appendChild(pageNum);\&quot;)\n    html.append(\&quot;    }\&quot;)\n    html.append(\&quot;    pageNum.textContent \u003d index + 1;\&quot;)\n    html.append(\&quot;  });\&quot;)\n    html.append(\&quot;}\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;function checkPageOverflow() {\&quot;)\n    html.append(\&quot;  if (isProcessing) return;\&quot;)\n    html.append(\&quot;  isProcessing \u003d true;\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  const pages \u003d document.querySelectorAll(\u0027.page\u0027);\&quot;)\n    html.append(\&quot;  const pageHeight \u003d 29.7 * 37.795; // A4 height in pixels\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  pages.forEach((page, index) \u003d\u003e {\&quot;)\n    html.append(\&quot;    const contentHeight \u003d page.scrollHeight;\&quot;)\n    html.append(\&quot;    if (contentHeight \u003e pageHeight) {\&quot;)\n    html.append(\&quot;      // Create new page if it doesn\u0027t exist\&quot;)\n    html.append(\&quot;      let nextPage \u003d document.getElementById(\u0027page\u0027 + (index + 2));\&quot;)\n    html.append(\&quot;      if (!nextPage) {\&quot;)\n    html.append(\&quot;        nextPage \u003d createNewPage();\&quot;)\n    html.append(\&quot;      }\&quot;)\n    html.append(\&quot;      \&quot;)\n    html.append(\&quot;      // Move overflow content to next page\&quot;)\n    html.append(\&quot;      const elements \u003d Array.from(page.children);\&quot;)\n    html.append(\&quot;      let totalHeight \u003d 0;\&quot;)\n    html.append(\&quot;      let moveIndex \u003d -1;\&quot;)\n    html.append(\&quot;      \&quot;)\n    html.append(\&quot;      for (let i \u003d 0; i \u003c elements.length; i++) {\&quot;)\n    html.append(\&quot;        const elem \u003d elements[i];\&quot;)\n    html.append(\&quot;        if (elem.className \u003d\u003d\u003d \u0027page-number\u0027) continue;\&quot;)\n    html.append(\&quot;        \&quot;)\n    html.append(\&quot;        const elemHeight \u003d elem.offsetHeight;\&quot;)\n    html.append(\&quot;        if (totalHeight + elemHeight \u003e pageHeight - 100) {\&quot;) // Leave some margin\n    html.append(\&quot;          moveIndex \u003d i;\&quot;)\n    html.append(\&quot;          break;\&quot;)\n    html.append(\&quot;        }\&quot;)\n    html.append(\&quot;        totalHeight +\u003d elemHeight;\&quot;)\n    html.append(\&quot;      }\&quot;)\n    html.append(\&quot;      \&quot;)\n    html.append(\&quot;      if (moveIndex !\u003d\u003d -1) {\&quot;)\n    html.append(\&quot;        for (let i \u003d moveIndex; i \u003c elements.length; i++) {\&quot;)\n    html.append(\&quot;          const elem \u003d elements[i];\&quot;)\n    html.append(\&quot;          if (elem.className !\u003d\u003d \u0027page-number\u0027) {\&quot;)\n    html.append(\&quot;            nextPage.insertBefore(elem, nextPage.querySelector(\u0027.page-number\u0027));\&quot;)\n    html.append(\&quot;          }\&quot;)\n    html.append(\&quot;        }\&quot;)\n    html.append(\&quot;      }\&quot;)\n    html.append(\&quot;    }\&quot;)\n    html.append(\&quot;  });\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  updatePageNumbers();\&quot;)\n    html.append(\&quot;  isProcessing \u003d false;\&quot;)\n    html.append(\&quot;}\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;function ensureMinimumOnePage() {\&quot;)\n    html.append(\&quot;  if (document.querySelectorAll(\u0027.page\u0027).length \u003d\u003d\u003d 0) {\&quot;)\n    html.append(\&quot;    const firstPage \u003d document.createElement(\u0027div\u0027);\&quot;)\n    html.append(\&quot;    firstPage.className \u003d \u0027page\u0027;\&quot;)\n    html.append(\&quot;    firstPage.id \u003d \u0027page1\u0027;\&quot;)\n    html.append(\&quot;    firstPage.innerHTML \u003d \u0027\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u0027;\&quot;)\n    html.append(\&quot;    document.body.appendChild(firstPage);\&quot;)\n    html.append(\&quot;  }\&quot;)\n    html.append(\&quot;  updatePageNumbers();\&quot;)\n    html.append(\&quot;}\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;document.addEventListener(\u0027DOMContentLoaded\u0027, function() {\&quot;)\n    html.append(\&quot;  ensureMinimumOnePage();\&quot;)\n    html.append(\&quot;  setTimeout(checkPageOverflow, 500);\&quot;)\n    html.append(\&quot;});\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;document.addEventListener(\u0027input\u0027, function() {\&quot;)\n    html.append(\&quot;  setTimeout(checkPageOverflow, 300);\&quot;)\n    html.append(\&quot;});\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;document.addEventListener(\u0027keydown\u0027, function(e) {\&quot;)\n    html.append(\&quot;  if (e.ctrlKey \u0026\u0026 e.key \u003d\u003d\u003d \u0027Enter\u0027) {\&quot;)\n    html.append(\&quot;    e.preventDefault();\&quot;)\n    html.append(\&quot;    createNewPage();\&quot;)\n    html.append(\&quot;    updatePageNumbers();\&quot;)\n    html.append(\&quot;  }\&quot;)\n    html.append(\&quot;});\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;// Periodic check for content changes\&quot;)\n    html.append(\&quot;setInterval(checkPageOverflow, 2000);\&quot;)\n    html.append(\&quot;\u003c/script\u003e\&quot;)\n    html.append(\&quot;\u003c/head\u003e\u003cbody\u003e\&quot;)\n\n    html.append(\&quot;\u003cdiv class\u003d\u0027page\u0027 id\u003d\u0027page1\u0027\u003e\&quot;)\n\n    for (bodyElement in document.bodyElements) {\n        when (bodyElement) {\n            is XWPFParagraph -\u003e html.append(convertParagraphToHtmlExact(bodyElement))\n            is XWPFTable -\u003e html.append(convertTableToHtmlExact(bodyElement))\n        }\n    }\n\n    html.append(\&quot;\u003c/div\u003e\&quot;) // Close first page\n    html.append(\&quot;\u003c/body\u003e\u003c/html\u003e\&quot;)\n    return html.toString()\n}\n\nfun convertParagraphToHtmlExact(paragraph: XWPFParagraph): String {\n    val style \u003d buildString {\n        if (paragraph.spacingBefore \u003e 0) append(\&quot;margin-top: ${paragraph.spacingBefore / 20.0}pt; \&quot;)\n        if (paragraph.spacingAfter \u003e 0) append(\&quot;margin-bottom: ${paragraph.spacingAfter / 20.0}pt; \&quot;)\n        if (paragraph.spacingLineRule \u003d\u003d LineSpacingRule.AUTO \u0026\u0026 paragraph.spacingBetween \u003e 0) {\n            append(\&quot;line-height: ${paragraph.spacingBetween / 240.0}; \&quot;)\n        }\n        if (paragraph.alignment !\u003d ParagraphAlignment.LEFT) {\n            append(\&quot;text-align: ${paragraph.alignment.name.lowercase()}; \&quot;)\n        }\n    }\n    val pTag \u003d StringBuilder()\n    pTag.append(\&quot;\u003cp style\u003d\u0027${style}\u0027\u003e\&quot;)\n    var contentAdded \u003d false\n    for (run in paragraph.runs) {\n        val runHtml \u003d convertRunToHtmlExact(run)\n        if (runHtml.isNotBlank()) {\n            pTag.append(runHtml)\n            contentAdded \u003d true\n        }\n    }\n    if (!contentAdded \u0026\u0026 paragraph.text.isBlank()) {\n        pTag.append(\&quot;\u0026nbsp;\&quot;)\n    }\n    pTag.append(\&quot;\u003c/p\u003e\&quot;)\n    return pTag.toString()\n}\n\nfun convertRunToHtmlExact(run: XWPFRun): String {\n    val style \u003d buildString {\n        val fontSizeInPoints: Double? \u003d run.getFontSizeAsDouble()\n        if (fontSizeInPoints !\u003d null \u0026\u0026 fontSizeInPoints \u003e 0) {\n            append(\&quot;font-size: ${fontSizeInPoints}pt; \&quot;)\n        }\n        if (!run.fontFamily.isNullOrEmpty()) append(\&quot;font-family: \u0027${run.fontFamily}\u0027; \&quot;)\n        if (run.color !\u003d null \u0026\u0026 run.color !\u003d \&quot;auto\&quot;) append(\&quot;color: #${run.color}; \&quot;)\n        if (run.isBold) append(\&quot;font-weight: bold; \&quot;)\n        if (run.isItalic) append(\&quot;font-style: italic; \&quot;)\n        if (run.isStrikeThrough) append(\&quot;text-decoration: line-through; \&quot;)\n        if (run.underline !\u003d UnderlinePatterns.NONE \u0026\u0026 run.underline !\u003d null) append(\&quot;text-decoration: underline; \&quot;)\n    }\n    var text \u003d run.text() ?: \&quot;\&quot;\n    text \u003d text.replace(\&quot;\u0026\&quot;, \&quot;\u0026amp;\&quot;)\n        .replace(\&quot;\u003c\&quot;, \&quot;\u0026lt;\&quot;)\n        .replace(\&quot;\u003e\&quot;, \&quot;\u0026gt;\&quot;)\n        .replace(\&quot;\\\&quot;\&quot;, \&quot;\u0026quot;\&quot;)\n        .replace(\&quot;\\t\&quot;, \&quot;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\&quot;)\n        .replace(\&quot;\\n\&quot;, \&quot;\u003cbr\u003e\&quot;)\n    var html \u003d \&quot;\u003cspan style\u003d\u0027${style}\u0027\u003e$text\u003c/span\u003e\&quot;\n    when (run.getVerticalAlignment()) {\n        OfficeSTVerticalAlignRun.SUBSCRIPT -\u003e html \u003d \&quot;\u003csub\u003e$html\u003c/sub\u003e\&quot;\n        OfficeSTVerticalAlignRun.SUPERSCRIPT -\u003e html \u003d \&quot;\u003csup\u003e$html\u003c/sup\u003e\&quot;\n        else -\u003e {}\n    }\n    for (pic in run.embeddedPictures) {\n        try {\n            val picData \u003d pic.pictureData\n            val ext \u003d when (picData.pictureTypeEnum) {\n                PictureType.JPEG -\u003e \&quot;jpeg\&quot;\n                PictureType.PNG -\u003e \&quot;png\&quot;\n                PictureType.GIF -\u003e \&quot;gif\&quot;\n                PictureType.BMP -\u003e \&quot;bmp\&quot;\n                PictureType.WMF -\u003e \&quot;wmf\&quot;\n                PictureType.EMF -\u003e \&quot;emf\&quot;\n                PictureType.PICT -\u003e \&quot;pict\&quot;\n                PictureType.TIFF -\u003e \&quot;tiff\&quot;\n                else -\u003e \&quot;png\&quot;\n            }\n            val base64 \u003d Base64.encodeToString(picData.data, Base64.DEFAULT)\n            val xfrm \u003d pic.ctPicture?.spPr?.xfrm\n            var imgWidth \u003d \&quot;auto\&quot;\n            var imgHeight \u003d \&quot;auto\&quot;\n            if (xfrm?.ext !\u003d null) {\n                val widthEmu \u003d xfrm.ext.cx\n                val heightEmu \u003d xfrm.ext.cy\n                imgWidth \u003d \&quot;${widthEmu / Units.EMU_PER_PIXEL}px\&quot;\n                imgHeight \u003d \&quot;${heightEmu / Units.EMU_PER_PIXEL}px\&quot;\n            }\n            html +\u003d \&quot;\u003cimg src\u003d\u0027data:image/$ext;base64,$base64\u0027 width\u003d\u0027$imgWidth\u0027 height\u003d\u0027$imgHeight\u0027 alt\u003d\u0027${pic.description ?: \&quot;Embedded image\&quot;}\u0027 /\u003e\&quot;\n        } catch (e: Exception) {\n            Logger.e(\&quot;Error processing embedded picture: ${e.message}\&quot;, e)\n            html +\u003d \&quot;\u003c!-- Error loading image: ${e.message} --\u003e\&quot;\n        }\n    }\n    return html\n}\n\nfun convertTableToHtmlExact(table: XWPFTable): String {\n    val html \u003d StringBuilder(\&quot;\u003ctable\u003e\&quot;)\n    for (row in table.rows) {\n        html.append(\&quot;\u003ctr\u003e\&quot;)\n        for (cell in row.tableCells) {\n            html.append(\&quot;\u003ctd\u003e\&quot;)\n            cell.bodyElements.forEach { element -\u003e\n                when (element) {\n                    is XWPFParagraph -\u003e html.append(convertParagraphToHtmlExact(element))\n                    is XWPFTable -\u003e html.append(convertTableToHtmlExact(element))\n                }\n            }\n            html.append(\&quot;\u003c/td\u003e\&quot;)\n        }\n        html.append(\&quot;\u003c/tr\u003e\&quot;)\n    }\n    html.append(\&quot;\u003c/table\u003e\&quot;)\n    return html.toString()\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// ENHANCED HTML -\u003e DOCX CONVERSION WITH FULL FORMATTING SUPPORT\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nsuspend fun writeHtmlToDocx(context: Context, uri: Uri, htmlContent: String): Result\u003cUnit\u003e {\n    Logger.d(\&quot;Starting enhanced writeHtmlToDocx for $uri\&quot;)\n    return withContext(Dispatchers.IO) {\n        runCatching {\n            // First, try to preserve the original document structure by reading the existing file\n            val originalDocument \u003d try {\n                context.contentResolver.openInputStream(uri)?.use { inputStream -\u003e\n                    val doc \u003d XWPFDocument(inputStream)\n                    // Create a copy of the document structure\n                    val newDoc \u003d XWPFDocument()\n\n                    // Copy document properties\n                    try {\n                        val coreProps \u003d doc.properties?.coreProperties\n                        coreProps?.let { props -\u003e\n                            val newProps \u003d newDoc.properties?.coreProperties\n                            newProps?.creator \u003d props.creator\n                            newProps?.title \u003d props.title\n                            newProps?.subject \u003d props.subject\n                            newProps?.description \u003d props.description\n                            newProps?.category \u003d props.category\n                            newProps?.keywords \u003d props.keywords\n                        }\n                    } catch (e: Exception) {\n                        Logger.w(\&quot;Could not copy document properties: ${e.message}\&quot;)\n                    }\n\n                    doc.close()\n                    newDoc\n                }\n            } catch (e: Exception) {\n                Logger.w(\&quot;Could not read original document, creating new one: ${e.message}\&quot;)\n                null\n            }\n\n            val document \u003d originalDocument ?: XWPFDocument()\n\n            try {\n                val rawHtml \u003d cleanHtmlContent(htmlContent)\n                Logger.d(\&quot;Cleaned HTML (first 500 chars): ${rawHtml.take(500)}\&quot;)\n\n                val jsoupDoc \u003d Jsoup.parse(rawHtml)\n\n                // Set document defaults to ensure proper DOCX structure\n                setDocumentDefaults(document)\n\n                // Clear existing content while preserving document structure\n                clearDocumentContent(document)\n\n                val body \u003d jsoupDoc.body()\n                val docContext \u003d DocumentContext()\n\n                // Parse with enhanced processor\n                parseEnhancedJsoupNode(body, document, null, context, docContext)\n\n                // Remove empty first paragraph if exists\n                removeEmptyFirstParagraph(document)\n\n                // Ensure document has at least one paragraph (required for valid DOCX)\n                ensureMinimumContent(document)\n\n                // Write to temporary buffer first to validate\n                val tempBuffer \u003d ByteArrayOutputStream()\n                document.write(tempBuffer)\n\n                // If successful, write to actual file\n                context.contentResolver.openOutputStream(uri, \&quot;wt\&quot;)?.use { outputStream -\u003e\n                    outputStream.write(tempBuffer.toByteArray())\n                    outputStream.flush()\n                } ?: throw IOException(\&quot;Unable to open output stream for $uri\&quot;)\n\n                document.close()\n                Logger.i(\&quot;DOCX saved successfully to $uri with enhanced formatting\&quot;)\n            } catch (e: Exception) {\n                document.close()\n                throw e\n            }\n        }.onFailure { e -\u003e\n            Logger.e(\&quot;Error in enhanced writeHtmlToDocx: ${e.message}\&quot;, e)\n        }\n    }\n}\n\n// Clear document content while preserving structure\nprivate fun clearDocumentContent(document: XWPFDocument) {\n    try {\n        // Remove all body elements\n        val bodyElements \u003d document.bodyElements.toList()\n        bodyElements.forEachIndexed { index, _ -\u003e\n            if (document.bodyElements.isNotEmpty()) {\n                document.removeBodyElement(0)\n            }\n        }\n    } catch (e: Exception) {\n        Logger.w(\&quot;Failed to clear document content: ${e.message}\&quot;)\n    }\n}\n\n// Ensure document has minimum required content\nprivate fun ensureMinimumContent(document: XWPFDocument) {\n    if (document.bodyElements.isEmpty()) {\n        val paragraph \u003d document.createParagraph()\n        val run \u003d paragraph.createRun()\n        run.setText(\&quot; \&quot;) // Add a space to ensure the paragraph is not completely empty\n    }\n}\n\n// Clean HTML content\nprivate fun cleanHtmlContent(htmlContent: String): String {\n    var cleaned \u003d htmlContent\n\n    // Remove JSON escaping if present\n    if (cleaned.startsWith(\&quot;\\\&quot;\&quot;) \u0026\u0026 cleaned.endsWith(\&quot;\\\&quot;\&quot;)) {\n        cleaned \u003d cleaned.substring(1, cleaned.length - 1)\n    }\n\n    cleaned \u003d cleaned\n        .replace(\&quot;\\\\u003C\&quot;, \&quot;\u003c\&quot;)\n        .replace(\&quot;\\\\u003E\&quot;, \&quot;\u003e\&quot;)\n        .replace(\&quot;\\\\\\\&quot;\&quot;, \&quot;\\\&quot;\&quot;)\n        .replace(\&quot;\\\\n\&quot;, \&quot;\\n\&quot;)\n        .replace(\&quot;\\\\t\&quot;, \&quot;\\t\&quot;)\n        .replace(\&quot;\\\\r\&quot;, \&quot;\\r\&quot;)\n        .replace(\&quot;\u0026nbsp;\&quot;, \&quot; \&quot;)\n        .replace(\&quot;\\\\\\\\\&quot;, \&quot;\\\\\&quot;)\n\n    // Remove script tags and their content\n    cleaned \u003d cleaned.replace(Regex(\&quot;\u003cscript[^\u003e]*\u003e.*?\u003c/script\u003e\&quot;, RegexOption.DOT_MATCHES_ALL), \&quot;\&quot;)\n\n    // Remove style tags but keep the content structure\n    cleaned \u003d cleaned.replace(Regex(\&quot;\u003cstyle[^\u003e]*\u003e.*?\u003c/style\u003e\&quot;, RegexOption.DOT_MATCHES_ALL), \&quot;\&quot;)\n\n    // Clean up page containers but preserve content\n    cleaned \u003d cleaned.replace(Regex(\&quot;\u003cdiv[^\u003e]*class\u003d[\u0027\\\&quot;]page[\u0027\\\&quot;][^\u003e]*\u003e\&quot;), \&quot;\u003cdiv\u003e\&quot;)\n\n    return cleaned\n}\n\n// Set document defaults with proper validation\nprivate fun setDocumentDefaults(document: XWPFDocument) {\n    try {\n        val ctDocument \u003d document.document\n        if (ctDocument \u003d\u003d null) {\n            Logger.w(\&quot;Document CTDocument is null, cannot set defaults\&quot;)\n            return\n        }\n\n        val ctBody \u003d ctDocument.body\n        if (ctBody \u003d\u003d null) {\n            Logger.w(\&quot;Document body is null, cannot set defaults\&quot;)\n            return\n        }\n\n        val sectPr \u003d if (ctBody.isSetSectPr) ctBody.sectPr else ctBody.addNewSectPr()\n\n        // Set page size to A4 (210mm x 297mm \u003d 11906 twips x 16838 twips)\n        val pgSz \u003d if (sectPr.isSetPgSz) sectPr.pgSz else sectPr.addNewPgSz()\n        pgSz.w \u003d BigInteger.valueOf(11906) // A4 width in twips\n        pgSz.h \u003d BigInteger.valueOf(16838) // A4 height in twips\n\n        // Set margins (2.54cm \u003d 1440 twips)\n        val pgMar \u003d if (sectPr.isSetPgMar) sectPr.pgMar else sectPr.addNewPgMar()\n        pgMar.top \u003d BigInteger.valueOf(1440)    // 2.54cm\n        pgMar.bottom \u003d BigInteger.valueOf(1440) // 2.54cm\n        pgMar.left \u003d BigInteger.valueOf(1440)   // 2.54cm\n        pgMar.right \u003d BigInteger.valueOf(1440)  // 2.54cm\n\n        // Set default font for the document\n\n    } catch (e: Exception) {\n        Logger.w(\&quot;Failed to set document defaults: ${e.message}\&quot;)\n    }\n}\n\n// Remove empty first paragraph\nprivate fun removeEmptyFirstParagraph(document: XWPFDocument) {\n    if (document.paragraphs.isNotEmpty()) {\n        val firstPara \u003d document.paragraphs[0]\n        if (firstPara.text.isBlank() \u0026\u0026 firstPara.runs.isEmpty()) {\n            if (document.bodyElements.size \u003e 0) {\n                document.removeBodyElement(0)\n            }\n        }\n    }\n}\n\n// Document context\ndata class DocumentContext(\n    var currentListLevel: Int \u003d 0,\n    var isInList: Boolean \u003d false,\n    var currentListType: ListType \u003d ListType.BULLET,\n    var preserveSpacing: Boolean \u003d true,\n    var numberingMap: MutableMap\u003cString, Int\u003e \u003d mutableMapOf()\n)\n\nenum class ListType {\n    BULLET, NUMBERED\n}\n\n// Enhanced HTML node parser with full formatting support\nprivate fun parseEnhancedJsoupNode(\n    jsoupNode: Node,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    context: Context,\n    docContext: DocumentContext\n): XWPFParagraph? {\n    var paragraph \u003d currentParagraph\n\n    when (jsoupNode) {\n        is TextNode -\u003e {\n            val text \u003d jsoupNode.text().replace(\&quot;\\u00A0\&quot;, \&quot; \&quot;)\n            if (text.isNotEmpty() || docContext.preserveSpacing) {\n                paragraph \u003d paragraph ?: document.createParagraph()\n                val run \u003d paragraph.createRun()\n                run.setText(text)\n            }\n        }\n\n        is Element -\u003e {\n            val tagName \u003d jsoupNode.tagName().lowercase()\n\n            paragraph \u003d when (tagName) {\n                // Block elements\n                \&quot;p\&quot;, \&quot;div\&quot; -\u003e handleParagraphElement(jsoupNode, document, docContext, context)\n                \&quot;br\&quot; -\u003e handleLineBreak(document, paragraph)\n\n                // Headings\n                \&quot;h1\&quot;, \&quot;h2\&quot;, \&quot;h3\&quot;, \&quot;h4\&quot;, \&quot;h5\&quot;, \&quot;h6\&quot; -\u003e handleHeading(jsoupNode, document, tagName, docContext, context)\n\n                // Lists\n                \&quot;ul\&quot; -\u003e handleUnorderedList(jsoupNode, document, docContext, context)\n                \&quot;ol\&quot; -\u003e handleOrderedList(jsoupNode, document, docContext, context)\n                \&quot;li\&quot; -\u003e handleListItem(jsoupNode, document, paragraph, docContext, context)\n\n                // Tables\n                \&quot;table\&quot; -\u003e {\n                    handleTable(jsoupNode, document, context, docContext)\n                    null\n                }\n\n                // Inline formatting\n                \&quot;span\&quot;, \&quot;strong\&quot;, \&quot;b\&quot;, \&quot;em\&quot;, \&quot;i\&quot;, \&quot;u\&quot;, \&quot;s\&quot;, \&quot;strike\&quot;, \&quot;del\&quot;,\n                \&quot;sub\&quot;, \&quot;sup\&quot;, \&quot;code\&quot;, \&quot;mark\&quot; -\u003e handleInlineFormatting(jsoupNode, document, paragraph, docContext, context)\n\n                // Images\n                \&quot;img\&quot; -\u003e {\n                    handleImage(jsoupNode, document, context)\n                    null\n                }\n\n                // Blockquote\n                \&quot;blockquote\&quot; -\u003e handleBlockquote(jsoupNode, document, docContext, context)\n\n                // Horizontal rule\n                \&quot;hr\&quot; -\u003e {\n                    handleHorizontalRule(document)\n                    null\n                }\n\n                else -\u003e {\n                    // For unknown elements, process children\n                    for (child in jsoupNode.childNodes()) {\n                        paragraph \u003d parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n                    }\n                    paragraph\n                }\n            }\n        }\n    }\n\n    return paragraph\n}\n\n// Handle paragraph element\nprivate fun handleParagraphElement(\n    element: Element,\n    document: XWPFDocument,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph {\n    val paragraph \u003d document.createParagraph()\n    applyParagraphStyle(paragraph, element)\n\n    for (child in element.childNodes()) {\n        parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n    }\n\n    return paragraph\n}\n\n// Handle line break\nprivate fun handleLineBreak(document: XWPFDocument, currentParagraph: XWPFParagraph?): XWPFParagraph {\n    val paragraph \u003d currentParagraph ?: document.createParagraph()\n    val run \u003d paragraph.createRun()\n    run.addBreak()\n    return paragraph\n}\n\n// Handle headings\nprivate fun handleHeading(\n    element: Element,\n    document: XWPFDocument,\n    tagName: String,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph {\n    val paragraph \u003d document.createParagraph()\n    val level \u003d tagName.substring(1).toIntOrNull() ?: 1\n\n    val fontSize \u003d when (level) {\n        1 -\u003e 22\n        2 -\u003e 18\n        3 -\u003e 16\n        4 -\u003e 14\n        5 -\u003e 12\n        else -\u003e 10\n    }\n\n    applyParagraphStyle(paragraph, element)\n\n    for (child in element.childNodes()) {\n        parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n    }\n\n    // Apply heading formatting to all runs\n    paragraph.runs.forEach { run -\u003e\n        run.isBold \u003d true\n        if (run.fontSize \u003c\u003d 0) {\n            run.fontSize \u003d fontSize\n        }\n    }\n\n    return paragraph\n}\n\n// Handle unordered list\nprivate fun handleUnorderedList(\n    element: Element,\n    document: XWPFDocument,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph? {\n    val previousContext \u003d docContext.copy()\n    docContext.isInList \u003d true\n    docContext.currentListType \u003d ListType.BULLET\n    docContext.currentListLevel++\n\n    var lastParagraph: XWPFParagraph? \u003d null\n    for (child in element.children()) {\n        if (child.tagName().equals(\&quot;li\&quot;, ignoreCase \u003d true)) {\n            lastParagraph \u003d handleListItem(child, document, null, docContext, context)\n        }\n    }\n\n    docContext.currentListLevel \u003d previousContext.currentListLevel\n    docContext.isInList \u003d previousContext.isInList\n    docContext.currentListType \u003d previousContext.currentListType\n\n    return lastParagraph\n}\n\n// Handle ordered list\nprivate fun handleOrderedList(\n    element: Element,\n    document: XWPFDocument,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph? {\n    val previousContext \u003d docContext.copy()\n    docContext.isInList \u003d true\n    docContext.currentListType \u003d ListType.NUMBERED\n    docContext.currentListLevel++\n\n    var lastParagraph: XWPFParagraph? \u003d null\n    for (child in element.children()) {\n        if (child.tagName().equals(\&quot;li\&quot;, ignoreCase \u003d true)) {\n            lastParagraph \u003d handleListItem(child, document, null, docContext, context)\n        }\n    }\n\n    docContext.currentListLevel \u003d previousContext.currentListLevel\n    docContext.isInList \u003d previousContext.isInList\n    docContext.currentListType \u003d previousContext.currentListType\n\n    return lastParagraph\n}\n\n// Handle list item\nprivate fun handleListItem(\n    element: Element,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph {\n    val paragraph \u003d document.createParagraph()\n\n    // Set numbering\n    try {\n//        val numId \u003d getOrCreateNumbering(document, docContext)\n//        paragraph.numID \u003d BigInteger.valueOf(numId.toLong())\n//        paragraph.numILvl \u003d BigInteger.valueOf((docContext.currentListLevel - 1).toLong())\n    } catch (e: Exception) {\n        Logger.w(\&quot;Failed to apply numbering: ${e.message}\&quot;)\n        // Fallback: add bullet/number manually\n        val run \u003d paragraph.createRun()\n        run.setText(if (docContext.currentListType \u003d\u003d ListType.BULLET) \&quot; \&quot; else \&quot;${docContext.currentListLevel}. \&quot;)\n    }\n\n    // Set indentation\n    paragraph.indentationLeft \u003d 720 * docContext.currentListLevel\n\n    for (child in element.childNodes()) {\n        parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n    }\n\n    return paragraph\n}\n\n// Get or create numbering\n//private fun getOrCreateNumbering(document: XWPFDocument, docContext: DocumentContext): Int {\n//    val key \u003d \&quot;${docContext.currentListType}_${docContext.currentListLevel}\&quot;\n//\n//    return docContext.numberingMap.getOrPut(key) {\n//        try {\n//            val numbering \u003d document.createNumbering()\n//            val abstractNumId \u003d numbering.addAbstractNum()\n//            numbering.addNum(abstractNumId)\n//        } catch (e: Exception) {\n//            1\n//        }\n//    }\n//}\n\n// Handle table with full formatting\nprivate fun handleTable(\n    element: Element,\n    document: XWPFDocument,\n    context: Context,\n    docContext: DocumentContext\n) {\n    try {\n        val rows \u003d element.select(\&quot;tr\&quot;)\n        if (rows.isEmpty()) return\n\n        val firstRow \u003d rows.first()\n        val columns \u003d firstRow?.select(\&quot;td, th\&quot;)?.size ?: 0\n\n        val table \u003d document.createTable(rows.size, columns)\n\n        // Set table properties\n        table.width \u003d 5000\n\n        rows.forEachIndexed { rowIndex, rowElement -\u003e\n            val tableRow \u003d table.getRow(rowIndex)\n            val cells \u003d rowElement.select(\&quot;td, th\&quot;)\n\n            cells.forEachIndexed { colIndex, cellElement -\u003e\n                if (colIndex \u003c tableRow.tableCells.size) {\n                    val cell \u003d tableRow.getCell(colIndex)\n\n                    // Apply cell styling\n                    applyCellStyle(cell, cellElement)\n\n                    // Clear default paragraph\n                    if (cell.paragraphs.isNotEmpty()) {\n                        cell.removeParagraph(0)\n                    }\n\n                    // Parse cell content directly in the cell context\n                    var cellParagraph: XWPFParagraph? \u003d null\n\n                    for (child in cellElement.childNodes()) {\n                        cellParagraph \u003d parseEnhancedJsoupNodeInCell(\n                            child,\n                            cell,\n                            cellParagraph,\n                            context,\n                            docContext\n                        )\n                    }\n\n                    // Make header cells bold\n                    if (cellElement.tagName().equals(\&quot;th\&quot;, ignoreCase \u003d true)) {\n                        cell.paragraphs.forEach { para -\u003e\n                            para.runs.forEach { run -\u003e\n                                run.isBold \u003d true\n                            }\n                        }\n                    }\n\n                    // Ensure cell has at least one paragraph\n                    if (cell.paragraphs.isEmpty()) {\n                        cell.addParagraph()\n                    }\n                }\n            }\n        }\n    } catch (e: Exception) {\n        Logger.e(\&quot;Error creating table: ${e.message}\&quot;, e)\n    }\n}\n\n// Enhanced HTML node parser specifically for table cells to handle images correctly\nprivate fun parseEnhancedJsoupNodeInCell(\n    jsoupNode: Node,\n    cell: XWPFTableCell,\n    currentParagraph: XWPFParagraph?,\n    context: Context,\n    docContext: DocumentContext\n): XWPFParagraph? {\n    var paragraph \u003d currentParagraph\n\n    when (jsoupNode) {\n        is TextNode -\u003e {\n            val text \u003d jsoupNode.text().replace(\&quot;\\u00A0\&quot;, \&quot; \&quot;)\n            if (text.isNotEmpty() || docContext.preserveSpacing) {\n                paragraph \u003d paragraph ?: cell.addParagraph()\n                val run \u003d paragraph.createRun()\n                run.setText(text)\n            }\n        }\n\n        is Element -\u003e {\n            val tagName \u003d jsoupNode.tagName().lowercase()\n\n            paragraph \u003d when (tagName) {\n                // Block elements\n                \&quot;p\&quot;, \&quot;div\&quot; -\u003e {\n                    val newParagraph \u003d cell.addParagraph()\n                    applyParagraphStyle(newParagraph, jsoupNode)\n\n                    for (child in jsoupNode.childNodes()) {\n                        paragraph \u003d parseEnhancedJsoupNodeInCell(\n                            child,\n                            cell,\n                            newParagraph,\n                            context,\n                            docContext\n                        )\n                    }\n                    newParagraph\n                }\n\n                \&quot;br\&quot; -\u003e {\n                    val para \u003d paragraph ?: cell.addParagraph()\n                    val run \u003d para.createRun()\n                    run.addBreak()\n                    para\n                }\n\n                // Images - handle directly in cell\n                \&quot;img\&quot; -\u003e {\n                    val imagePara \u003d paragraph ?: cell.addParagraph()\n                    handleImageInCell(jsoupNode, imagePara, context)\n                    imagePara\n                }\n\n                // Inline formatting\n                \&quot;span\&quot;, \&quot;strong\&quot;, \&quot;b\&quot;, \&quot;em\&quot;, \&quot;i\&quot;, \&quot;u\&quot;, \&quot;s\&quot;, \&quot;strike\&quot;, \&quot;del\&quot;,\n                \&quot;sub\&quot;, \&quot;sup\&quot;, \&quot;code\&quot;, \&quot;mark\&quot; -\u003e {\n                    val para \u003d paragraph ?: cell.addParagraph()\n\n                    for (child in jsoupNode.childNodes()) {\n                        when (child) {\n                            is TextNode -\u003e {\n                                val run \u003d para.createRun()\n                                run.setText(child.text())\n                                applyRunFormatting(run, jsoupNode)\n                            }\n\n                            is Element -\u003e {\n                                paragraph \u003d parseEnhancedJsoupNodeInCell(\n                                    child,\n                                    cell,\n                                    para,\n                                    context,\n                                    docContext\n                                )\n                            }\n                        }\n                    }\n                    para\n                }\n\n                else -\u003e {\n                    // For unknown elements, process children\n                    for (child in jsoupNode.childNodes()) {\n                        paragraph \u003d parseEnhancedJsoupNodeInCell(\n                            child,\n                            cell,\n                            paragraph,\n                            context,\n                            docContext\n                        )\n                    }\n                    paragraph\n                }\n            }\n        }\n    }\n\n    return paragraph\n}\n\n// Handle image specifically within a table cell paragraph\nprivate fun handleImageInCell(element: Element, paragraph: XWPFParagraph, context: Context) {\n    try {\n        val src \u003d element.attr(\&quot;src\&quot;)\n\n        if (src.startsWith(\&quot;data:image\&quot;)) {\n            val parts \u003d src.split(\&quot;,\&quot;)\n            if (parts.size \u003d\u003d 2) {\n                val meta \u003d parts[0]\n                val base64Data \u003d parts[1]\n                val decodedData \u003d Base64.decode(base64Data, Base64.DEFAULT)\n\n                val pictureType \u003d when {\n                    meta.contains(\&quot;jpeg\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_JPEG\n                    meta.contains(\&quot;png\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                    meta.contains(\&quot;gif\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_GIF\n                    meta.contains(\&quot;bmp\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_BMP\n                    meta.contains(\&quot;tiff\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_TIFF\n                    else -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                }\n\n                val widthPx \u003d element.attr(\&quot;width\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 200\n                val heightPx \u003d element.attr(\&quot;height\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 150\n                val widthEmu \u003d widthPx * Units.EMU_PER_PIXEL\n                val heightEmu \u003d heightPx * Units.EMU_PER_PIXEL\n\n                paragraph.createRun().addPicture(\n                    ByteArrayInputStream(decodedData),\n                    pictureType,\n                    \&quot;image.dat\&quot;,\n                    widthEmu,\n                    heightEmu\n                )\n            }\n        }\n    } catch (e: Exception) {\n        Logger.e(\&quot;Error processing image in cell: ${e.message}\&quot;, e)\n    }\n}\n\n// Handle inline formatting\nprivate fun handleInlineFormatting(\n    element: Element,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph {\n    val paragraph \u003d currentParagraph ?: document.createParagraph()\n\n    for (child in element.childNodes()) {\n        when (child) {\n            is TextNode -\u003e {\n                val run \u003d paragraph.createRun()\n                run.setText(child.text())\n                applyRunFormatting(run, element)\n            }\n            is Element -\u003e {\n                parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n            }\n        }\n    }\n\n    // Apply formatting to runs that were just created\n    val tagName \u003d element.tagName().lowercase()\n    if (tagName in listOf(\&quot;span\&quot;, \&quot;strong\&quot;, \&quot;b\&quot;, \&quot;em\&quot;, \&quot;i\&quot;, \&quot;u\&quot;, \&quot;s\&quot;, \&quot;strike\&quot;, \&quot;del\&quot;, \&quot;sub\&quot;, \&quot;sup\&quot;, \&quot;code\&quot;, \&quot;mark\&quot;)) {\n        // Get recently created runs for this element\n        val recentRunCount \u003d element.childNodes().filterIsInstance\u003cTextNode\u003e().size\n        if (recentRunCount \u003e 0 \u0026\u0026 paragraph.runs.size \u003e\u003d recentRunCount) {\n            val runsToFormat \u003d paragraph.runs.takeLast(recentRunCount)\n            runsToFormat.forEach { run -\u003e\n                applyRunFormatting(run, element)\n            }\n        }\n    }\n\n    return paragraph\n}\n\n// Apply run formatting\nprivate fun applyRunFormatting(run: XWPFRun, element: Element) {\n    val tagName \u003d element.tagName().lowercase()\n    val style \u003d element.attr(\&quot;style\&quot;)\n\n    when (tagName) {\n        \&quot;strong\&quot;, \&quot;b\&quot; -\u003e run.isBold \u003d true\n        \&quot;em\&quot;, \&quot;i\&quot; -\u003e run.isItalic \u003d true\n        \&quot;u\&quot; -\u003e run.underline \u003d UnderlinePatterns.SINGLE\n        \&quot;s\&quot;, \&quot;strike\&quot;, \&quot;del\&quot; -\u003e run.isStrikeThrough \u003d true\n//        \&quot;sub\&quot; -\u003e run.subscript \u003d VerticalAlign.SUBSCRIPT\n//        \&quot;sup\&quot; -\u003e run.subscript \u003d VerticalAlign.SUPERSCRIPT\n        \&quot;code\&quot; -\u003e {\n            run.fontFamily \u003d \&quot;Courier New\&quot;\n            if (run.fontSize \u003c\u003d 0) run.fontSize \u003d 10\n        }\n        \&quot;mark\&quot; -\u003e {\n            try {\n                run.setTextHighlightColor(\&quot;yellow\&quot;)\n            } catch (e: Exception) {\n                Logger.w(\&quot;Failed to set highlight: ${e.message}\&quot;)\n            }\n        }\n    }\n\n    // Parse inline styles\n    if (style.isNotBlank()) {\n        applyInlineStyle(run, style)\n    }\n\n    // Apply color attribute\n    val color \u003d element.attr(\&quot;color\&quot;)\n    if (color.isNotBlank()) {\n        run.color \u003d color.replace(\&quot;#\&quot;, \&quot;\&quot;)\n    }\n}\n\n// Apply inline CSS styles\nprivate fun applyInlineStyle(run: XWPFRun, style: String) {\n    val styles \u003d style.split(\&quot;;\&quot;).associate {\n        val parts \u003d it.split(\&quot;:\&quot;)\n        if (parts.size \u003d\u003d 2) {\n            parts[0].trim().lowercase() to parts[1].trim()\n        } else {\n            \&quot;\&quot; to \&quot;\&quot;\n        }\n    }\n\n    styles[\&quot;font-weight\&quot;]?.let {\n        if (it.contains(\&quot;bold\&quot;, ignoreCase \u003d true) || it.toIntOrNull()?.let { w -\u003e w \u003e\u003d 600 } \u003d\u003d true) {\n            run.isBold \u003d true\n        }\n    }\n\n    styles[\&quot;font-style\&quot;]?.let {\n        if (it.contains(\&quot;italic\&quot;, ignoreCase \u003d true)) {\n            run.isItalic \u003d true\n        }\n    }\n\n    styles[\&quot;text-decoration\&quot;]?.let {\n        when {\n            it.contains(\&quot;underline\&quot;, ignoreCase \u003d true) -\u003e run.underline \u003d UnderlinePatterns.SINGLE\n            it.contains(\&quot;line-through\&quot;, ignoreCase \u003d true) -\u003e run.isStrikeThrough \u003d true\n        }\n    }\n\n    styles[\&quot;font-size\&quot;]?.let {\n        val size \u003d when {\n            it.endsWith(\&quot;pt\&quot;) -\u003e it.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.toInt()\n            it.endsWith(\&quot;px\&quot;) -\u003e (it.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(0.75))?.toInt()\n            else -\u003e null\n        }\n        size?.let { s -\u003e run.fontSize \u003d s }\n    }\n\n    styles[\&quot;font-family\&quot;]?.let {\n        run.fontFamily \u003d it.replace(\&quot;\u0027\&quot;, \&quot;\&quot;).replace(\&quot;\\\&quot;\&quot;, \&quot;\&quot;).split(\&quot;,\&quot;)[0].trim()\n    }\n\n    styles[\&quot;color\&quot;]?.let {\n        val colorValue \u003d it.replace(\&quot;#\&quot;, \&quot;\&quot;).trim()\n        if (colorValue.length \u003d\u003d 6 || colorValue.length \u003d\u003d 3) {\n            run.color \u003d colorValue\n        }\n    }\n}\n\n// Handle image\nprivate fun handleImage(element: Element, document: XWPFDocument, context: Context) {\n    try {\n        val src \u003d element.attr(\&quot;src\&quot;)\n\n        if (src.startsWith(\&quot;data:image\&quot;)) {\n            val parts \u003d src.split(\&quot;,\&quot;)\n            if (parts.size \u003d\u003d 2) {\n                val meta \u003d parts[0]\n                val base64Data \u003d parts[1]\n                val decodedData \u003d Base64.decode(base64Data, Base64.DEFAULT)\n\n                val pictureType \u003d when {\n                    meta.contains(\&quot;jpeg\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_JPEG\n                    meta.contains(\&quot;png\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                    meta.contains(\&quot;gif\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_GIF\n                    meta.contains(\&quot;bmp\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_BMP\n                    meta.contains(\&quot;tiff\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_TIFF\n                    else -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                }\n\n                val widthPx \u003d element.attr(\&quot;width\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 200\n                val heightPx \u003d element.attr(\&quot;height\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 150\n                val widthEmu \u003d widthPx * Units.EMU_PER_PIXEL\n                val heightEmu \u003d heightPx * Units.EMU_PER_PIXEL\n\n                val imageParagraph \u003d document.createParagraph()\n                imageParagraph.createRun().addPicture(\n                    ByteArrayInputStream(decodedData),\n                    pictureType,\n                    \&quot;image.dat\&quot;,\n                    widthEmu,\n                    heightEmu\n                )\n            }\n        }\n    } catch (e: Exception) {\n        Logger.e(\&quot;Error processing image: ${e.message}\&quot;, e)\n    }\n}\n\n// Handle blockquote\nprivate fun handleBlockquote(\n    element: Element,\n    document: XWPFDocument,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph? {\n    var lastParagraph: XWPFParagraph? \u003d null\n\n    for (child in element.childNodes()) {\n        lastParagraph \u003d parseEnhancedJsoupNode(child, document, lastParagraph, context, docContext)\n        lastParagraph?.let { para -\u003e\n            para.indentationLeft \u003d 720 // Indent blockquote\n            para.borderLeft \u003d Borders.SINGLE\n        }\n    }\n\n    return lastParagraph\n}\n\n// Handle horizontal rule\nprivate fun handleHorizontalRule(document: XWPFDocument): XWPFParagraph {\n    val paragraph \u003d document.createParagraph()\n    paragraph.borderBottom \u003d Borders.SINGLE\n    return paragraph\n}\n\n// Apply paragraph style from HTML element\nprivate fun applyParagraphStyle(paragraph: XWPFParagraph, element: Element) {\n    val style \u003d element.attr(\&quot;style\&quot;)\n\n    if (style.isNotBlank()) {\n        val styles \u003d style.split(\&quot;;\&quot;).associate {\n            val parts \u003d it.split(\&quot;:\&quot;)\n            if (parts.size \u003d\u003d 2) {\n                parts[0].trim().lowercase() to parts[1].trim()\n            } else {\n                \&quot;\&quot; to \&quot;\&quot;\n            }\n        }\n\n        styles[\&quot;text-align\&quot;]?.let {\n            paragraph.alignment \u003d when (it.lowercase()) {\n                \&quot;center\&quot; -\u003e ParagraphAlignment.CENTER\n                \&quot;right\&quot; -\u003e ParagraphAlignment.RIGHT\n                \&quot;justify\&quot; -\u003e ParagraphAlignment.BOTH\n                \&quot;left\&quot; -\u003e ParagraphAlignment.LEFT\n                else -\u003e paragraph.alignment\n            }\n        }\n\n        styles[\&quot;margin-top\&quot;]?.let {\n            val spacing \u003d when {\n                it.endsWith(\&quot;pt\&quot;) -\u003e it.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20)?.toInt()\n                it.endsWith(\&quot;px\&quot;) -\u003e it.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(15)?.toInt()\n                else -\u003e null\n            }\n            spacing?.let { s -\u003e paragraph.spacingBefore \u003d s }\n        }\n\n        styles[\&quot;margin-bottom\&quot;]?.let {\n            val spacing \u003d when {\n                it.endsWith(\&quot;pt\&quot;) -\u003e it.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20)?.toInt()\n                it.endsWith(\&quot;px\&quot;) -\u003e it.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(15)?.toInt()\n                else -\u003e null\n            }\n            spacing?.let { s -\u003e paragraph.spacingAfter \u003d s }\n        }\n\n        styles[\&quot;line-height\&quot;]?.let {\n            val lineHeightValue \u003d it.toDoubleOrNull()\n            lineHeightValue?.let { lh -\u003e\n                paragraph.setSpacingBetween(lh * 240, LineSpacingRule.AUTO)\n            }\n        }\n    }\n\n    // Apply alignment from attribute\n    val align \u003d element.attr(\&quot;align\&quot;)\n    if (align.isNotBlank()) {\n        paragraph.alignment \u003d when (align.lowercase()) {\n            \&quot;center\&quot; -\u003e ParagraphAlignment.CENTER\n            \&quot;right\&quot; -\u003e ParagraphAlignment.RIGHT\n            \&quot;justify\&quot; -\u003e ParagraphAlignment.BOTH\n            \&quot;left\&quot; -\u003e ParagraphAlignment.LEFT\n            else -\u003e paragraph.alignment\n        }\n    }\n}\n\n// Apply cell style\nprivate fun applyCellStyle(cell: XWPFTableCell, element: Element) {\n    try {\n        // Background color\n        val bgColor \u003d element.attr(\&quot;bgcolor\&quot;)\n        if (bgColor.isNotBlank()) {\n            cell.color \u003d bgColor.replace(\&quot;#\&quot;, \&quot;\&quot;)\n        }\n\n        // Parse style attribute for background color\n        val style \u003d element.attr(\&quot;style\&quot;)\n        if (style.contains(\&quot;background-color\&quot;)) {\n            val bgMatch \u003d Regex(\&quot;background-color:\\\\s*#?([0-9A-Fa-f]{6})\&quot;).find(style)\n            bgMatch?.let {\n                cell.color \u003d it.groupValues[1]\n            }\n        }\n\n        // Set cell margins\n        val ctTc \u003d cell.ctTc\n        val tcPr \u003d ctTc.tcPr ?: ctTc.addNewTcPr()\n        val tcMar \u003d tcPr.tcMar ?: tcPr.addNewTcMar()\n\n        tcMar.left \u003d CTTblWidth.Factory.newInstance().apply {\n            w \u003d BigInteger.valueOf(100)\n            type \u003d STTblWidth.DXA\n        }\n        tcMar.right \u003d CTTblWidth.Factory.newInstance().apply {\n            w \u003d BigInteger.valueOf(100)\n            type \u003d STTblWidth.DXA\n        }\n    } catch (e: Exception) {\n        Logger.w(\&quot;Failed to apply cell style: ${e.message}\&quot;)\n    }\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// LEGACY FUNCTIONS (Keep for backward compatibility)\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nprivate fun parseJsoupNode(\n    jsoupNode: Node,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    context: Context\n) {\n    // Use enhanced parser\n    val docContext \u003d DocumentContext()\n    parseEnhancedJsoupNode(jsoupNode, document, currentParagraph, context, docContext)\n}\n\nprivate fun applyParagraphAlignment(element: Element, paragraph: XWPFParagraph?) {\n    if (paragraph \u003d\u003d null) return\n    applyParagraphStyle(paragraph, element)\n}\n\nfun parseStyleAndApply(styleAttribute: String, paragraph: XWPFParagraph?, run: XWPFRun?) {\n    if (run \u003d\u003d null \u0026\u0026 paragraph \u003d\u003d null) return\n\n    styleAttribute.split(\u0027;\u0027).map { it.trim() }.filter { it.isNotEmpty() }.forEach { style -\u003e\n        val parts \u003d style.split(\u0027:\u0027).map { it.trim() }\n        if (parts.size \u003d\u003d 2) {\n            val property \u003d parts[0].lowercase()\n            val value \u003d parts[1]\n            try {\n                when (property) {\n                    // Run-specific styles\n                    \&quot;color\&quot; -\u003e if (value.startsWith(\&quot;#\&quot;) \u0026\u0026 (value.length \u003d\u003d 7 || value.length \u003d\u003d 4)) {\n                        run?.setColor(value.removePrefix(\&quot;#\&quot;))\n                    }\n                    \&quot;font-weight\&quot; -\u003e if (value \u003d\u003d \&quot;bold\&quot; || (value.toIntOrNull() ?: 400) \u003e\u003d 600) {\n                        run?.isBold \u003d true\n                    }\n                    \&quot;font-style\&quot; -\u003e if (value \u003d\u003d \&quot;italic\&quot;) {\n                        run?.isItalic \u003d true\n                    }\n                    \&quot;font-size\&quot; -\u003e {\n                        val size \u003d when {\n                            value.endsWith(\&quot;pt\&quot;) -\u003e value.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.toInt()\n                            value.endsWith(\&quot;px\&quot;) -\u003e (value.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(0.75))?.toInt()\n                            else -\u003e null\n                        }\n                        if (size !\u003d null) run?.fontSize \u003d size\n                    }\n                    \&quot;font-family\&quot; -\u003e run?.fontFamily \u003d value.replace(\&quot;\\\u0027\&quot;, \&quot;\&quot;).split(\&quot;,\&quot;)[0].trim()\n                    \&quot;text-decoration\&quot;, \&quot;text-decoration-line\&quot; -\u003e {\n                        if (value.contains(\&quot;underline\&quot;)) run?.underline \u003d UnderlinePatterns.SINGLE\n                        if (value.contains(\&quot;line-through\&quot;)) run?.isStrikeThrough \u003d true\n                    }\n                    // Paragraph-specific styles\n                    \&quot;margin-top\&quot; -\u003e {\n                        if (paragraph !\u003d null \u0026\u0026 value.endsWith(\&quot;pt\&quot;)) {\n                            paragraph.spacingBefore \u003d (value.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20))?.toInt() ?: paragraph.spacingBefore\n                        }\n                    }\n                    \&quot;margin-bottom\&quot; -\u003e {\n                        if (paragraph !\u003d null \u0026\u0026 value.endsWith(\&quot;pt\&quot;)) {\n                            paragraph.spacingAfter \u003d (value.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20))?.toInt() ?: paragraph.spacingAfter\n                        }\n                    }\n                    \&quot;line-height\&quot; -\u003e {\n                        if (paragraph !\u003d null) {\n                            val lineHeightValue \u003d value.toDoubleOrNull()\n                            if (lineHeightValue !\u003d null) {\n                                paragraph.setSpacingBetween(lineHeightValue * 240, LineSpacingRule.AUTO)\n                            }\n                        }\n                    }\n                }\n            } catch (e: Exception) {\n                Logger.w(\&quot;Failed to parse style: $property \u003d $value. Error: ${e.message}\&quot;)\n            }\n        }\n    }\n}&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Now I can see the issue is around line 577 where there\u0027s a `val` being assigned again. Let me look at the specific lines around that area:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_016sFbkNMfDvQSfxqj3fzeHb&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;grep_search&quot;,&quot;arguments&quot;:&quot;{\&quot;query\&quot;: \&quot;577\&quot;, \&quot;include_pattern\&quot;: \&quot;EditDocxScreen.kt\&quot;, \&quot;explanation\&quot;: \&quot;Looking for the specific line 577 causing the reassignment error\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;grep_search&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_016sFbkNMfDvQSfxqj3fzeHb&quot;,&quot;content&quot;:&quot;The grep_search tool found no files.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Let me check the code around line 570-580:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01GPAuZEEXwjLTpSC4MaMPsz&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;read_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;read_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01GPAuZEEXwjLTpSC4MaMPsz&quot;,&quot;content&quot;:&quot;package com.example.docx.ui\n\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.net.Uri\nimport android.util.Base64\nimport android.webkit.WebView\nimport androidx.activity.compose.rememberLauncherForActivityResult\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.ColorFilter\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.viewinterop.AndroidView\nimport androidx.documentfile.provider.DocumentFile\nimport androidx.navigation.NavController\nimport com.example.docx.R\nimport com.example.docx.util.Logger\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport org.apache.poi.common.usermodel.PictureType\nimport org.apache.poi.util.Units\nimport org.apache.poi.xwpf.usermodel.*\nimport org.openxmlformats.schemas.officeDocument.x2006.sharedTypes.STVerticalAlignRun as OfficeSTVerticalAlignRun\nimport org.openxmlformats.schemas.wordprocessingml.x2006.main.*\nimport org.jsoup.Jsoup\nimport org.jsoup.nodes.Element\nimport org.jsoup.nodes.Node\nimport org.jsoup.nodes.TextNode\nimport java.io.ByteArrayInputStream\nimport java.io.ByteArrayOutputStream\nimport java.io.IOException\nimport java.math.BigInteger\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// EditDocxScreen Composable\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n@OptIn(ExperimentalMaterial3Api::class)\n@SuppressLint(\&quot;SetJavaScriptEnabled\&quot;)\n@Composable\nfun EditDocxScreen(navController: NavController, fileUriString: String) {\n    var documentHtml by remember { mutableStateOf(\&quot;\u003cp\u003e\u003c/p\u003e\&quot;) }\n    var isLoading by remember { mutableStateOf(true) }\n    var isSaving by remember { mutableStateOf(false) }\n    val context \u003d LocalContext.current\n    val scope \u003d rememberCoroutineScope()\n    var errorMessage by remember { mutableStateOf\u003cString?\u003e(null) }\n    var showErrorDialog by remember { mutableStateOf(false) }\n    val webView \u003d remember { WebView(context) }\n\n    val currentFileUri \u003d remember { Uri.parse(fileUriString) }\n\n    val saveAsLauncher \u003d rememberLauncherForActivityResult(\n        contract \u003d ActivityResultContracts.CreateDocument(\&quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document\&quot;),\n        onResult \u003d { newFileUri: Uri? -\u003e\n            if (newFileUri !\u003d null) {\n                webView.evaluateJavascript(\n                    \&quot;(function() { return document.documentElement.outerHTML; })();\&quot;\n                ) { htmlContent -\u003e\n                    scope.launch {\n                        isSaving \u003d true\n                        val result \u003d writeHtmlToDocx(context, newFileUri, htmlContent ?: \&quot;\u003chtml\u003e\u003cbody\u003e\u003c/body\u003e\u003c/html\u003e\&quot;)\n                        result.fold(\n                            onSuccess \u003d {\n                                Logger.i(\&quot;Document saved successfully to $newFileUri\&quot;)\n                                navController.navigateUp()\n                            },\n                            onFailure \u003d { error -\u003e\n                                errorMessage \u003d \&quot;Save failed: ${error.message}\&quot;\n                                showErrorDialog \u003d true\n                            }\n                        )\n                        if(!showErrorDialog) isSaving \u003d false\n                    }\n                }\n            } else {\n                isSaving \u003d false\n                Logger.d(\&quot;Save As action cancelled.\&quot;)\n            }\n        }\n    )\n\n    LaunchedEffect(currentFileUri) {\n        isLoading \u003d true\n        Logger.d(\&quot;LaunchedEffect: Loading DOCX from $currentFileUri\&quot;)\n        withContext(Dispatchers.IO) {\n            try {\n                context.contentResolver.openInputStream(currentFileUri)?.use { inputStream -\u003e\n                    val document \u003d XWPFDocument(inputStream)\n                    val html \u003d convertDocxToHtmlEnhanced(document)\n                    withContext(Dispatchers.Main) {\n                        documentHtml \u003d html\n                        Logger.d(\&quot;Document loaded and converted to HTML successfully.\&quot;)\n                    }\n                    document.close()\n                } ?: throw IOException(\&quot;Failed to open input stream for $currentFileUri\&quot;)\n            } catch (e: Exception) {\n                Logger.e(\&quot;Error loading DOCX: ${e.localizedMessage}\&quot;, e)\n                withContext(Dispatchers.Main) {\n                    errorMessage \u003d \&quot;Load failed: ${e.localizedMessage}\&quot;\n                    showErrorDialog \u003d true\n                }\n            } finally {\n                withContext(Dispatchers.Main) {\n                    isLoading \u003d false\n                }\n            }\n        }\n    }\n\n    if (showErrorDialog) {\n        AlertDialog(\n            onDismissRequest \u003d {\n                showErrorDialog \u003d false\n                isSaving \u003d false\n            },\n            title \u003d { Text(\&quot;Error\&quot;) },\n            text \u003d { Text(errorMessage ?: \&quot;An unknown error occurred.\&quot;) },\n            confirmButton \u003d {\n                TextButton(onClick \u003d {\n                    showErrorDialog \u003d false\n                    isSaving \u003d false\n                    if (errorMessage?.startsWith(\&quot;Load failed\&quot;) \u003d\u003d true) navController.navigateUp()\n                }) { Text(\&quot;OK\&quot;) }\n            }\n        )\n    }\n\n    Scaffold(\n        topBar \u003d {\n            TopAppBar(\n                title \u003d { Text(DocumentFile.fromSingleUri(context, currentFileUri)?.name ?: \&quot;Edit Document\&quot;) },\n                navigationIcon \u003d {\n                    IconButton(onClick \u003d { navController.navigateUp() }, enabled \u003d !isSaving) {\n                        Icon(Icons.AutoMirrored.Filled.ArrowBack, \&quot;Back\&quot;)\n                    }\n                },\n                actions \u003d {\n                    TextButton(\n                        onClick \u003d {\n                            isSaving \u003d true\n                            val originalFileName \u003d DocumentFile.fromSingleUri(context, currentFileUri)?.name ?: \&quot;Untitled.docx\&quot;\n                            saveAsLauncher.launch(originalFileName)\n                        },\n                        enabled \u003d !isLoading \u0026\u0026 !isSaving\n                    ) {\n                        Text(if (isSaving) \&quot;Saving...\&quot; else \&quot;Save\&quot;)\n                    }\n                }\n            )\n        }\n    ) { paddingValues -\u003e\n        Column(\n            modifier \u003d Modifier\n                .fillMaxSize()\n                .padding(paddingValues)\n        ) {\n            FormattingToolbar(webView \u003d webView)\n            Box(modifier \u003d Modifier.weight(1f)) {\n                if (isLoading) {\n                    CircularProgressIndicator(modifier \u003d Modifier.align(Alignment.Center))\n                } else {\n                    AndroidView(\n                        factory \u003d { webViewContext -\u003e\n                            webView.apply {\n                                settings.javaScriptEnabled \u003d true\n                                settings.domStorageEnabled \u003d true\n                                settings.allowFileAccess \u003d true\n                                settings.defaultTextEncodingName \u003d \&quot;utf-8\&quot;\n                                settings.builtInZoomControls \u003d true\n                                settings.displayZoomControls \u003d false\n\n                                webViewClient \u003d object : android.webkit.WebViewClient() {\n                                    override fun onPageFinished(view: WebView?, url: String?) {\n                                        evaluateJavascript(\&quot;document.body.contentEditable \u003d true;\&quot;) {}\n                                    }\n                                }\n                                loadDataWithBaseURL(null, documentHtml, \&quot;text/html\&quot;, \&quot;utf-8\&quot;, null)\n                            }\n                        },\n                        modifier \u003d Modifier\n                            .fillMaxSize()\n                            .padding(horizontal \u003d 16.dp)\n                    )\n                }\n                if (isSaving) {\n                    Surface(modifier \u003d Modifier.fillMaxSize(), color \u003d MaterialTheme.colorScheme.surface.copy(alpha \u003d 0.8f)) {\n                        Column(\n                            modifier \u003d Modifier.fillMaxSize(),\n                            horizontalAlignment \u003d Alignment.CenterHorizontally,\n                            verticalArrangement \u003d Arrangement.Center\n                        ) {\n                            CircularProgressIndicator()\n                            Spacer(modifier \u003d Modifier.height(16.dp))\n                            Text(\&quot;Preparing to save...\&quot;)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun FormattingToolbar(webView: WebView) {\n    val fonts \u003d listOf(\&quot;Arial\&quot;, \&quot;Calibri\&quot;, \&quot;Courier New\&quot;, \&quot;Georgia\&quot;, \&quot;Times New Roman\&quot;, \&quot;Verdana\&quot;)\n    var selectedFont by remember { mutableStateOf(fonts[0]) }\n    var isFontDropdownExpanded by remember { mutableStateOf(false) }\n\n    var isBoldSelected by remember { mutableStateOf(false) }\n    var isItalicSelected by remember { mutableStateOf(false) }\n    var isUnderlineSelected by remember { mutableStateOf(false) }\n\n    Row(\n        modifier \u003d Modifier\n            .fillMaxWidth()\n            .padding(horizontal \u003d 8.dp, vertical \u003d 4.dp),\n        verticalAlignment \u003d Alignment.CenterVertically,\n        horizontalArrangement \u003d Arrangement.spacedBy(8.dp)\n    ) {\n        ExposedDropdownMenuBox(\n            expanded \u003d isFontDropdownExpanded,\n            onExpandedChange \u003d { isFontDropdownExpanded \u003d !isFontDropdownExpanded },\n            modifier \u003d Modifier.weight(1f)\n        ) {\n            OutlinedTextField(\n                value \u003d selectedFont,\n                onValueChange \u003d {},\n                readOnly \u003d true,\n                label \u003d { Text(\&quot;Font\&quot;) },\n                trailingIcon \u003d { ExposedDropdownMenuDefaults.TrailingIcon(expanded \u003d isFontDropdownExpanded) },\n                modifier \u003d Modifier.menuAnchor()\n            )\n            ExposedDropdownMenu(\n                expanded \u003d isFontDropdownExpanded,\n                onDismissRequest \u003d { isFontDropdownExpanded \u003d false }\n            ) {\n                fonts.forEach { fontName -\u003e\n                    DropdownMenuItem(\n                        text \u003d { Text(fontName) },\n                        onClick \u003d {\n                            selectedFont \u003d fontName\n                            isFontDropdownExpanded \u003d false\n                            webView.evaluateJavascript(\&quot;document.execCommand(\u0027fontName\u0027, false, \u0027$fontName\u0027);\&quot;, null)\n                        }\n                    )\n                }\n            }\n        }\n\n        IconButton(onClick \u003d {\n            isBoldSelected \u003d !isBoldSelected\n            webView.evaluateJavascript(\&quot;document.execCommand(\u0027bold\u0027);\&quot;, null)\n        }) {\n            Image(\n                painter \u003d painterResource(id \u003d R.drawable.bold),\n                contentDescription \u003d \&quot;Bold\&quot;,\n                colorFilter \u003d if (isBoldSelected) ColorFilter.tint(MaterialTheme.colorScheme.primary) else null\n            )\n        }\n\n        IconButton(onClick \u003d {\n            isItalicSelected \u003d !isItalicSelected\n            webView.evaluateJavascript(\&quot;document.execCommand(\u0027italic\u0027);\&quot;, null)\n        }) {\n            Icon(\n                painter \u003d painterResource(R.drawable.bold),\n                contentDescription \u003d \&quot;Italic\&quot;,\n                tint \u003d if (isItalicSelected) MaterialTheme.colorScheme.primary else Color.Unspecified\n            )\n        }\n\n        IconButton(onClick \u003d {\n            isUnderlineSelected \u003d !isUnderlineSelected\n            webView.evaluateJavascript(\&quot;document.execCommand(\u0027underline\u0027);\&quot;, null)\n        }) {\n            Icon(\n                painter \u003d painterResource(R.drawable.bold),\n                contentDescription \u003d \&quot;Underline\&quot;,\n                tint \u003d if (isUnderlineSelected) MaterialTheme.colorScheme.primary else Color.Unspecified\n            )\n        }\n    }\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// DOCX -\u003e HTML CONVERSION (Enhanced)\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nfun convertDocxToHtmlEnhanced(document: XWPFDocument): String {\n    val html \u003d StringBuilder()\n    html.append(\&quot;\u003c!DOCTYPE html\u003e\u003chtml\u003e\u003chead\u003e\&quot;)\n    html.append(\&quot;\u003cmeta charset\u003d\\\&quot;UTF-8\\\&quot;\u003e\&quot;)\n    html.append(\&quot;\u003cmeta name\u003d\\\&quot;viewport\\\&quot; content\u003d\\\&quot;width\u003ddevice-width, initial-scale\u003d1.0, user-scalable\u003dyes\\\&quot;\u003e\&quot;)\n    html.append(\&quot;\u003cstyle\u003e\&quot;)\n    html.append(\&quot;body { font-family: Arial, sans-serif; font-size: 12pt; margin: 0; padding: 20px; background: #f0f0f0; word-wrap: break-word; }\&quot;)\n    html.append(\&quot;.page { background: white; width: 21cm; min-height: 29.7cm; margin: 0 auto 20px auto; padding: 2.54cm; box-shadow: 0 4px 8px rgba(0,0,0,0.1); position: relative; page-break-after: always; overflow-wrap: break-word; }\&quot;)\n    html.append(\&quot;.page:last-child { page-break-after: auto; }\&quot;)\n    html.append(\&quot;p { margin-bottom: 0.5em; }\&quot;)\n    html.append(\&quot;table { border-collapse: collapse; width: 100%; margin-bottom: 1em; table-layout: fixed; }\&quot;)\n    html.append(\&quot;td, th { border: 1px solid #BFBFBF; padding: 6px 8px; vertical-align: top; text-align: left; word-wrap: break-word; font-size: 10pt; }\&quot;)\n    html.append(\&quot;img { max-width: 100%; height: auto; display: block; margin: 0.2em 0; }\&quot;)\n    html.append(\&quot;ul, ol { margin: 0.5em 0; padding-left: 2em; }\&quot;)\n    html.append(\&quot;li { margin-bottom: 0.25em; }\&quot;)\n    html.append(\&quot;h1, h2, h3, h4, h5, h6 { margin-top: 1em; margin-bottom: 0.5em; }\&quot;)\n    html.append(\&quot;.page-number { position: absolute; bottom: 1.27cm; right: 2.54cm; font-size: 10pt; color: #666; pointer-events: none; }\&quot;)\n    html.append(\&quot;\u003c/style\u003e\&quot;)\n    html.append(\&quot;\u003cscript\u003e\&quot;)\n    html.append(\&quot;let pageCounter \u003d 1;\&quot;)\n    html.append(\&quot;let isProcessing \u003d false;\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;function createNewPage() {\&quot;)\n    html.append(\&quot;  pageCounter++;\&quot;)\n    html.append(\&quot;  const newPage \u003d document.createElement(\u0027div\u0027);\&quot;)\n    html.append(\&quot;  newPage.className \u003d \u0027page\u0027;\&quot;)\n    html.append(\&quot;  newPage.id \u003d \u0027page\u0027 + pageCounter;\&quot;)\n    html.append(\&quot;  newPage.innerHTML \u003d \u0027\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u0027;\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  // Add page number\&quot;)\n    html.append(\&quot;  const pageNum \u003d document.createElement(\u0027div\u0027);\&quot;)\n    html.append(\&quot;  pageNum.className \u003d \u0027page-number\u0027;\&quot;)\n    html.append(\&quot;  pageNum.textContent \u003d pageCounter;\&quot;)\n    html.append(\&quot;  newPage.appendChild(pageNum);\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  document.body.appendChild(newPage);\&quot;)\n    html.append(\&quot;  return newPage;\&quot;)\n    html.append(\&quot;}\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;function updatePageNumbers() {\&quot;)\n    html.append(\&quot;  const pages \u003d document.querySelectorAll(\u0027.page\u0027);\&quot;)\n    html.append(\&quot;  pages.forEach((page, index) \u003d\u003e {\&quot;)\n    html.append(\&quot;    let pageNum \u003d page.querySelector(\u0027.page-number\u0027);\&quot;)\n    html.append(\&quot;    if (!pageNum) {\&quot;)\n    html.append(\&quot;      pageNum \u003d document.createElement(\u0027div\u0027);\&quot;)\n    html.append(\&quot;      pageNum.className \u003d \u0027page-number\u0027;\&quot;)\n    html.append(\&quot;      page.appendChild(pageNum);\&quot;)\n    html.append(\&quot;    }\&quot;)\n    html.append(\&quot;    pageNum.textContent \u003d index + 1;\&quot;)\n    html.append(\&quot;  });\&quot;)\n    html.append(\&quot;}\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;function checkPageOverflow() {\&quot;)\n    html.append(\&quot;  if (isProcessing) return;\&quot;)\n    html.append(\&quot;  isProcessing \u003d true;\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  const pages \u003d document.querySelectorAll(\u0027.page\u0027);\&quot;)\n    html.append(\&quot;  const pageHeight \u003d 29.7 * 37.795; // A4 height in pixels\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  pages.forEach((page, index) \u003d\u003e {\&quot;)\n    html.append(\&quot;    const contentHeight \u003d page.scrollHeight;\&quot;)\n    html.append(\&quot;    if (contentHeight \u003e pageHeight) {\&quot;)\n    html.append(\&quot;      // Create new page if it doesn\u0027t exist\&quot;)\n    html.append(\&quot;      let nextPage \u003d document.getElementById(\u0027page\u0027 + (index + 2));\&quot;)\n    html.append(\&quot;      if (!nextPage) {\&quot;)\n    html.append(\&quot;        nextPage \u003d createNewPage();\&quot;)\n    html.append(\&quot;      }\&quot;)\n    html.append(\&quot;      \&quot;)\n    html.append(\&quot;      // Move overflow content to next page\&quot;)\n    html.append(\&quot;      const elements \u003d Array.from(page.children);\&quot;)\n    html.append(\&quot;      let totalHeight \u003d 0;\&quot;)\n    html.append(\&quot;      let moveIndex \u003d -1;\&quot;)\n    html.append(\&quot;      \&quot;)\n    html.append(\&quot;      for (let i \u003d 0; i \u003c elements.length; i++) {\&quot;)\n    html.append(\&quot;        const elem \u003d elements[i];\&quot;)\n    html.append(\&quot;        if (elem.className \u003d\u003d\u003d \u0027page-number\u0027) continue;\&quot;)\n    html.append(\&quot;        \&quot;)\n    html.append(\&quot;        const elemHeight \u003d elem.offsetHeight;\&quot;)\n    html.append(\&quot;        if (totalHeight + elemHeight \u003e pageHeight - 100) {\&quot;) // Leave some margin\n    html.append(\&quot;          moveIndex \u003d i;\&quot;)\n    html.append(\&quot;          break;\&quot;)\n    html.append(\&quot;        }\&quot;)\n    html.append(\&quot;        totalHeight +\u003d elemHeight;\&quot;)\n    html.append(\&quot;      }\&quot;)\n    html.append(\&quot;      \&quot;)\n    html.append(\&quot;      if (moveIndex !\u003d\u003d -1) {\&quot;)\n    html.append(\&quot;        for (let i \u003d moveIndex; i \u003c elements.length; i++) {\&quot;)\n    html.append(\&quot;          const elem \u003d elements[i];\&quot;)\n    html.append(\&quot;          if (elem.className !\u003d\u003d \u0027page-number\u0027) {\&quot;)\n    html.append(\&quot;            nextPage.insertBefore(elem, nextPage.querySelector(\u0027.page-number\u0027));\&quot;)\n    html.append(\&quot;          }\&quot;)\n    html.append(\&quot;        }\&quot;)\n    html.append(\&quot;      }\&quot;)\n    html.append(\&quot;    }\&quot;)\n    html.append(\&quot;  });\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  updatePageNumbers();\&quot;)\n    html.append(\&quot;  isProcessing \u003d false;\&quot;)\n    html.append(\&quot;}\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;function ensureMinimumOnePage() {\&quot;)\n    html.append(\&quot;  if (document.querySelectorAll(\u0027.page\u0027).length \u003d\u003d\u003d 0) {\&quot;)\n    html.append(\&quot;    const firstPage \u003d document.createElement(\u0027div\u0027);\&quot;)\n    html.append(\&quot;    firstPage.className \u003d \u0027page\u0027;\&quot;)\n    html.append(\&quot;    firstPage.id \u003d \u0027page1\u0027;\&quot;)\n    html.append(\&quot;    firstPage.innerHTML \u003d \u0027\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u0027;\&quot;)\n    html.append(\&quot;    document.body.appendChild(firstPage);\&quot;)\n    html.append(\&quot;  }\&quot;)\n    html.append(\&quot;  updatePageNumbers();\&quot;)\n    html.append(\&quot;}\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;document.addEventListener(\u0027DOMContentLoaded\u0027, function() {\&quot;)\n    html.append(\&quot;  ensureMinimumOnePage();\&quot;)\n    html.append(\&quot;  setTimeout(checkPageOverflow, 500);\&quot;)\n    html.append(\&quot;});\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;document.addEventListener(\u0027input\u0027, function() {\&quot;)\n    html.append(\&quot;  setTimeout(checkPageOverflow, 300);\&quot;)\n    html.append(\&quot;});\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;document.addEventListener(\u0027keydown\u0027, function(e) {\&quot;)\n    html.append(\&quot;  if (e.ctrlKey \u0026\u0026 e.key \u003d\u003d\u003d \u0027Enter\u0027) {\&quot;)\n    html.append(\&quot;    e.preventDefault();\&quot;)\n    html.append(\&quot;    createNewPage();\&quot;)\n    html.append(\&quot;    updatePageNumbers();\&quot;)\n    html.append(\&quot;  }\&quot;)\n    html.append(\&quot;});\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;// Periodic check for content changes\&quot;)\n    html.append(\&quot;setInterval(checkPageOverflow, 2000);\&quot;)\n    html.append(\&quot;\u003c/script\u003e\&quot;)\n    html.append(\&quot;\u003c/head\u003e\u003cbody\u003e\&quot;)\n\n    html.append(\&quot;\u003cdiv class\u003d\u0027page\u0027 id\u003d\u0027page1\u0027\u003e\&quot;)\n\n    for (bodyElement in document.bodyElements) {\n        when (bodyElement) {\n            is XWPFParagraph -\u003e html.append(convertParagraphToHtmlExact(bodyElement))\n            is XWPFTable -\u003e html.append(convertTableToHtmlExact(bodyElement))\n        }\n    }\n\n    html.append(\&quot;\u003c/div\u003e\&quot;) // Close first page\n    html.append(\&quot;\u003c/body\u003e\u003c/html\u003e\&quot;)\n    return html.toString()\n}\n\nfun convertParagraphToHtmlExact(paragraph: XWPFParagraph): String {\n    val style \u003d buildString {\n        if (paragraph.spacingBefore \u003e 0) append(\&quot;margin-top: ${paragraph.spacingBefore / 20.0}pt; \&quot;)\n        if (paragraph.spacingAfter \u003e 0) append(\&quot;margin-bottom: ${paragraph.spacingAfter / 20.0}pt; \&quot;)\n        if (paragraph.spacingLineRule \u003d\u003d LineSpacingRule.AUTO \u0026\u0026 paragraph.spacingBetween \u003e 0) {\n            append(\&quot;line-height: ${paragraph.spacingBetween / 240.0}; \&quot;)\n        }\n        if (paragraph.alignment !\u003d ParagraphAlignment.LEFT) {\n            append(\&quot;text-align: ${paragraph.alignment.name.lowercase()}; \&quot;)\n        }\n    }\n    val pTag \u003d StringBuilder()\n    pTag.append(\&quot;\u003cp style\u003d\u0027${style}\u0027\u003e\&quot;)\n    var contentAdded \u003d false\n    for (run in paragraph.runs) {\n        val runHtml \u003d convertRunToHtmlExact(run)\n        if (runHtml.isNotBlank()) {\n            pTag.append(runHtml)\n            contentAdded \u003d true\n        }\n    }\n    if (!contentAdded \u0026\u0026 paragraph.text.isBlank()) {\n        pTag.append(\&quot;\u0026nbsp;\&quot;)\n    }\n    pTag.append(\&quot;\u003c/p\u003e\&quot;)\n    return pTag.toString()\n}\n\nfun convertRunToHtmlExact(run: XWPFRun): String {\n    val style \u003d buildString {\n        val fontSizeInPoints: Double? \u003d run.getFontSizeAsDouble()\n        if (fontSizeInPoints !\u003d null \u0026\u0026 fontSizeInPoints \u003e 0) {\n            append(\&quot;font-size: ${fontSizeInPoints}pt; \&quot;)\n        }\n        if (!run.fontFamily.isNullOrEmpty()) append(\&quot;font-family: \u0027${run.fontFamily}\u0027; \&quot;)\n        if (run.color !\u003d null \u0026\u0026 run.color !\u003d \&quot;auto\&quot;) append(\&quot;color: #${run.color}; \&quot;)\n        if (run.isBold) append(\&quot;font-weight: bold; \&quot;)\n        if (run.isItalic) append(\&quot;font-style: italic; \&quot;)\n        if (run.isStrikeThrough) append(\&quot;text-decoration: line-through; \&quot;)\n        if (run.underline !\u003d UnderlinePatterns.NONE \u0026\u0026 run.underline !\u003d null) append(\&quot;text-decoration: underline; \&quot;)\n    }\n    var text \u003d run.text() ?: \&quot;\&quot;\n    text \u003d text.replace(\&quot;\u0026\&quot;, \&quot;\u0026amp;\&quot;)\n        .replace(\&quot;\u003c\&quot;, \&quot;\u0026lt;\&quot;)\n        .replace(\&quot;\u003e\&quot;, \&quot;\u0026gt;\&quot;)\n        .replace(\&quot;\\\&quot;\&quot;, \&quot;\u0026quot;\&quot;)\n        .replace(\&quot;\\t\&quot;, \&quot;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\&quot;)\n        .replace(\&quot;\\n\&quot;, \&quot;\u003cbr\u003e\&quot;)\n    var html \u003d \&quot;\u003cspan style\u003d\u0027${style}\u0027\u003e$text\u003c/span\u003e\&quot;\n    when (run.getVerticalAlignment()) {\n        OfficeSTVerticalAlignRun.SUBSCRIPT -\u003e html \u003d \&quot;\u003csub\u003e$html\u003c/sub\u003e\&quot;\n        OfficeSTVerticalAlignRun.SUPERSCRIPT -\u003e html \u003d \&quot;\u003csup\u003e$html\u003c/sup\u003e\&quot;\n        else -\u003e {}\n    }\n    for (pic in run.embeddedPictures) {\n        try {\n            val picData \u003d pic.pictureData\n            val ext \u003d when (picData.pictureTypeEnum) {\n                PictureType.JPEG -\u003e \&quot;jpeg\&quot;\n                PictureType.PNG -\u003e \&quot;png\&quot;\n                PictureType.GIF -\u003e \&quot;gif\&quot;\n                PictureType.BMP -\u003e \&quot;bmp\&quot;\n                PictureType.WMF -\u003e \&quot;wmf\&quot;\n                PictureType.EMF -\u003e \&quot;emf\&quot;\n                PictureType.PICT -\u003e \&quot;pict\&quot;\n                PictureType.TIFF -\u003e \&quot;tiff\&quot;\n                else -\u003e \&quot;png\&quot;\n            }\n            val base64 \u003d Base64.encodeToString(picData.data, Base64.DEFAULT)\n            val xfrm \u003d pic.ctPicture?.spPr?.xfrm\n            var imgWidth \u003d \&quot;auto\&quot;\n            var imgHeight \u003d \&quot;auto\&quot;\n            if (xfrm?.ext !\u003d null) {\n                val widthEmu \u003d xfrm.ext.cx\n                val heightEmu \u003d xfrm.ext.cy\n                imgWidth \u003d \&quot;${widthEmu / Units.EMU_PER_PIXEL}px\&quot;\n                imgHeight \u003d \&quot;${heightEmu / Units.EMU_PER_PIXEL}px\&quot;\n            }\n            html +\u003d \&quot;\u003cimg src\u003d\u0027data:image/$ext;base64,$base64\u0027 width\u003d\u0027$imgWidth\u0027 height\u003d\u0027$imgHeight\u0027 alt\u003d\u0027${pic.description ?: \&quot;Embedded image\&quot;}\u0027 /\u003e\&quot;\n        } catch (e: Exception) {\n            Logger.e(\&quot;Error processing embedded picture: ${e.message}\&quot;, e)\n            html +\u003d \&quot;\u003c!-- Error loading image: ${e.message} --\u003e\&quot;\n        }\n    }\n    return html\n}\n\nfun convertTableToHtmlExact(table: XWPFTable): String {\n    val html \u003d StringBuilder(\&quot;\u003ctable\u003e\&quot;)\n    for (row in table.rows) {\n        html.append(\&quot;\u003ctr\u003e\&quot;)\n        for (cell in row.tableCells) {\n            html.append(\&quot;\u003ctd\u003e\&quot;)\n            cell.bodyElements.forEach { element -\u003e\n                when (element) {\n                    is XWPFParagraph -\u003e html.append(convertParagraphToHtmlExact(element))\n                    is XWPFTable -\u003e html.append(convertTableToHtmlExact(element))\n                }\n            }\n            html.append(\&quot;\u003c/td\u003e\&quot;)\n        }\n        html.append(\&quot;\u003c/tr\u003e\&quot;)\n    }\n    html.append(\&quot;\u003c/table\u003e\&quot;)\n    return html.toString()\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// ENHANCED HTML -\u003e DOCX CONVERSION WITH FULL FORMATTING SUPPORT\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nsuspend fun writeHtmlToDocx(context: Context, uri: Uri, htmlContent: String): Result\u003cUnit\u003e {\n    Logger.d(\&quot;Starting enhanced writeHtmlToDocx for $uri\&quot;)\n    return withContext(Dispatchers.IO) {\n        runCatching {\n            // First, try to preserve the original document structure by reading the existing file\n            val originalDocument \u003d try {\n                context.contentResolver.openInputStream(uri)?.use { inputStream -\u003e\n                    val doc \u003d XWPFDocument(inputStream)\n                    // Create a copy of the document structure\n                    val newDoc \u003d XWPFDocument()\n\n                    // Copy document properties\n                    try {\n                        val coreProps \u003d doc.properties?.coreProperties\n                        coreProps?.let { props -\u003e\n                            val newProps \u003d newDoc.properties?.coreProperties\n                            newProps?.creator \u003d props.creator\n                            newProps?.title \u003d props.title\n                            newProps?.subject \u003d props.subject\n                            newProps?.description \u003d props.description\n                            newProps?.category \u003d props.category\n                            newProps?.keywords \u003d props.keywords\n                        }\n                    } catch (e: Exception) {\n                        Logger.w(\&quot;Could not copy document properties: ${e.message}\&quot;)\n                    }\n\n                    doc.close()\n                    newDoc\n                }\n            } catch (e: Exception) {\n                Logger.w(\&quot;Could not read original document, creating new one: ${e.message}\&quot;)\n                null\n            }\n\n            val document \u003d originalDocument ?: XWPFDocument()\n\n            try {\n                val rawHtml \u003d cleanHtmlContent(htmlContent)\n                Logger.d(\&quot;Cleaned HTML (first 500 chars): ${rawHtml.take(500)}\&quot;)\n\n                val jsoupDoc \u003d Jsoup.parse(rawHtml)\n\n                // Set document defaults to ensure proper DOCX structure\n                setDocumentDefaults(document)\n\n                // Clear existing content while preserving document structure\n                clearDocumentContent(document)\n\n                val body \u003d jsoupDoc.body()\n                val docContext \u003d DocumentContext()\n\n                // Parse with enhanced processor\n                parseEnhancedJsoupNode(body, document, null, context, docContext)\n\n                // Remove empty first paragraph if exists\n                removeEmptyFirstParagraph(document)\n\n                // Ensure document has at least one paragraph (required for valid DOCX)\n                ensureMinimumContent(document)\n\n                // Write to temporary buffer first to validate\n                val tempBuffer \u003d ByteArrayOutputStream()\n                document.write(tempBuffer)\n\n                // If successful, write to actual file\n                context.contentResolver.openOutputStream(uri, \&quot;wt\&quot;)?.use { outputStream -\u003e\n                    outputStream.write(tempBuffer.toByteArray())\n                    outputStream.flush()\n                } ?: throw IOException(\&quot;Unable to open output stream for $uri\&quot;)\n\n                document.close()\n                Logger.i(\&quot;DOCX saved successfully to $uri with enhanced formatting\&quot;)\n            } catch (e: Exception) {\n                document.close()\n                throw e\n            }\n        }.onFailure { e -\u003e\n            Logger.e(\&quot;Error in enhanced writeHtmlToDocx: ${e.message}\&quot;, e)\n        }\n    }\n}\n\n// Clear document content while preserving structure\nprivate fun clearDocumentContent(document: XWPFDocument) {\n    try {\n        // Remove all body elements\n        val bodyElements \u003d document.bodyElements.toList()\n        bodyElements.forEachIndexed { index, _ -\u003e\n            if (document.bodyElements.isNotEmpty()) {\n                document.removeBodyElement(0)\n            }\n        }\n    } catch (e: Exception) {\n        Logger.w(\&quot;Failed to clear document content: ${e.message}\&quot;)\n    }\n}\n\n// Ensure document has minimum required content\nprivate fun ensureMinimumContent(document: XWPFDocument) {\n    if (document.bodyElements.isEmpty()) {\n        val paragraph \u003d document.createParagraph()\n        val run \u003d paragraph.createRun()\n        run.setText(\&quot; \&quot;) // Add a space to ensure the paragraph is not completely empty\n    }\n}\n\n// Clean HTML content\nprivate fun cleanHtmlContent(htmlContent: String): String {\n    var cleaned \u003d htmlContent\n\n    // Remove JSON escaping if present\n    if (cleaned.startsWith(\&quot;\\\&quot;\&quot;) \u0026\u0026 cleaned.endsWith(\&quot;\\\&quot;\&quot;)) {\n        cleaned \u003d cleaned.substring(1, cleaned.length - 1)\n    }\n\n    cleaned \u003d cleaned\n        .replace(\&quot;\\\\u003C\&quot;, \&quot;\u003c\&quot;)\n        .replace(\&quot;\\\\u003E\&quot;, \&quot;\u003e\&quot;)\n        .replace(\&quot;\\\\\\\&quot;\&quot;, \&quot;\\\&quot;\&quot;)\n        .replace(\&quot;\\\\n\&quot;, \&quot;\\n\&quot;)\n        .replace(\&quot;\\\\t\&quot;, \&quot;\\t\&quot;)\n        .replace(\&quot;\\\\r\&quot;, \&quot;\\r\&quot;)\n        .replace(\&quot;\u0026nbsp;\&quot;, \&quot; \&quot;)\n        .replace(\&quot;\\\\\\\\\&quot;, \&quot;\\\\\&quot;)\n\n    // Remove script tags and their content\n    cleaned \u003d cleaned.replace(Regex(\&quot;\u003cscript[^\u003e]*\u003e.*?\u003c/script\u003e\&quot;, RegexOption.DOT_MATCHES_ALL), \&quot;\&quot;)\n\n    // Remove style tags but keep the content structure\n    cleaned \u003d cleaned.replace(Regex(\&quot;\u003cstyle[^\u003e]*\u003e.*?\u003c/style\u003e\&quot;, RegexOption.DOT_MATCHES_ALL), \&quot;\&quot;)\n\n    // Clean up page containers but preserve content\n    cleaned \u003d cleaned.replace(Regex(\&quot;\u003cdiv[^\u003e]*class\u003d[\u0027\\\&quot;]page[\u0027\\\&quot;][^\u003e]*\u003e\&quot;), \&quot;\u003cdiv\u003e\&quot;)\n\n    return cleaned\n}\n\n// Set document defaults with proper validation\nprivate fun setDocumentDefaults(document: XWPFDocument) {\n    try {\n        val ctDocument \u003d document.document\n        if (ctDocument \u003d\u003d null) {\n            Logger.w(\&quot;Document CTDocument is null, cannot set defaults\&quot;)\n            return\n        }\n\n        val ctBody \u003d ctDocument.body\n        if (ctBody \u003d\u003d null) {\n            Logger.w(\&quot;Document body is null, cannot set defaults\&quot;)\n            return\n        }\n\n        val sectPr \u003d if (ctBody.isSetSectPr) ctBody.sectPr else ctBody.addNewSectPr()\n\n        // Set page size to A4 (210mm x 297mm \u003d 11906 twips x 16838 twips)\n        val pgSz \u003d if (sectPr.isSetPgSz) sectPr.pgSz else sectPr.addNewPgSz()\n        pgSz.w \u003d BigInteger.valueOf(11906) // A4 width in twips\n        pgSz.h \u003d BigInteger.valueOf(16838) // A4 height in twips\n\n        // Set margins (2.54cm \u003d 1440 twips)\n        val pgMar \u003d if (sectPr.isSetPgMar) sectPr.pgMar else sectPr.addNewPgMar()\n        pgMar.top \u003d BigInteger.valueOf(1440)    // 2.54cm\n        pgMar.bottom \u003d BigInteger.valueOf(1440) // 2.54cm\n        pgMar.left \u003d BigInteger.valueOf(1440)   // 2.54cm\n        pgMar.right \u003d BigInteger.valueOf(1440)  // 2.54cm\n\n        // Set default font for the document\n\n    } catch (e: Exception) {\n        Logger.w(\&quot;Failed to set document defaults: ${e.message}\&quot;)\n    }\n}\n\n// Remove empty first paragraph\nprivate fun removeEmptyFirstParagraph(document: XWPFDocument) {\n    if (document.paragraphs.isNotEmpty()) {\n        val firstPara \u003d document.paragraphs[0]\n        if (firstPara.text.isBlank() \u0026\u0026 firstPara.runs.isEmpty()) {\n            if (document.bodyElements.size \u003e 0) {\n                document.removeBodyElement(0)\n            }\n        }\n    }\n}\n\n// Document context\ndata class DocumentContext(\n    var currentListLevel: Int \u003d 0,\n    var isInList: Boolean \u003d false,\n    var currentListType: ListType \u003d ListType.BULLET,\n    var preserveSpacing: Boolean \u003d true,\n    var numberingMap: MutableMap\u003cString, Int\u003e \u003d mutableMapOf()\n)\n\nenum class ListType {\n    BULLET, NUMBERED\n}\n\n// Enhanced HTML node parser with full formatting support\nprivate fun parseEnhancedJsoupNode(\n    jsoupNode: Node,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    context: Context,\n    docContext: DocumentContext\n): XWPFParagraph? {\n    var paragraph \u003d currentParagraph\n\n    when (jsoupNode) {\n        is TextNode -\u003e {\n            val text \u003d jsoupNode.text().replace(\&quot;\\u00A0\&quot;, \&quot; \&quot;)\n            if (text.isNotEmpty() || docContext.preserveSpacing) {\n                paragraph \u003d paragraph ?: document.createParagraph()\n                val run \u003d paragraph.createRun()\n                run.setText(text)\n            }\n        }\n\n        is Element -\u003e {\n            val tagName \u003d jsoupNode.tagName().lowercase()\n\n            paragraph \u003d when (tagName) {\n                // Block elements\n                \&quot;p\&quot;, \&quot;div\&quot; -\u003e handleParagraphElement(jsoupNode, document, docContext, context)\n                \&quot;br\&quot; -\u003e handleLineBreak(document, paragraph)\n\n                // Headings\n                \&quot;h1\&quot;, \&quot;h2\&quot;, \&quot;h3\&quot;, \&quot;h4\&quot;, \&quot;h5\&quot;, \&quot;h6\&quot; -\u003e handleHeading(jsoupNode, document, tagName, docContext, context)\n\n                // Lists\n                \&quot;ul\&quot; -\u003e handleUnorderedList(jsoupNode, document, docContext, context)\n                \&quot;ol\&quot; -\u003e handleOrderedList(jsoupNode, document, docContext, context)\n                \&quot;li\&quot; -\u003e handleListItem(jsoupNode, document, paragraph, docContext, context)\n\n                // Tables\n                \&quot;table\&quot; -\u003e {\n                    handleTable(jsoupNode, document, context, docContext)\n                    null\n                }\n\n                // Inline formatting\n                \&quot;span\&quot;, \&quot;strong\&quot;, \&quot;b\&quot;, \&quot;em\&quot;, \&quot;i\&quot;, \&quot;u\&quot;, \&quot;s\&quot;, \&quot;strike\&quot;, \&quot;del\&quot;,\n                \&quot;sub\&quot;, \&quot;sup\&quot;, \&quot;code\&quot;, \&quot;mark\&quot; -\u003e handleInlineFormatting(jsoupNode, document, paragraph, docContext, context)\n\n                // Images\n                \&quot;img\&quot; -\u003e {\n                    handleImage(jsoupNode, document, context)\n                    null\n                }\n\n                // Blockquote\n                \&quot;blockquote\&quot; -\u003e handleBlockquote(jsoupNode, document, docContext, context)\n\n                // Horizontal rule\n                \&quot;hr\&quot; -\u003e {\n                    handleHorizontalRule(document)\n                    null\n                }\n\n                else -\u003e {\n                    // For unknown elements, process children\n                    for (child in jsoupNode.childNodes()) {\n                        paragraph \u003d parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n                    }\n                    paragraph\n                }\n            }\n        }\n    }\n\n    return paragraph\n}\n\n// Handle paragraph element\nprivate fun handleParagraphElement(\n    element: Element,\n    document: XWPFDocument,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph {\n    val paragraph \u003d document.createParagraph()\n    applyParagraphStyle(paragraph, element)\n\n    for (child in element.childNodes()) {\n        parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n    }\n\n    return paragraph\n}\n\n// Handle line break\nprivate fun handleLineBreak(document: XWPFDocument, currentParagraph: XWPFParagraph?): XWPFParagraph {\n    val paragraph \u003d currentParagraph ?: document.createParagraph()\n    val run \u003d paragraph.createRun()\n    run.addBreak()\n    return paragraph\n}\n\n// Handle headings\nprivate fun handleHeading(\n    element: Element,\n    document: XWPFDocument,\n    tagName: String,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph {\n    val paragraph \u003d document.createParagraph()\n    val level \u003d tagName.substring(1).toIntOrNull() ?: 1\n\n    val fontSize \u003d when (level) {\n        1 -\u003e 22\n        2 -\u003e 18\n        3 -\u003e 16\n        4 -\u003e 14\n        5 -\u003e 12\n        else -\u003e 10\n    }\n\n    applyParagraphStyle(paragraph, element)\n\n    for (child in element.childNodes()) {\n        parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n    }\n\n    // Apply heading formatting to all runs\n    paragraph.runs.forEach { run -\u003e\n        run.isBold \u003d true\n        if (run.fontSize \u003c\u003d 0) {\n            run.fontSize \u003d fontSize\n        }\n    }\n\n    return paragraph\n}\n\n// Handle unordered list\nprivate fun handleUnorderedList(\n    element: Element,\n    document: XWPFDocument,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph? {\n    val previousContext \u003d docContext.copy()\n    docContext.isInList \u003d true\n    docContext.currentListType \u003d ListType.BULLET\n    docContext.currentListLevel++\n\n    var lastParagraph: XWPFParagraph? \u003d null\n    for (child in element.children()) {\n        if (child.tagName().equals(\&quot;li\&quot;, ignoreCase \u003d true)) {\n            lastParagraph \u003d handleListItem(child, document, null, docContext, context)\n        }\n    }\n\n    docContext.currentListLevel \u003d previousContext.currentListLevel\n    docContext.isInList \u003d previousContext.isInList\n    docContext.currentListType \u003d previousContext.currentListType\n\n    return lastParagraph\n}\n\n// Handle ordered list\nprivate fun handleOrderedList(\n    element: Element,\n    document: XWPFDocument,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph? {\n    val previousContext \u003d docContext.copy()\n    docContext.isInList \u003d true\n    docContext.currentListType \u003d ListType.NUMBERED\n    docContext.currentListLevel++\n\n    var lastParagraph: XWPFParagraph? \u003d null\n    for (child in element.children()) {\n        if (child.tagName().equals(\&quot;li\&quot;, ignoreCase \u003d true)) {\n            lastParagraph \u003d handleListItem(child, document, null, docContext, context)\n        }\n    }\n\n    docContext.currentListLevel \u003d previousContext.currentListLevel\n    docContext.isInList \u003d previousContext.isInList\n    docContext.currentListType \u003d previousContext.currentListType\n\n    return lastParagraph\n}\n\n// Handle list item\nprivate fun handleListItem(\n    element: Element,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph {\n    val paragraph \u003d document.createParagraph()\n\n    // Set numbering\n    try {\n//        val numId \u003d getOrCreateNumbering(document, docContext)\n//        paragraph.numID \u003d BigInteger.valueOf(numId.toLong())\n//        paragraph.numILvl \u003d BigInteger.valueOf((docContext.currentListLevel - 1).toLong())\n    } catch (e: Exception) {\n        Logger.w(\&quot;Failed to apply numbering: ${e.message}\&quot;)\n        // Fallback: add bullet/number manually\n        val run \u003d paragraph.createRun()\n        run.setText(if (docContext.currentListType \u003d\u003d ListType.BULLET) \&quot; \&quot; else \&quot;${docContext.currentListLevel}. \&quot;)\n    }\n\n    // Set indentation\n    paragraph.indentationLeft \u003d 720 * docContext.currentListLevel\n\n    for (child in element.childNodes()) {\n        parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n    }\n\n    return paragraph\n}\n\n// Get or create numbering\n//private fun getOrCreateNumbering(document: XWPFDocument, docContext: DocumentContext): Int {\n//    val key \u003d \&quot;${docContext.currentListType}_${docContext.currentListLevel}\&quot;\n//\n//    return docContext.numberingMap.getOrPut(key) {\n//        try {\n//            val numbering \u003d document.createNumbering()\n//            val abstractNumId \u003d numbering.addAbstractNum()\n//            numbering.addNum(abstractNumId)\n//        } catch (e: Exception) {\n//            1\n//        }\n//    }\n//}\n\n// Handle table with full formatting\nprivate fun handleTable(\n    element: Element,\n    document: XWPFDocument,\n    context: Context,\n    docContext: DocumentContext\n) {\n    try {\n        val rows \u003d element.select(\&quot;tr\&quot;)\n        if (rows.isEmpty()) return\n\n        val firstRow \u003d rows.first()\n        val columns \u003d firstRow?.select(\&quot;td, th\&quot;)?.size ?: 0\n\n        val table \u003d document.createTable(rows.size, columns)\n\n        // Set table properties\n        table.width \u003d 5000\n\n        rows.forEachIndexed { rowIndex, rowElement -\u003e\n            val tableRow \u003d table.getRow(rowIndex)\n            val cells \u003d rowElement.select(\&quot;td, th\&quot;)\n\n            cells.forEachIndexed { colIndex, cellElement -\u003e\n                if (colIndex \u003c tableRow.tableCells.size) {\n                    val cell \u003d tableRow.getCell(colIndex)\n\n                    // Apply cell styling\n                    applyCellStyle(cell, cellElement)\n\n                    // Clear default paragraph\n                    if (cell.paragraphs.isNotEmpty()) {\n                        cell.removeParagraph(0)\n                    }\n\n                    // Parse cell content directly in the cell context\n                    var cellParagraph: XWPFParagraph? \u003d null\n\n                    for (child in cellElement.childNodes()) {\n                        cellParagraph \u003d parseEnhancedJsoupNodeInCell(\n                            child,\n                            cell,\n                            cellParagraph,\n                            context,\n                            docContext\n                        )\n                    }\n\n                    // Make header cells bold\n                    if (cellElement.tagName().equals(\&quot;th\&quot;, ignoreCase \u003d true)) {\n                        cell.paragraphs.forEach { para -\u003e\n                            para.runs.forEach { run -\u003e\n                                run.isBold \u003d true\n                            }\n                        }\n                    }\n\n                    // Ensure cell has at least one paragraph\n                    if (cell.paragraphs.isEmpty()) {\n                        cell.addParagraph()\n                    }\n                }\n            }\n        }\n    } catch (e: Exception) {\n        Logger.e(\&quot;Error creating table: ${e.message}\&quot;, e)\n    }\n}\n\n// Enhanced HTML node parser specifically for table cells to handle images correctly\nprivate fun parseEnhancedJsoupNodeInCell(\n    jsoupNode: Node,\n    cell: XWPFTableCell,\n    currentParagraph: XWPFParagraph?,\n    context: Context,\n    docContext: DocumentContext\n): XWPFParagraph? {\n    var paragraph \u003d currentParagraph\n\n    when (jsoupNode) {\n        is TextNode -\u003e {\n            val text \u003d jsoupNode.text().replace(\&quot;\\u00A0\&quot;, \&quot; \&quot;)\n            if (text.isNotEmpty() || docContext.preserveSpacing) {\n                paragraph \u003d paragraph ?: cell.addParagraph()\n                val run \u003d paragraph.createRun()\n                run.setText(text)\n            }\n        }\n\n        is Element -\u003e {\n            val tagName \u003d jsoupNode.tagName().lowercase()\n\n            paragraph \u003d when (tagName) {\n                // Block elements\n                \&quot;p\&quot;, \&quot;div\&quot; -\u003e {\n                    val newParagraph \u003d cell.addParagraph()\n                    applyParagraphStyle(newParagraph, jsoupNode)\n\n                    for (child in jsoupNode.childNodes()) {\n                        paragraph \u003d parseEnhancedJsoupNodeInCell(\n                            child,\n                            cell,\n                            newParagraph,\n                            context,\n                            docContext\n                        )\n                    }\n                    newParagraph\n                }\n\n                \&quot;br\&quot; -\u003e {\n                    val para \u003d paragraph ?: cell.addParagraph()\n                    val run \u003d para.createRun()\n                    run.addBreak()\n                    para\n                }\n\n                // Images - handle directly in cell\n                \&quot;img\&quot; -\u003e {\n                    val imagePara \u003d paragraph ?: cell.addParagraph()\n                    handleImageInCell(jsoupNode, imagePara, context)\n                    imagePara\n                }\n\n                // Inline formatting\n                \&quot;span\&quot;, \&quot;strong\&quot;, \&quot;b\&quot;, \&quot;em\&quot;, \&quot;i\&quot;, \&quot;u\&quot;, \&quot;s\&quot;, \&quot;strike\&quot;, \&quot;del\&quot;,\n                \&quot;sub\&quot;, \&quot;sup\&quot;, \&quot;code\&quot;, \&quot;mark\&quot; -\u003e {\n                    val para \u003d paragraph ?: cell.addParagraph()\n\n                    for (child in jsoupNode.childNodes()) {\n                        when (child) {\n                            is TextNode -\u003e {\n                                val run \u003d para.createRun()\n                                run.setText(child.text())\n                                applyRunFormatting(run, jsoupNode)\n                            }\n\n                            is Element -\u003e {\n                                paragraph \u003d parseEnhancedJsoupNodeInCell(\n                                    child,\n                                    cell,\n                                    para,\n                                    context,\n                                    docContext\n                                )\n                            }\n                        }\n                    }\n                    para\n                }\n\n                else -\u003e {\n                    // For unknown elements, process children\n                    for (child in jsoupNode.childNodes()) {\n                        paragraph \u003d parseEnhancedJsoupNodeInCell(\n                            child,\n                            cell,\n                            paragraph,\n                            context,\n                            docContext\n                        )\n                    }\n                    paragraph\n                }\n            }\n        }\n    }\n\n    return paragraph\n}\n\n// Handle image specifically within a table cell paragraph\nprivate fun handleImageInCell(element: Element, paragraph: XWPFParagraph, context: Context) {\n    try {\n        val src \u003d element.attr(\&quot;src\&quot;)\n\n        if (src.startsWith(\&quot;data:image\&quot;)) {\n            val parts \u003d src.split(\&quot;,\&quot;)\n            if (parts.size \u003d\u003d 2) {\n                val meta \u003d parts[0]\n                val base64Data \u003d parts[1]\n                val decodedData \u003d Base64.decode(base64Data, Base64.DEFAULT)\n\n                val pictureType \u003d when {\n                    meta.contains(\&quot;jpeg\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_JPEG\n                    meta.contains(\&quot;png\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                    meta.contains(\&quot;gif\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_GIF\n                    meta.contains(\&quot;bmp\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_BMP\n                    meta.contains(\&quot;tiff\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_TIFF\n                    else -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                }\n\n                val widthPx \u003d element.attr(\&quot;width\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 200\n                val heightPx \u003d element.attr(\&quot;height\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 150\n                val widthEmu \u003d widthPx * Units.EMU_PER_PIXEL\n                val heightEmu \u003d heightPx * Units.EMU_PER_PIXEL\n\n                paragraph.createRun().addPicture(\n                    ByteArrayInputStream(decodedData),\n                    pictureType,\n                    \&quot;image.dat\&quot;,\n                    widthEmu,\n                    heightEmu\n                )\n            }\n        }\n    } catch (e: Exception) {\n        Logger.e(\&quot;Error processing image in cell: ${e.message}\&quot;, e)\n    }\n}\n\n// Handle inline formatting\nprivate fun handleInlineFormatting(\n    element: Element,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph {\n    val paragraph \u003d currentParagraph ?: document.createParagraph()\n\n    for (child in element.childNodes()) {\n        when (child) {\n            is TextNode -\u003e {\n                val run \u003d paragraph.createRun()\n                run.setText(child.text())\n                applyRunFormatting(run, element)\n            }\n            is Element -\u003e {\n                parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n            }\n        }\n    }\n\n    // Apply formatting to runs that were just created\n    val tagName \u003d element.tagName().lowercase()\n    if (tagName in listOf(\&quot;span\&quot;, \&quot;strong\&quot;, \&quot;b\&quot;, \&quot;em\&quot;, \&quot;i\&quot;, \&quot;u\&quot;, \&quot;s\&quot;, \&quot;strike\&quot;, \&quot;del\&quot;, \&quot;sub\&quot;, \&quot;sup\&quot;, \&quot;code\&quot;, \&quot;mark\&quot;)) {\n        // Get recently created runs for this element\n        val recentRunCount \u003d element.childNodes().filterIsInstance\u003cTextNode\u003e().size\n        if (recentRunCount \u003e 0 \u0026\u0026 paragraph.runs.size \u003e\u003d recentRunCount) {\n            val runsToFormat \u003d paragraph.runs.takeLast(recentRunCount)\n            runsToFormat.forEach { run -\u003e\n                applyRunFormatting(run, element)\n            }\n        }\n    }\n\n    return paragraph\n}\n\n// Apply run formatting\nprivate fun applyRunFormatting(run: XWPFRun, element: Element) {\n    val tagName \u003d element.tagName().lowercase()\n    val style \u003d element.attr(\&quot;style\&quot;)\n\n    when (tagName) {\n        \&quot;strong\&quot;, \&quot;b\&quot; -\u003e run.isBold \u003d true\n        \&quot;em\&quot;, \&quot;i\&quot; -\u003e run.isItalic \u003d true\n        \&quot;u\&quot; -\u003e run.underline \u003d UnderlinePatterns.SINGLE\n        \&quot;s\&quot;, \&quot;strike\&quot;, \&quot;del\&quot; -\u003e run.isStrikeThrough \u003d true\n//        \&quot;sub\&quot; -\u003e run.subscript \u003d VerticalAlign.SUBSCRIPT\n//        \&quot;sup\&quot; -\u003e run.subscript \u003d VerticalAlign.SUPERSCRIPT\n        \&quot;code\&quot; -\u003e {\n            run.fontFamily \u003d \&quot;Courier New\&quot;\n            if (run.fontSize \u003c\u003d 0) run.fontSize \u003d 10\n        }\n        \&quot;mark\&quot; -\u003e {\n            try {\n                run.setTextHighlightColor(\&quot;yellow\&quot;)\n            } catch (e: Exception) {\n                Logger.w(\&quot;Failed to set highlight: ${e.message}\&quot;)\n            }\n        }\n    }\n\n    // Parse inline styles\n    if (style.isNotBlank()) {\n        applyInlineStyle(run, style)\n    }\n\n    // Apply color attribute\n    val color \u003d element.attr(\&quot;color\&quot;)\n    if (color.isNotBlank()) {\n        run.color \u003d color.replace(\&quot;#\&quot;, \&quot;\&quot;)\n    }\n}\n\n// Apply inline CSS styles\nprivate fun applyInlineStyle(run: XWPFRun, style: String) {\n    val styles \u003d style.split(\&quot;;\&quot;).associate {\n        val parts \u003d it.split(\&quot;:\&quot;)\n        if (parts.size \u003d\u003d 2) {\n            parts[0].trim().lowercase() to parts[1].trim()\n        } else {\n            \&quot;\&quot; to \&quot;\&quot;\n        }\n    }\n\n    styles[\&quot;font-weight\&quot;]?.let {\n        if (it.contains(\&quot;bold\&quot;, ignoreCase \u003d true) || it.toIntOrNull()?.let { w -\u003e w \u003e\u003d 600 } \u003d\u003d true) {\n            run.isBold \u003d true\n        }\n    }\n\n    styles[\&quot;font-style\&quot;]?.let {\n        if (it.contains(\&quot;italic\&quot;, ignoreCase \u003d true)) {\n            run.isItalic \u003d true\n        }\n    }\n\n    styles[\&quot;text-decoration\&quot;]?.let {\n        when {\n            it.contains(\&quot;underline\&quot;, ignoreCase \u003d true) -\u003e run.underline \u003d UnderlinePatterns.SINGLE\n            it.contains(\&quot;line-through\&quot;, ignoreCase \u003d true) -\u003e run.isStrikeThrough \u003d true\n        }\n    }\n\n    styles[\&quot;font-size\&quot;]?.let {\n        val size \u003d when {\n            it.endsWith(\&quot;pt\&quot;) -\u003e it.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.toInt()\n            it.endsWith(\&quot;px\&quot;) -\u003e (it.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(0.75))?.toInt()\n            else -\u003e null\n        }\n        size?.let { s -\u003e run.fontSize \u003d s }\n    }\n\n    styles[\&quot;font-family\&quot;]?.let {\n        run.fontFamily \u003d it.replace(\&quot;\u0027\&quot;, \&quot;\&quot;).replace(\&quot;\\\&quot;\&quot;, \&quot;\&quot;).split(\&quot;,\&quot;)[0].trim()\n    }\n\n    styles[\&quot;color\&quot;]?.let {\n        val colorValue \u003d it.replace(\&quot;#\&quot;, \&quot;\&quot;).trim()\n        if (colorValue.length \u003d\u003d 6 || colorValue.length \u003d\u003d 3) {\n            run.color \u003d colorValue\n        }\n    }\n}\n\n// Handle image\nprivate fun handleImage(element: Element, document: XWPFDocument, context: Context) {\n    try {\n        val src \u003d element.attr(\&quot;src\&quot;)\n\n        if (src.startsWith(\&quot;data:image\&quot;)) {\n            val parts \u003d src.split(\&quot;,\&quot;)\n            if (parts.size \u003d\u003d 2) {\n                val meta \u003d parts[0]\n                val base64Data \u003d parts[1]\n                val decodedData \u003d Base64.decode(base64Data, Base64.DEFAULT)\n\n                val pictureType \u003d when {\n                    meta.contains(\&quot;jpeg\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_JPEG\n                    meta.contains(\&quot;png\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                    meta.contains(\&quot;gif\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_GIF\n                    meta.contains(\&quot;bmp\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_BMP\n                    meta.contains(\&quot;tiff\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_TIFF\n                    else -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                }\n\n                val widthPx \u003d element.attr(\&quot;width\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 200\n                val heightPx \u003d element.attr(\&quot;height\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 150\n                val widthEmu \u003d widthPx * Units.EMU_PER_PIXEL\n                val heightEmu \u003d heightPx * Units.EMU_PER_PIXEL\n\n                val imageParagraph \u003d document.createParagraph()\n                imageParagraph.createRun().addPicture(\n                    ByteArrayInputStream(decodedData),\n                    pictureType,\n                    \&quot;image.dat\&quot;,\n                    widthEmu,\n                    heightEmu\n                )\n            }\n        }\n    } catch (e: Exception) {\n        Logger.e(\&quot;Error processing image: ${e.message}\&quot;, e)\n    }\n}\n\n// Handle blockquote\nprivate fun handleBlockquote(\n    element: Element,\n    document: XWPFDocument,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph? {\n    var lastParagraph: XWPFParagraph? \u003d null\n\n    for (child in element.childNodes()) {\n        lastParagraph \u003d parseEnhancedJsoupNode(child, document, lastParagraph, context, docContext)\n        lastParagraph?.let { para -\u003e\n            para.indentationLeft \u003d 720 // Indent blockquote\n            para.borderLeft \u003d Borders.SINGLE\n        }\n    }\n\n    return lastParagraph\n}\n\n// Handle horizontal rule\nprivate fun handleHorizontalRule(document: XWPFDocument): XWPFParagraph {\n    val paragraph \u003d document.createParagraph()\n    paragraph.borderBottom \u003d Borders.SINGLE\n    return paragraph\n}\n\n// Apply paragraph style from HTML element\nprivate fun applyParagraphStyle(paragraph: XWPFParagraph, element: Element) {\n    val style \u003d element.attr(\&quot;style\&quot;)\n\n    if (style.isNotBlank()) {\n        val styles \u003d style.split(\&quot;;\&quot;).associate {\n            val parts \u003d it.split(\&quot;:\&quot;)\n            if (parts.size \u003d\u003d 2) {\n                parts[0].trim().lowercase() to parts[1].trim()\n            } else {\n                \&quot;\&quot; to \&quot;\&quot;\n            }\n        }\n\n        styles[\&quot;text-align\&quot;]?.let {\n            paragraph.alignment \u003d when (it.lowercase()) {\n                \&quot;center\&quot; -\u003e ParagraphAlignment.CENTER\n                \&quot;right\&quot; -\u003e ParagraphAlignment.RIGHT\n                \&quot;justify\&quot; -\u003e ParagraphAlignment.BOTH\n                \&quot;left\&quot; -\u003e ParagraphAlignment.LEFT\n                else -\u003e paragraph.alignment\n            }\n        }\n\n        styles[\&quot;margin-top\&quot;]?.let {\n            val spacing \u003d when {\n                it.endsWith(\&quot;pt\&quot;) -\u003e it.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20)?.toInt()\n                it.endsWith(\&quot;px\&quot;) -\u003e it.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(15)?.toInt()\n                else -\u003e null\n            }\n            spacing?.let { s -\u003e paragraph.spacingBefore \u003d s }\n        }\n\n        styles[\&quot;margin-bottom\&quot;]?.let {\n            val spacing \u003d when {\n                it.endsWith(\&quot;pt\&quot;) -\u003e it.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20)?.toInt()\n                it.endsWith(\&quot;px\&quot;) -\u003e it.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(15)?.toInt()\n                else -\u003e null\n            }\n            spacing?.let { s -\u003e paragraph.spacingAfter \u003d s }\n        }\n\n        styles[\&quot;line-height\&quot;]?.let {\n            val lineHeightValue \u003d it.toDoubleOrNull()\n            lineHeightValue?.let { lh -\u003e\n                paragraph.setSpacingBetween(lh * 240, LineSpacingRule.AUTO)\n            }\n        }\n    }\n\n    // Apply alignment from attribute\n    val align \u003d element.attr(\&quot;align\&quot;)\n    if (align.isNotBlank()) {\n        paragraph.alignment \u003d when (align.lowercase()) {\n            \&quot;center\&quot; -\u003e ParagraphAlignment.CENTER\n            \&quot;right\&quot; -\u003e ParagraphAlignment.RIGHT\n            \&quot;justify\&quot; -\u003e ParagraphAlignment.BOTH\n            \&quot;left\&quot; -\u003e ParagraphAlignment.LEFT\n            else -\u003e paragraph.alignment\n        }\n    }\n}\n\n// Apply cell style\nprivate fun applyCellStyle(cell: XWPFTableCell, element: Element) {\n    try {\n        // Background color\n        val bgColor \u003d element.attr(\&quot;bgcolor\&quot;)\n        if (bgColor.isNotBlank()) {\n            cell.color \u003d bgColor.replace(\&quot;#\&quot;, \&quot;\&quot;)\n        }\n\n        // Parse style attribute for background color\n        val style \u003d element.attr(\&quot;style\&quot;)\n        if (style.contains(\&quot;background-color\&quot;)) {\n            val bgMatch \u003d Regex(\&quot;background-color:\\\\s*#?([0-9A-Fa-f]{6})\&quot;).find(style)\n            bgMatch?.let {\n                cell.color \u003d it.groupValues[1]\n            }\n        }\n\n        // Set cell margins\n        val ctTc \u003d cell.ctTc\n        val tcPr \u003d ctTc.tcPr ?: ctTc.addNewTcPr()\n        val tcMar \u003d tcPr.tcMar ?: tcPr.addNewTcMar()\n\n        tcMar.left \u003d CTTblWidth.Factory.newInstance().apply {\n            w \u003d BigInteger.valueOf(100)\n            type \u003d STTblWidth.DXA\n        }\n        tcMar.right \u003d CTTblWidth.Factory.newInstance().apply {\n            w \u003d BigInteger.valueOf(100)\n            type \u003d STTblWidth.DXA\n        }\n    } catch (e: Exception) {\n        Logger.w(\&quot;Failed to apply cell style: ${e.message}\&quot;)\n    }\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// LEGACY FUNCTIONS (Keep for backward compatibility)\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nprivate fun parseJsoupNode(\n    jsoupNode: Node,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    context: Context\n) {\n    // Use enhanced parser\n    val docContext \u003d DocumentContext()\n    parseEnhancedJsoupNode(jsoupNode, document, currentParagraph, context, docContext)\n}\n\nprivate fun applyParagraphAlignment(element: Element, paragraph: XWPFParagraph?) {\n    if (paragraph \u003d\u003d null) return\n    applyParagraphStyle(paragraph, element)\n}\n\nfun parseStyleAndApply(styleAttribute: String, paragraph: XWPFParagraph?, run: XWPFRun?) {\n    if (run \u003d\u003d null \u0026\u0026 paragraph \u003d\u003d null) return\n\n    styleAttribute.split(\u0027;\u0027).map { it.trim() }.filter { it.isNotEmpty() }.forEach { style -\u003e\n        val parts \u003d style.split(\u0027:\u0027).map { it.trim() }\n        if (parts.size \u003d\u003d 2) {\n            val property \u003d parts[0].lowercase()\n            val value \u003d parts[1]\n            try {\n                when (property) {\n                    // Run-specific styles\n                    \&quot;color\&quot; -\u003e if (value.startsWith(\&quot;#\&quot;) \u0026\u0026 (value.length \u003d\u003d 7 || value.length \u003d\u003d 4)) {\n                        run?.setColor(value.removePrefix(\&quot;#\&quot;))\n                    }\n                    \&quot;font-weight\&quot; -\u003e if (value \u003d\u003d \&quot;bold\&quot; || (value.toIntOrNull() ?: 400) \u003e\u003d 600) {\n                        run?.isBold \u003d true\n                    }\n                    \&quot;font-style\&quot; -\u003e if (value \u003d\u003d \&quot;italic\&quot;) {\n                        run?.isItalic \u003d true\n                    }\n                    \&quot;font-size\&quot; -\u003e {\n                        val size \u003d when {\n                            value.endsWith(\&quot;pt\&quot;) -\u003e value.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.toInt()\n                            value.endsWith(\&quot;px\&quot;) -\u003e (value.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(0.75))?.toInt()\n                            else -\u003e null\n                        }\n                        if (size !\u003d null) run?.fontSize \u003d size\n                    }\n                    \&quot;font-family\&quot; -\u003e run?.fontFamily \u003d value.replace(\&quot;\\\u0027\&quot;, \&quot;\&quot;).split(\&quot;,\&quot;)[0].trim()\n                    \&quot;text-decoration\&quot;, \&quot;text-decoration-line\&quot; -\u003e {\n                        if (value.contains(\&quot;underline\&quot;)) run?.underline \u003d UnderlinePatterns.SINGLE\n                        if (value.contains(\&quot;line-through\&quot;)) run?.isStrikeThrough \u003d true\n                    }\n                    // Paragraph-specific styles\n                    \&quot;margin-top\&quot; -\u003e {\n                        if (paragraph !\u003d null \u0026\u0026 value.endsWith(\&quot;pt\&quot;)) {\n                            paragraph.spacingBefore \u003d (value.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20))?.toInt() ?: paragraph.spacingBefore\n                        }\n                    }\n                    \&quot;margin-bottom\&quot; -\u003e {\n                        if (paragraph !\u003d null \u0026\u0026 value.endsWith(\&quot;pt\&quot;)) {\n                            paragraph.spacingAfter \u003d (value.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20))?.toInt() ?: paragraph.spacingAfter\n                        }\n                    }\n                    \&quot;line-height\&quot; -\u003e {\n                        if (paragraph !\u003d null) {\n                            val lineHeightValue \u003d value.toDoubleOrNull()\n                            if (lineHeightValue !\u003d null) {\n                                paragraph.setSpacingBetween(lineHeightValue * 240, LineSpacingRule.AUTO)\n                            }\n                        }\n                    }\n                }\n            } catch (e: Exception) {\n                Logger.w(\&quot;Failed to parse style: $property \u003d $value. Error: ${e.message}\&quot;)\n            }\n        }\n    }\n}&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Now I see the file fully. Let me compile and test your app to see the current status:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01EvTMjZKDFQ5MfqYYpsy2TA&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;run_terminal_cmd&quot;,&quot;arguments&quot;:&quot;{\&quot;command\&quot;: \&quot;cd AndroidStudioProjects/Docx \u0026\u0026 ./gradlew build\&quot;, \&quot;explanation\&quot;: \&quot;Compiling the project to check for build errors and ensure the current state is working\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;run_terminal_cmd&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01EvTMjZKDFQ5MfqYYpsy2TA&quot;,&quot;content&quot;:&quot;Command output:\n\n```\ncd AndroidStudioProjects/Docx \u0026\u0026 ./gradlew build\nroidStudioProjects/Docx \u0026\u0026 ./gradlew build\ncd: no such file or directory: AndroidStudioProjects/Docx\n(base) yuvrajdube@yuvrajs-MacBook-Air Docx %\n```\n\nThe previous shell command ended, so on the next invocation of this tool, you will be reusing the shell.\n\nOn the next terminal tool call, the directory of the shell will already be /Users/yuvrajdube/AndroidStudioProjects/Docx.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_015tB3oopEHFmmMVoZ9vpaU4&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;run_terminal_cmd&quot;,&quot;arguments&quot;:&quot;{\&quot;command\&quot;: \&quot;pwd \u0026\u0026 ls -la\&quot;, \&quot;explanation\&quot;: \&quot;Checking the current directory and listing files to understand the project structure\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;run_terminal_cmd&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_015tB3oopEHFmmMVoZ9vpaU4&quot;,&quot;content&quot;:&quot;Command output:\n\n```\n\npwd \u0026\u0026 ls -la                                      \n ls -la\n/Users/yuvrajdube/AndroidStudioProjects/Docx\ntotal 64\ndrwxr-xr-x@ 14 yuvrajdube  staff   448 Sep 26 10:57 .\ndrwxr-xr-x  45 yuvrajdube  staff  1440 Sep 29 17:12 ..\n-rw-r--r--@  1 yuvrajdube  staff   225 Sep 24 10:56 .gitignore\ndrwxr-xr-x@  8 yuvrajdube  staff   256 Oct  1 14:56 .gradle\ndrwxr-xr-x@ 17 yuvrajdube  staff   544 Oct  1 14:31 .idea\ndrwxr-xr-x@  4 yuvrajdube  staff   128 Sep 24 13:23 .kotlin\ndrwxr-xr-x@  7 yuvrajdube  staff   224 Oct  1 12:02 app\n-rw-r--r--@  1 yuvrajdube  staff   269 Sep 25 14:05 build.gradle.kts\ndrwxr-xr-x@  4 yuvrajdube  staff   128 Sep 30 11:49 gradle\n-rw-r--r--@  1 yuvrajdube  staff  1346 Sep 24 10:56 gradle.properties\n-rwxr--r--@  1 yuvrajdube  staff  5766 Sep 24 10:56 gradlew\n-rw-r--r--@  1 yuvrajdube  staff  2763 Sep 24 10:56 gradlew.bat\n-rw-r--r--@  1 yuvrajdube  staff   439 Sep 24 10:56 local.properties\n-rw-r--r--@  1 yuvrajdube  staff   529 Sep 26 11:35 settings.gradle.kts\n(base) yuvrajdube@yuvrajs-MacBook-Air Docx %\n```\n\nThe previous shell command ended, so on the next invocation of this tool, you will be reusing the shell.\n\nOn the next terminal tool call, the directory of the shell will already be /Users/yuvrajdube/AndroidStudioProjects/Docx.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Perfect! Now let me run a build to check the current status:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_016drqda4qL4qxRu2VLEoHJn&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;run_terminal_cmd&quot;,&quot;arguments&quot;:&quot;{\&quot;command\&quot;: \&quot;./gradlew assembleDebug\&quot;, \&quot;explanation\&quot;: \&quot;Building the debug version to check for compilation errors\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;run_terminal_cmd&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_016drqda4qL4qxRu2VLEoHJn&quot;,&quot;content&quot;:&quot;Command output:\n\n```\n\nlew assembleDebug\nWARNING: A restricted method in java.lang.System has been called\nWARNING: java.lang.System::load has been called by net.rubygrapefruit.platform.internal.NativeLibraryLoader in an unnamed module (file:/Users/yuvrajdube/.gradle/wrapper/dists/gradle-8.13-bin/5xuhj0ry160q40clulazy9h7d/gradle-8.13/lib/native-platform-0.22-milestone-28.jar)\nWARNING: Use --enable-native-access\u003dALL-UNNAMED to avoid a warning for callers in this module\nWARNING: Restricted methods will be blocked in a future release unless native access is enabled\n\nStarting a Gradle Daemon, 1 incompatible and 1 stopped Daemons could not be reused, use --status for details\n\n\u003e Task :app:compileDebugKotlin FAILED\ne: file:///Users/yuvrajdube/AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt:578:39 \u0027val\u0027 cannot be reassigned.\n\nFAILURE: Build failed with an exception.\n\n* What went wrong:\nExecution failed for task \u0027:app:compileDebugKotlin\u0027.\n\u003e A failure occurred while executing org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction\n   \u003e Compilation error. See log for more details\n\n* Try:\n\u003e Run with --stacktrace option to get the stack trace.\n\u003e Run with --info or --debug option to get more log output.\n\u003e Run with --scan to get full insights.\n\u003e Get more help at https://help.gradle.org.\n\nBUILD FAILED in 10s\n30 actionable tasks: 5 executed, 25 up-to-date\n(base) yuvrajdube@yuvrajs-MacBook-Air Docx %\n```\n\nThe previous shell command ended, so on the next invocation of this tool, you will be reusing the shell.\n\nOn the next terminal tool call, the directory of the shell will already be /Users/yuvrajdube/AndroidStudioProjects/Docx.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Now I can see the exact error is at line 578. Let me look at the current writeHtmlToDocx function and find line 578:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01DkqY959TFqAAwKTessrJfN&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;grep_search&quot;,&quot;arguments&quot;:&quot;{\&quot;query\&quot;: \&quot;cleaned \u003d cleaned\&quot;, \&quot;include_pattern\&quot;: \&quot;EditDocxScreen.kt\&quot;, \&quot;explanation\&quot;: \&quot;Looking for the specific line where a val is being reassigned, likely in the cleanHtmlContent function\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;grep_search&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01DkqY959TFqAAwKTessrJfN&quot;,&quot;content&quot;:&quot;File: AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\n\tLine 673: cleaned \u003d cleaned.substring(1, cleaned.length - 1)\n\tLine 676: cleaned \u003d cleaned\n\tLine 687: cleaned \u003d cleaned.replace(Regex(\&quot;\u003cscript[^\u003e]*\u003e.*?\u003c/script\u003e\&quot;, RegexOption.DOT_MAT\n\tLine 690: cleaned \u003d cleaned.replace(Regex(\&quot;\u003cstyle[^\u003e]*\u003e.*?\u003c/style\u003e\&quot;, RegexOption.DOT_MATCH\n\tLine 693: cleaned \u003d cleaned.replace(Regex(\&quot;\u003cdiv[^\u003e]*class\u003d[\u0027\\\&quot;]page[\u0027\\\&quot;][^\u003e]*\u003e\&quot;), \&quot;\u003cdiv\u003e\&quot;)&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;I found the issue! The problem is that `cleaned` is declared as `val` but I\u0027m trying to reassign it. Let me fix this:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01HLFq4DaWq1q62G7gDZoKti&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;edit_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\&quot;, \&quot;instructions\&quot;: \&quot;I will change the cleaned variable from val to var to allow reassignment, fixing the compilation error.\&quot;, \&quot;code_edit\&quot;: \&quot;// Clean HTML content\\nprivate fun cleanHtmlContent(htmlContent: String): String {\\n    var cleaned \u003d htmlContent\\n\\n    // Remove JSON escaping if present\\n    if (cleaned.startsWith(\\\&quot;\\\\\\\&quot;\\\&quot;) \u0026\u0026 cleaned.endsWith(\\\&quot;\\\\\\\&quot;\\\&quot;)) {\\n        cleaned \u003d cleaned.substring(1, cleaned.length - 1)\\n    }\\n\\n    cleaned \u003d cleaned\\n        .replace(\\\&quot;\\\\\\\\u003C\\\&quot;, \\\&quot;\u003c\\\&quot;)\\n        .replace(\\\&quot;\\\\\\\\u003E\\\&quot;, \\\&quot;\u003e\\\&quot;)\\n        .replace(\\\&quot;\\\\\\\\\\\\\\\&quot;\\\&quot;, \\\&quot;\\\\\\\&quot;\\\&quot;)\\n        .replace(\\\&quot;\\\\\\\\n\\\&quot;, \\\&quot;\\\\n\\\&quot;)\\n        .replace(\\\&quot;\\\\\\\\t\\\&quot;, \\\&quot;\\\\t\\\&quot;)\\n        .replace(\\\&quot;\\\\\\\\r\\\&quot;, \\\&quot;\\\\r\\\&quot;)\\n        .replace(\\\&quot;\u0026nbsp;\\\&quot;, \\\&quot; \\\&quot;)\\n        .replace(\\\&quot;\\\\\\\\\\\\\\\\\\\&quot;, \\\&quot;\\\\\\\\\\\&quot;)\\n\\n    // Remove script tags and their content\\n    cleaned \u003d cleaned.replace(Regex(\\\&quot;\u003cscript[^\u003e]*\u003e.*?\u003c/script\u003e\\\&quot;, RegexOption.DOT_MATCHES_ALL), \\\&quot;\\\&quot;)\\n\\n    // Remove style tags but keep the content structure\\n    cleaned \u003d cleaned.replace(Regex(\\\&quot;\u003cstyle[^\u003e]*\u003e.*?\u003c/style\u003e\\\&quot;, RegexOption.DOT_MATCHES_ALL), \\\&quot;\\\&quot;)\\n\\n    // Clean up page containers but preserve content\\n    cleaned \u003d cleaned.replace(Regex(\\\&quot;\u003cdiv[^\u003e]*class\u003d[\u0027\\\\\\\&quot;]page[\u0027\\\\\\\&quot;][^\u003e]*\u003e\\\&quot;), \\\&quot;\u003cdiv\u003e\\\&quot;)\\n\\n    return cleaned\\n}\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;edit_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01HLFq4DaWq1q62G7gDZoKti&quot;,&quot;content&quot;:&quot;The apply model made NO changes to the file. Try retrying with more clear instructions.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Let me try a more specific edit by finding the exact function:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01Px7gQjgZZsScmnwGRHy3Tw&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;grep_search&quot;,&quot;arguments&quot;:&quot;{\&quot;query\&quot;: \&quot;private fun cleanHtmlContent\&quot;, \&quot;include_pattern\&quot;: \&quot;EditDocxScreen.kt\&quot;, \&quot;explanation\&quot;: \&quot;Finding the exact location of the cleanHtmlContent function to fix the val/var issue\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;grep_search&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01Px7gQjgZZsScmnwGRHy3Tw&quot;,&quot;content&quot;:&quot;File: AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\n\tLine 668: private fun cleanHtmlContent(htmlContent: String): String {&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01UTTtZ7vYsHeVcJDFLAhUQF&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;edit_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\&quot;, \&quot;instructions\&quot;: \&quot;I will change line where \u0027val cleaned \u003d htmlContent\u0027 is declared to \u0027var cleaned \u003d htmlContent\u0027 to fix the reassignment error.\&quot;, \&quot;code_edit\&quot;: \&quot;private fun cleanHtmlContent(htmlContent: String): String {\\n    var cleaned \u003d htmlContent\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;edit_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01UTTtZ7vYsHeVcJDFLAhUQF&quot;,&quot;content&quot;:&quot;The apply model made NO changes to the file. Try retrying with more clear instructions.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Let me check the exact content around line 668-675:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_012rmbF6AezgJPMW9sBAmnSv&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;grep_search&quot;,&quot;arguments&quot;:&quot;{\&quot;query\&quot;: \&quot;var cleaned.*htmlContent|val cleaned.*htmlContent\&quot;, \&quot;include_pattern\&quot;: \&quot;EditDocxScreen.kt\&quot;, \&quot;explanation\&quot;: \&quot;Finding where the cleaned variable is declared to fix the val to var issue\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;grep_search&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_012rmbF6AezgJPMW9sBAmnSv&quot;,&quot;content&quot;:&quot;File: AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\n\tLine 669: var cleaned \u003d htmlContent&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;It seems the variable is already declared as `var`. Let me check the compilation again to see if there are other issues:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_0186NkVXrYWUCbJsuKYRK2Ux&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;run_terminal_cmd&quot;,&quot;arguments&quot;:&quot;{\&quot;command\&quot;: \&quot;./gradlew assembleDebug\&quot;, \&quot;explanation\&quot;: \&quot;Trying to build again to see the current compilation errors\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;run_terminal_cmd&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_0186NkVXrYWUCbJsuKYRK2Ux&quot;,&quot;content&quot;:&quot;Command output:\n\n```\n\nlew assembleDebug\nWARNING: A restricted method in java.lang.System has been called\nWARNING: java.lang.System::load has been called by net.rubygrapefruit.platform.internal.NativeLibraryLoader in an unnamed module (file:/Users/yuvrajdube/.gradle/wrapper/dists/gradle-8.13-bin/5xuhj0ry160q40clulazy9h7d/gradle-8.13/lib/native-platform-0.22-milestone-28.jar)\nWARNING: Use --enable-native-access\u003dALL-UNNAMED to avoid a warning for callers in this module\nWARNING: Restricted methods will be blocked in a future release unless native access is enabled\n\n\n\u003e Task :app:compileDebugKotlin FAILED\ne: file:///Users/yuvrajdube/AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt:578:39 \u0027val\u0027 cannot be reassigned.\n\nFAILURE: Build failed with an exception.\n\n* What went wrong:\nExecution failed for task \u0027:app:compileDebugKotlin\u0027.\n\u003e A failure occurred while executing org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction\n   \u003e Compilation error. See log for more details\n\n* Try:\n\u003e Run with --stacktrace option to get the stack trace.\n\u003e Run with --info or --debug option to get more log output.\n\u003e Run with --scan to get full insights.\n\u003e Get more help at https://help.gradle.org.\n\nBUILD FAILED in 3s\n30 actionable tasks: 1 executed, 29 up-to-date\n(base) yuvrajdube@yuvrajs-MacBook-Air Docx %\n```\n\nThe previous shell command ended, so on the next invocation of this tool, you will be reusing the shell.\n\nOn the next terminal tool call, the directory of the shell will already be /Users/yuvrajdube/AndroidStudioProjects/Docx.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Still the same error at line 578. Let me find exactly what\u0027s on that line:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01Fh4viTaKdJFDcYqsuxzDjR&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;run_terminal_cmd&quot;,&quot;arguments&quot;:&quot;{\&quot;command\&quot;: \&quot;sed -n \u0027570,585p\u0027 app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\&quot;, \&quot;explanation\&quot;: \&quot;Getting the exact lines around 578 to see what\u0027s causing the val reassignment error\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;run_terminal_cmd&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01Fh4viTaKdJFDcYqsuxzDjR&quot;,&quot;content&quot;:&quot;Command output:\n\n```\n\nsed -n \u0027570,585p\u0027 app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\nditDocxScreen.kt\n\n                    // Copy document properties\n                    try {\n                        val coreProps \u003d doc.properties?.coreProperties\n                        coreProps?.let { props -\u003e\n                            val newProps \u003d newDoc.properties?.coreProperties\n                            newProps?.creator \u003d props.creator\n                            newProps?.title \u003d props.title\n                            newProps?.subject \u003d props.subject\n                            newProps?.description \u003d props.description\n                            newProps?.category \u003d props.category\n                            newProps?.keywords \u003d props.keywords\n                        }\n                    } catch (e: Exception) {\n                        Logger.w(\&quot;Could not copy document properties: ${e.message}\&quot;)\n                    }\n(base) yuvrajdube@yuvrajs-MacBook-Air Docx %\n```\n\nThe previous shell command ended, so on the next invocation of this tool, you will be reusing the shell.\n\nOn the next terminal tool call, the directory of the shell will already be /Users/yuvrajdube/AndroidStudioProjects/Docx.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;I can see the issue now. The problem is that we\u0027re trying to assign to properties of `newProps` but `newProps` is declared as `val`. The issue is with the line `newProps?.creator \u003d props.creator` etc. Let me fix this:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_017vu1Cm7g45o5DYqdmEMebP&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;edit_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\&quot;, \&quot;instructions\&quot;: \&quot;I will fix the document properties copying code by using proper assignment methods or wrapping in try-catch blocks to handle the properties that may not be assignable.\&quot;, \&quot;code_edit\&quot;: \&quot;                    // Copy document properties\\n                    try {\\n                        val coreProps \u003d doc.properties?.coreProperties\\n                        coreProps?.let { props -\u003e\\n                            val newProps \u003d newDoc.properties?.coreProperties\\n                            try {\\n                                newProps?.creator \u003d props.creator\\n                                newProps?.title \u003d props.title\\n                                newProps?.subject \u003d props.subject\\n                                newProps?.description \u003d props.description\\n                                newProps?.category \u003d props.category\\n                                newProps?.keywords \u003d props.keywords\\n                            } catch (propertyException: Exception) {\\n                                Logger.w(\\\&quot;Could not copy some document properties: ${propertyException.message}\\\&quot;)\\n                            }\\n                        }\\n                    } catch (e: Exception) {\\n                        Logger.w(\\\&quot;Could not copy document properties: ${e.message}\\\&quot;)\\n                    }\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;edit_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_017vu1Cm7g45o5DYqdmEMebP&quot;,&quot;content&quot;:&quot;The apply model made the following changes to the file:\n\n```\n@@ -574,10 +574,14 @@\n                         coreProps?.let { props -\u003e\n                             val newProps \u003d newDoc.properties?.coreProperties\n-                            newProps?.creator \u003d props.creator\n-                            newProps?.title \u003d props.title\n-                            newProps?.subject \u003d props.subject\n-                            newProps?.description \u003d props.description\n-                            newProps?.category \u003d props.category\n-                            newProps?.keywords \u003d props.keywords\n+                            try {\n+                                newProps?.creator \u003d props.creator\n+                                newProps?.title \u003d props.title\n+                                newProps?.subject \u003d props.subject\n+                                newProps?.description \u003d props.description\n+                                newProps?.category \u003d props.category\n+                                newProps?.keywords \u003d props.keywords\n+                            } catch (propertyException: Exception) {\n+                                Logger.w(\&quot;Could not copy some document properties: ${propertyException.message}\&quot;)\n+                            }\n                         }\n                     } catch (e: Exception) {\n```\n\nThe edit introduced the following new linter errors:\n\n```\nLine 579: \u0027val\u0027 cannot be reassigned.\n```\n\nPlease fix the linter errors if it is clear how to. Do not make uneducated guesses.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;The issue is that the properties are likely read-only. Let me remove the property copying entirely for now to fix the compilation error:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01ExHCKpEjgYZYASdU5o6jo3&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;edit_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\&quot;, \&quot;instructions\&quot;: \&quot;I will remove the document properties copying code that\u0027s causing the compilation error, since these properties appear to be read-only.\&quot;, \&quot;code_edit\&quot;: \&quot;                    // Copy document properties\\n                    try {\\n                        // Document properties are often read-only, so we skip copying them\\n                        Logger.d(\\\&quot;Skipping document properties copying - not supported\\\&quot;)\\n                    } catch (e: Exception) {\\n                        Logger.w(\\\&quot;Could not copy document properties: ${e.message}\\\&quot;)\\n                    }\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;edit_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01ExHCKpEjgYZYASdU5o6jo3&quot;,&quot;content&quot;:&quot;The apply model made the following changes to the file:\n\n```\n@@ -571,18 +571,6 @@\n                     // Copy document properties\n                     try {\n-                        val coreProps \u003d doc.properties?.coreProperties\n-                        coreProps?.let { props -\u003e\n-                            val newProps \u003d newDoc.properties?.coreProperties\n-                            try {\n-                                newProps?.creator \u003d props.creator\n-                                newProps?.title \u003d props.title\n-                                newProps?.subject \u003d props.subject\n-                                newProps?.description \u003d props.description\n-                                newProps?.category \u003d props.category\n-                                newProps?.keywords \u003d props.keywords\n-                            } catch (propertyException: Exception) {\n-                                Logger.w(\&quot;Could not copy some document properties: ${propertyException.message}\&quot;)\n-                            }\n-                        }\n+                        // Document properties are often read-only, so we skip copying them\n+                        Logger.d(\&quot;Skipping document properties copying - not supported\&quot;)\n                     } catch (e: Exception) {\n                         Logger.w(\&quot;Could not copy document properties: ${e.message}\&quot;)\n```\n\nThe edit was successful with no linter errors.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Now let\u0027s try building again:&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01QbiLLiH9SvxPEqSYr7PAG5&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;run_terminal_cmd&quot;,&quot;arguments&quot;:&quot;{\&quot;command\&quot;: \&quot;./gradlew assembleDebug\&quot;, \&quot;explanation\&quot;: \&quot;Building the project again to check if the compilation errors are fixed\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;run_terminal_cmd&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01QbiLLiH9SvxPEqSYr7PAG5&quot;,&quot;content&quot;:&quot;Command output:\n\n```\n\nlew assembleDebug\nWARNING: A restricted method in java.lang.System has been called\nWARNING: java.lang.System::load has been called by net.rubygrapefruit.platform.internal.NativeLibraryLoader in an unnamed module (file:/Users/yuvrajdube/.gradle/wrapper/dists/gradle-8.13-bin/5xuhj0ry160q40clulazy9h7d/gradle-8.13/lib/native-platform-0.22-milestone-28.jar)\nWARNING: Use --enable-native-access\u003dALL-UNNAMED to avoid a warning for callers in this module\nWARNING: Restricted methods will be blocked in a future release unless native access is enabled\n\n\n\u003e Task :app:compileDebugKotlin\nw: file:///Users/yuvrajdube/AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/CreateNewDocxScreen.kt:372:37 \u0027fun Modifier.menuAnchor(): Modifier\u0027 is deprecated. Use overload that takes MenuAnchorType and enabled parameters.\nw: file:///Users/yuvrajdube/AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt:244:37 \u0027fun Modifier.menuAnchor(): Modifier\u0027 is deprecated. Use overload that takes MenuAnchorType and enabled parameters.\nw: file:///Users/yuvrajdube/AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt:880:17 \u0027var fontSize: Int\u0027 is deprecated. Deprecated in Java.\nw: file:///Users/yuvrajdube/AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt:1251:21 \u0027var fontSize: Int\u0027 is deprecated. Deprecated in Java.\nw: file:///Users/yuvrajdube/AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/util/DocxUtil.kt:253:17 \u0027var fontSize: Int\u0027 is deprecated. Deprecated in Java.\nw: file:///Users/yuvrajdube/AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/util/DocxUtil.kt:253:66 \u0027var fontSize: Int\u0027 is deprecated. Deprecated in Java.\n\nBUILD SUCCESSFUL in 8s\n36 actionable tasks: 5 executed, 31 up-to-date\n(base) yuvrajdube@yuvrajs-MacBook-Air Docx %\n```\n\nThe previous shell command ended, so on the next invocation of this tool, you will be reusing the shell.\n\nOn the next terminal tool call, the directory of the shell will already be /Users/yuvrajdube/AndroidStudioProjects/Docx.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Excellent! The build is now successful. Now let me provide you with a summary of the fixes I made to resolve the DOCX parsing error issue:\n\n## Summary of Fixes Applied\n\nThe main issue was that your app was corrupting DOCX files during the editing process, making them unreadable by other applications. Here are the key problems I fixed:\n\n### 1. **Improved Document Structure Preservation**\n- **Problem**: The original code wasn\u0027t preserving the proper DOCX document structure when saving\n- **Fix**: Added code to attempt to read and preserve the original document structure before writing new content\n\n### 2. **Enhanced HTML Cleaning Process**\n- **Problem**: HTML content from the WebView contained script tags, style tags, and other elements that corrupted the DOCX structure\n- **Fix**: Improved the `cleanHtmlContent()` function to:\n  - Remove script tags completely\n  - Remove style tags while preserving content structure  \n  - Clean up page containers properly\n  - Handle JSON escaping correctly\n\n### 3. **Proper Document Writing Process**\n- **Problem**: The original code wrote directly to the file without validation\n- **Fix**: Implemented a two-step writing process:\n  - First write to a temporary buffer to validate the document\n  - Only write to the actual file if validation succeeds\n  - Proper error handling and document cleanup\n\n### 4. **Document Defaults and Validation**\n- **Problem**: Missing essential document properties could cause parsing errors\n- **Fix**: Added proper document defaults including:\n  - A4 page size settings\n  - Standard margins\n  - Proper section properties\n  - Ensuring minimum required content (at least one paragraph)\n\n### 5. **Better Content Clearing**\n- **Problem**: When clearing existing content, the document structure was being damaged\n- **Fix**: Implemented `clearDocumentContent()` that safely removes content while preserving the document structure\n\n### 6. **Fixed Compilation Errors**\n- **Problem**: Read-only properties were being assigned causing compilation failures\n- **Fix**: Removed problematic property copying code and focused on content preservation\n\n## What This Means for Your App\n\nWith these fixes, your edited DOCX files should now:\n\n1.  **Open correctly in other applications** (Microsoft Word, Google Docs, etc.)\n2.  **Maintain proper DOCX structure** and formatting\n3.  **Preserve document integrity** after editing\n4.  **Handle complex content** like tables, images, and formatting correctly\n\n## Testing the Fix\n\nTo verify the fix works:\n\n1. **Build and install** your app with the updated code\n2. **Open a DOCX file** in your app\n3. **Make some edits** (add text, format, etc.)\n4. **Save the document**\n5. **Try opening the saved file** in Microsoft Word, Google Docs, or any other DOCX reader\n\nThe file should now open without any parsing errors!\n\nThe core issue was that the HTML-to-DOCX conversion process wasn\u0027t maintaining the proper DOCX file structure, which is quite strict. By preserving the document structure, cleaning the HTML properly, and using a validated writing process, your edited DOCX files should now be fully compatible with other applications.&quot;}]},{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\u003cuser_query\u003e\nnow change the view formatting of edit and create screen same as viewdocxscreen without changing the feature or other thing just change the webview formatting make it same as ViewDocxScreen\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;thinking&quot;,&quot;thinking&quot;:&quot;gAAAAABo31wpXBJXyGyLyGaxOt03WAhwC1PjXEKe_ergdOLbbcAeWu9-W-1DEDrnhIntyRsr5fXLy8LsE5gNigSefdN7vKBsQTM9JvhJlKfdrrqW9rVuIYbRq5ASmUn000YfN3zYSVbzhGFPQHxd5eZ603CuUk0jGdU9d-LeCBWBpFt1KM43koyurXSFZxbDngcqVbuvkLeseFf0k4qHKMMX_wPNS507GlbQWTBJCo4SuydJQViLaQtEAPCmBxfoX5HVvZlWPdCbEWP4WeJDA7eB01h_aLp-_cEFaStZeczV2TLs8wTf8Oxnu4v12AdHg45uJdj82uyBQxhg27AUXuVKuf-XK7wSwqMlGDtBde4sIlx6zVrcPM2YdqCAlXvl01z9qMhIzxQANHnkbabwPbWab-gfn0GFyOR7Lxp_AIB5GxfOivrMylL2k5OTmh6KoW6vEf3i7s9iU7MoIvNowLb-_U1_j1ossChkPSRhNCOgqrJbm-KJcuFN7h9KJXJuMebN6E2g7-yzrbAG6ZLC7e8oRXaZWGu63_miaAlct9ppdfRAQY4uXdglwNBL9GfuP6f0uxFxrY7jtnQToM4rKZ_nMBL9I8zj47n52QqX1R7qzM1Syc1WjrbvkHHf7gdIyW1fOi6HadIpG3dmHTqend_l3H00sPHBk1JW_S3ooP6deg88J20XJKSllJjmB-qBBvwQKyArip_kg6kwmR6f_frTxoQWYL6YN_Cr-_Kh8_wWnhPK5Ut1_alIYcjbP-9vzn2kNvYkojm4euIU_cS_0rvE4MSWL1qu1I7bbJMrmT0Es0LjPsvDatuiPcFYgDAaeVmcfSEh2xUwrTL5q0rG0ccCHiywl4iAiU7F_EcXRstW-d8UnYIrkyiRejMLehrCp9PHDGS-l8E6BdPQXrPinFuvrO_T7mRFQXqNPzPekLlxX6lpQIAQJVDpsbZmDHB9R2WbuIz_rWbBJsjrllbGx15_Z0N9PEFJR4PlqkN-fBn23-e31RqnRdnrK_y9rk4Kpsm7JWaEXfHYxKzlI5BtBJU3vbBaeFOzyhW_CrPMsTbozIBudZb1RaFIzMMQRpPdhGgItDCEG1DlsF0ZZ2bgZqZJP4QrnwdkGGdlPyibPwL7MnnqGozExJ8xe7HVHkgZXwyd-CS8_HYgP9ZB0CVkMuICLKOK7cP5eGuh2-dtqfOexhXsa8ylkU1XSy7vk19ZUAiVTyVXtvW4Bga0op8biCL1zUPao2MKDjXlVqIeHRVnyw4Ia47Cb-Bsr6YZ9vdEt0OApfjSEx3KBIcfO1wpwCuE49CmyZq2dhBLBXDRbWXF0iTJHMLCPCjZVVQlJnf_ZPHtcN9yFoE9TVIAiFTUf1qoqF6hdL9WCnROCy8XPglN4BH0ApRlL8Po9FZTFEZIdZLqZhKB7XqCRUgwVGr21_h-Djv6VtgxEulHqlnwaLX0TL7QmZwtu4rhEGi2VzyU2JGSXr9Fr1D2WpGAXMAT9o4oeQxfuPNIhmBwiS2vchNOxt7SWbtw6SPfqwm_1aDePSsrmScJpStOxw7365WFo1R8dsR8qpieI1thytEktUtky2g4pZuvhf2mopExc3XTx_tzaHYHre4Zovagneg8FkBSvlQzc3rydJ9F6ffwR8PWRDVjFk9b9OJY8T_gq5Qu9XAwvRLLdG26etlwIOJD4T7W8CetlSY4QIXh1wLFpK2If2sg_OMnh-1unMaiW9DDSeIfvw_VsyWgSEt3iWtj9yMrtJGqTlDtxODHNKVTYLtgFEVqiDDA9M9dIN8ubNb7OFA6wQDxyl4lUXuZHQs9YTi9rhfTKzR96gcDr9hYVPtqZtv2NfJ91NIM4e_iMcDgh_I1chm4znkWZj8Z5U-5LWOYanGmFZscYI8YGjIx1zspVScA5WtT6q3U2vGu73VUay0jnD9hkYYHfDdBUCMor16mLDWZB2-akDV6JaGL-s5WNReM1M3bJZRuv8bFQT0yEIcy5mTRa6kT317DpB-udRW1Up5QoOEuxnzM5LxabB9aPoRoqLybhOk0yJsH69mpJ-GljAHOb5wlQn45athMD2NPJobzCT1cwS4SB2r0m2iLNQoAIy4j-yc6oP-cwtLX8c9fePc1UAE9_lxvFoQh5vx3sNtcWbQiNp0lJsmQA9YyWEqI7InD2kL7MY5Vd0ZMjH35hdxPwMNCBlU8h9-BDijs_J7l-zibyOtLlyUlGCcddM0lertukCP8xP-xTR0i8j1not3kkIVDzigRmf3_OJznkYHfYe12HNH6YTEo9sJZ0cTnRcy_fZ0Bw1ugRp03_FyDpHvPWKQCiU31KVJbhu5ceQds9PKal-1KxBdwnh-N_i08y8ckQ_SFzRX2L3vx7np_BFGfp9dQX5jksLswbl84L0oHkMRitaCpSOBzo3WNeEyHLn9IGz7IJlmkFikbzmajuigm4U252fcbsq9Lf0o0UjZw7YCeHSQCt7G-4-HXdpaQKn6LOaD7A9AO3QzRWeX6KlwtYEYyyeViZEaJmXfl4fQi7bId6vG-y7q3Lj8pElDcdIfVLnD-G9KqnF6ZiOadGzN6gVPnu9iiGGJFFbArwbb1M2H22I6Yyx_XSkZe3BHRn4Os15z140Ja8UEg1WUZcnmMjhtZ6WnLzYZk-SsZPK2FxNcys2a_XpDZw1sB6qoYn_dQ092lFg5l4ncDn1Ayc0ZMKMuPFeYSKk1wn5Pwf34eiQxefbMDqTRYmdsrysA4d5_CfjQW9I40ZZhEDx7kHRPHYnwsZxJFSATj6rfq0Jczw7OVXuqK5-GgvUPfZeld_jDEkKt2fvtfv4o3Ytsu02Gx8rUlwQELMZGghnSa-wnVJM4yG5hdeUxk3Tgy7bYOzdUFnR8lZyd8KB0f0hSU1f7vERNgFEStw6maHV20r3Oh4U-RwzTyh76ZSqc1N14Ke_Ez1ZQTrwP-3QYPYD_xIbYxsqTR88dlLqf1ask_BDCoAmIWLTzneZP50Ntp7lu_3YE3FrMD8B7tGcwY0n1zpZAF-t19Ls7QyXGY7jpmlIDz1YPS3pgTcYjNurgrBL_mPp1RlaHJGk9eUBwXzI3Des36zFCe1MG99Rp1n4VrvcFt40qukfWq6XCcxaz9Fh5Fgrz8Z1nF4WYfcHWZlx-ukrtvlA_-grrCm0Idc8igE8b_NMV_0w\u003d\u003d&quot;,&quot;signature&quot;:&quot;rs_0683101154fa635a0168df5c2539f081a1b6f92a1dae7a190a&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;I\u0027ll scan the edit and create screens to find where they build the WebView HTML and update their CSS/JS to match `ViewDocxScreen`, keeping features intact. Then I\u0027ll implement the changes in both files.&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;call_kDnxBfMNuU5tgfsF6Sh1ebXy&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;read_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;:\&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/CreateNewDocxScreen.kt\&quot;}&quot;}},{&quot;id&quot;:&quot;call_5sKJrGOWmb4opThGRI4JImlF&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;read_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;:\&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;read_file&quot;,&quot;tool_call_id&quot;:&quot;call_kDnxBfMNuU5tgfsF6Sh1ebXy&quot;,&quot;content&quot;:&quot;package com.example.docx.ui\n\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.net.Uri\nimport android.util.Base64\nimport android.webkit.WebView\nimport androidx.activity.compose.rememberLauncherForActivityResult\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\n//import androidx.compose.material.icons.filled.FormatItalic // Ensured active import\n//import androidx.compose.material.icons.filled.FormatUnderlined // Ensured active import\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.ColorFilter\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.viewinterop.AndroidView\nimport androidx.navigation.NavController\nimport com.example.docx.R // For custom drawable R.drawable.bold\nimport com.example.docx.util.Logger\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport org.apache.poi.common.usermodel.PictureType\nimport org.apache.poi.util.Units\nimport org.apache.poi.xwpf.usermodel.*\nimport org.openxmlformats.schemas.officeDocument.x2006.sharedTypes.STVerticalAlignRun as OfficeSTVerticalAlignRun\nimport org.jsoup.Jsoup\nimport org.jsoup.nodes.Element\nimport org.jsoup.nodes.Node\nimport org.jsoup.nodes.TextNode\nimport java.io.ByteArrayInputStream\nimport java.io.IOException\n\n@OptIn(ExperimentalMaterial3Api::class)\n@SuppressLint(\&quot;SetJavaScriptEnabled\&quot;)\n@Composable\nfun CreateNewDocxScreen(navController: NavController) {\n    var documentHtml by remember {\n        mutableStateOf(\n            \&quot;\&quot;\&quot;\n        \u003c!DOCTYPE html\u003e\n        \u003chtml\u003e\n        \u003chead\u003e\n            \u003cmeta charset\u003d\&quot;UTF-8\&quot;\u003e\n            \u003cmeta name\u003d\&quot;viewport\&quot; content\u003d\&quot;width\u003ddevice-width, initial-scale\u003d1.0\&quot;\u003e\n            \u003cstyle\u003e\n                body { \n                    font-family: Arial, sans-serif; \n                    font-size: 12pt; \n                    margin: 0; \n                    padding: 20px; \n                    background: #f0f0f0; \n                    word-wrap: break-word; \n                }\n                .page { \n                    background: white; \n                    width: 21cm; \n                    min-height: 29.7cm; \n                    margin: 0 auto 20px auto; \n                    padding: 2.54cm; \n                    box-shadow: 0 4px 8px rgba(0,0,0,0.1); \n                    position: relative; \n                    page-break-after: always; \n                    overflow: hidden;\n                }\n                .page:last-child { page-break-after: auto; }\n                .page-number {\n                    position: absolute; \n                    bottom: 1.27cm; \n                    right: 2.54cm; \n                    font-size: 10pt; \n                    color: #666; \n                    pointer-events: none;\n                }\n                p { margin-bottom: 0.5em; }\n                table { border-collapse: collapse; width: 100%; margin-bottom: 1em; table-layout: fixed; }\n                td, th { border: 1px solid #BFBFBF; padding: 6px 8px; vertical-align: top; text-align: left; word-wrap: break-word; font-size: 10pt; }\n                img { max-width: 100%; height: auto; display: block; margin: 0.2em 0; }\n                ul, ol { margin: 0.5em 0; padding-left: 2em; }\n                li { margin-bottom: 0.25em; }\n                h1, h2, h3, h4, h5, h6 { margin-top: 1em; margin-bottom: 0.5em; }\n            \u003c/style\u003e\n            \u003cscript\u003e\n                let pageCounter \u003d 1;\n                let isProcessing \u003d false;\n                \n                function createNewPage() {\n                    pageCounter++;\n                    const newPage \u003d document.createElement(\u0027div\u0027);\n                    newPage.className \u003d \u0027page\u0027;\n                    newPage.id \u003d \u0027page\u0027 + pageCounter;\n                    newPage.innerHTML \u003d \u0027\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u0027;\n                    \n                    // Add page number\n                    const pageNum \u003d document.createElement(\u0027div\u0027);\n                    pageNum.className \u003d \u0027page-number\u0027;\n                    pageNum.style.cssText \u003d \u0027position: absolute; bottom: 1.27cm; right: 2.54cm; font-size: 10pt; color: #666; pointer-events: none;\u0027;\n                    pageNum.textContent \u003d pageCounter;\n                    newPage.appendChild(pageNum);\n                    \n                    document.body.appendChild(newPage);\n                    return newPage;\n                }\n                \n                function updatePageNumbers() {\n                    const pages \u003d document.querySelectorAll(\u0027.page\u0027);\n                    pages.forEach((page, index) \u003d\u003e {\n                        let pageNum \u003d page.querySelector(\u0027.page-number\u0027);\n                        if (!pageNum) {\n                            pageNum \u003d document.createElement(\u0027div\u0027);\n                            pageNum.className \u003d \u0027page-number\u0027;\n                            pageNum.style.cssText \u003d \u0027position: absolute; bottom: 1.27cm; right: 2.54cm; font-size: 10pt; color: #666; pointer-events: none;\u0027;\n                            page.appendChild(pageNum);\n                        }\n                        pageNum.textContent \u003d index + 1;\n                    });\n                }\n                \n                function checkPageOverflow() {\n                    if (isProcessing) return;\n                    isProcessing \u003d true;\n                    \n                    const pages \u003d document.querySelectorAll(\u0027.page\u0027);\n                    const pageHeight \u003d 29.7 * 37.795; // A4 height in pixels\n                    \n                    pages.forEach((page, index) \u003d\u003e {\n                        const contentHeight \u003d page.scrollHeight;\n                        if (contentHeight \u003e pageHeight) {\n                            // Create new page if it doesn\u0027t exist\n                            let nextPage \u003d document.getElementById(\u0027page\u0027 + (index + 2));\n                            if (!nextPage) {\n                                nextPage \u003d createNewPage();\n                            }\n                            \n                            // Move overflow content to next page\n                            const elements \u003d Array.from(page.children);\n                            let totalHeight \u003d 0;\n                            let moveIndex \u003d -1;\n                            \n                            for (let i \u003d 0; i \u003c elements.length; i++) {\n                                const elem \u003d elements[i];\n                                if (elem.className \u003d\u003d\u003d \u0027page-number\u0027) continue;\n                                \n                                const elemHeight \u003d elem.offsetHeight;\n                                if (totalHeight + elemHeight \u003e pageHeight - 100) { // Leave some margin\n                                    moveIndex \u003d i;\n                                    break;\n                                }\n                                totalHeight +\u003d elemHeight;\n                            }\n                            \n                            if (moveIndex !\u003d\u003d -1) {\n                                for (let i \u003d moveIndex; i \u003c elements.length; i++) {\n                                    const elem \u003d elements[i];\n                                    if (elem.className !\u003d\u003d \u0027page-number\u0027) {\n                                        nextPage.insertBefore(elem, nextPage.querySelector(\u0027.page-number\u0027));\n                                    }\n                                }\n                            }\n                        }\n                    });\n                    \n                    updatePageNumbers();\n                    isProcessing \u003d false;\n                }\n                \n                function ensureMinimumOnePage() {\n                    if (document.querySelectorAll(\u0027.page\u0027).length \u003d\u003d\u003d 0) {\n                        const firstPage \u003d document.createElement(\u0027div\u0027);\n                        firstPage.className \u003d \u0027page\u0027;\n                        firstPage.id \u003d \u0027page1\u0027;\n                        firstPage.innerHTML \u003d \u0027\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u0027;\n                        document.body.appendChild(firstPage);\n                    }\n                    updatePageNumbers();\n                }\n                \n                document.addEventListener(\u0027DOMContentLoaded\u0027, function() {\n                    ensureMinimumOnePage();\n                    setTimeout(checkPageOverflow, 500);\n                });\n                \n                document.addEventListener(\u0027input\u0027, function() {\n                    setTimeout(checkPageOverflow, 300);\n                });\n                \n                document.addEventListener(\u0027keydown\u0027, function(e) {\n                    if (e.ctrlKey \u0026\u0026 e.key \u003d\u003d\u003d \u0027Enter\u0027) {\n                        e.preventDefault();\n                        createNewPage();\n                        updatePageNumbers();\n                    }\n                });\n                \n                // Periodic check for content changes\n                setInterval(checkPageOverflow, 2000);\n            \u003c/script\u003e\n        \u003c/head\u003e\n        \u003cbody\u003e\n            \u003cdiv class\u003d\&quot;page\&quot; id\u003d\&quot;page1\&quot;\u003e\n                \u003cp\u003e\u003cbr\u003e\u003c/p\u003e\n            \u003c/div\u003e\n        \u003c/body\u003e\n        \u003c/html\u003e\n    \&quot;\&quot;\&quot;.trimIndent()\n        )\n    }\n    var isSaving by remember { mutableStateOf(false) }\n    val context \u003d LocalContext.current\n    val scope \u003d rememberCoroutineScope()\n    var errorMessage by remember { mutableStateOf\u003cString?\u003e(null) }\n    var showErrorDialog by remember { mutableStateOf(false) }\n    val webView \u003d remember { WebView(context) }\n\n    val createDocumentLauncher \u003d rememberLauncherForActivityResult(\n        contract \u003d ActivityResultContracts.CreateDocument(\&quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document\&quot;),\n        onResult \u003d { newFileUri: Uri? -\u003e\n            if (newFileUri !\u003d null) {\n                webView.evaluateJavascript(\n                    \&quot;(function() { return document.documentElement.outerHTML; })();\&quot;\n                ) { htmlContent -\u003e\n                    scope.launch {\n                        isSaving \u003d true\n                        val result \u003d writeHtmlToDoc(context, newFileUri, htmlContent ?: \&quot;\u003chtml\u003e\u003cbody\u003e\u003cp\u003e\u003c/p\u003e\u003c/body\u003e\u003c/html\u003e\&quot;) // Corrected name\n                        result.fold(\n                            onSuccess \u003d {\n                                Logger.i(\&quot;Document saved successfully to $newFileUri from CreateNewDocxScreen\&quot;)\n                                navController.popBackStack()\n                            },\n                            onFailure \u003d { error -\u003e\n                                errorMessage \u003d \&quot;Save failed: ${error.message}\&quot;\n                                showErrorDialog \u003d true\n                            }\n                        )\n                        if (!showErrorDialog) isSaving \u003d false\n                    }\n                }\n            } else {\n                isSaving \u003d false\n                Logger.d(\&quot;Save As action cancelled by user in CreateNewDocxScreen.\&quot;)\n            }\n        }\n    )\n\n    if (showErrorDialog) {\n        AlertDialog(\n            onDismissRequest \u003d { \n                showErrorDialog \u003d false \n                isSaving \u003d false\n            },\n            title \u003d { Text(\&quot;Error\&quot;) },\n            text \u003d { Text(errorMessage ?: \&quot;An unknown error occurred.\&quot;) },\n            confirmButton \u003d {\n                TextButton(onClick \u003d { \n                    showErrorDialog \u003d false \n                    isSaving \u003d false\n                }) { Text(\&quot;OK\&quot;) }\n            }\n        )\n    }\n\n    Scaffold(\n        topBar \u003d {\n            TopAppBar(\n                title \u003d { Text(\&quot;Create New Document\&quot;) },\n                navigationIcon \u003d {\n                    IconButton(onClick \u003d { navController.popBackStack() }, enabled \u003d !isSaving) {\n                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription \u003d \&quot;Back\&quot;)\n                    }\n                },\n                actions \u003d {\n                    TextButton(\n                        onClick \u003d {\n                            isSaving \u003d true\n                            createDocumentLauncher.launch(\&quot;Untitled.docx\&quot;)\n                        },\n                        enabled \u003d !isSaving\n                    ) {\n                        Text(if (isSaving) \&quot;Saving...\&quot; else \&quot;Save\&quot;)\n                    }\n                }\n            )\n        }\n    ) { paddingValues -\u003e\n        Column(\n            modifier \u003d Modifier\n                .fillMaxSize()\n                .padding(paddingValues)\n        ) {\n            FormattingToolbartop(webView \u003d webView)\n            Box(modifier \u003d Modifier.weight(1f)) {\n                AndroidView(\n                    factory \u003d { webViewContext -\u003e\n                        webView.apply {\n                            settings.javaScriptEnabled \u003d true\n                            settings.domStorageEnabled \u003d true\n                            settings.allowFileAccess \u003d true\n                            settings.defaultTextEncodingName \u003d \&quot;utf-8\&quot;\n                            settings.builtInZoomControls \u003d true\n                            settings.displayZoomControls \u003d false\n                            settings.setSupportZoom(true)\n\n                            webViewClient \u003d object : android.webkit.WebViewClient() {\n                                override fun onPageFinished(view: WebView?, url: String?) {\n                                    evaluateJavascript(\&quot;document.body.contentEditable \u003d true;\&quot;) {}\n                                }\n                            }\n                            loadDataWithBaseURL(null, documentHtml, \&quot;text/html\&quot;, \&quot;utf-8\&quot;, null)\n                        }\n                    },\n                    modifier \u003d Modifier\n                        .fillMaxSize()\n                        .padding(horizontal \u003d 16.dp),\n                    update \u003d { /* No specific update logic needed here for now */ }\n                )\n                if (isSaving) {\n                    Surface(modifier \u003d Modifier.fillMaxSize(), color \u003d MaterialTheme.colorScheme.surface.copy(alpha \u003d 0.8f)) {\n                        Column(\n                            modifier \u003d Modifier.fillMaxSize(),\n                            horizontalAlignment \u003d Alignment.CenterHorizontally,\n                            verticalArrangement \u003d Arrangement.Center\n                        ) {\n                            CircularProgressIndicator()\n                            Spacer(modifier \u003d Modifier.height(16.dp))\n                            Text(\&quot;Preparing to save...\&quot;)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun FormattingToolbartop(webView: WebView) {\n    val fonts \u003d listOf(\&quot;Arial\&quot;, \&quot;Calibri\&quot;, \&quot;Courier New\&quot;, \&quot;Georgia\&quot;, \&quot;Times New Roman\&quot;, \&quot;Verdana\&quot;)\n    var selectedFont by remember { mutableStateOf(fonts[0]) }\n    var isFontDropdownExpanded by remember { mutableStateOf(false) }\n\n    var isBoldSelected by remember { mutableStateOf(false) }\n    var isItalicSelected by remember { mutableStateOf(false) }\n    var isUnderlineSelected by remember { mutableStateOf(false) }\n\n    Row(\n        modifier \u003d Modifier\n            .fillMaxWidth()\n            .padding(horizontal \u003d 8.dp, vertical \u003d 4.dp),\n        verticalAlignment \u003d Alignment.CenterVertically,\n        horizontalArrangement \u003d Arrangement.spacedBy(8.dp)\n    ) {\n        ExposedDropdownMenuBox(\n            expanded \u003d isFontDropdownExpanded,\n            onExpandedChange \u003d { isFontDropdownExpanded \u003d !isFontDropdownExpanded },\n            modifier \u003d Modifier.weight(1f)\n        ) {\n            OutlinedTextField(\n                value \u003d selectedFont,\n                onValueChange \u003d {}, \n                readOnly \u003d true,\n                label \u003d { Text(\&quot;Font\&quot;) },\n                trailingIcon \u003d { ExposedDropdownMenuDefaults.TrailingIcon(expanded \u003d isFontDropdownExpanded) },\n                modifier \u003d Modifier.menuAnchor()\n            )\n            ExposedDropdownMenu(\n                expanded \u003d isFontDropdownExpanded,\n                onDismissRequest \u003d { isFontDropdownExpanded \u003d false }\n            ) {\n                fonts.forEach { fontName -\u003e\n                    DropdownMenuItem(\n                        text \u003d { Text(fontName) },\n                        onClick \u003d {\n                            selectedFont \u003d fontName\n                            isFontDropdownExpanded \u003d false\n                            webView.evaluateJavascript(\&quot;document.execCommand(\u0027fontName\u0027, false, \u0027$fontName\u0027);\&quot;, null)\n                        }\n                    )\n                }\n            }\n        }\n\n        IconButton(onClick \u003d {\n            isBoldSelected \u003d !isBoldSelected\n            webView.evaluateJavascript(\&quot;document.execCommand(\u0027bold\u0027);\&quot;, null)\n        }) {\n            Image(\n                painter \u003d painterResource(id \u003d R.drawable.bold),\n                contentDescription \u003d \&quot;Bold\&quot;,\n                colorFilter \u003d if (isBoldSelected) ColorFilter.tint(MaterialTheme.colorScheme.primary) else null\n            )\n        }\n\n        IconButton(onClick \u003d {\n            isItalicSelected \u003d !isItalicSelected\n            webView.evaluateJavascript(\&quot;document.execCommand(\u0027italic\u0027);\&quot;, null)\n        }) {\n            Icon(\n                painter \u003d painterResource(R.drawable.bold), // Corrected icon\n                contentDescription \u003d \&quot;Italic\&quot;,\n                tint \u003d if (isItalicSelected) MaterialTheme.colorScheme.primary else Color.Unspecified\n            )\n        }\n\n        IconButton(onClick \u003d {\n            isUnderlineSelected \u003d !isUnderlineSelected\n            webView.evaluateJavascript(\&quot;document.execCommand(\u0027underline\u0027);\&quot;, null)\n        }) {\n            Icon(\n                painter \u003d painterResource(R.drawable.bold), // Corrected icon\n                contentDescription \u003d \&quot;Underline\&quot;,\n                tint \u003d if (isUnderlineSelected) MaterialTheme.colorScheme.primary else Color.Unspecified\n            )\n        }\n    }\n}\n\n// DOCX -\u003e HTML conversion functions (These are defined but not actively used for DOCX loading in this screen)\nfun convertParagraphToHtml(paragraph: XWPFParagraph): String {\n    val style \u003d buildString {\n        if (paragraph.spacingBefore \u003e 0) append(\&quot;margin-top: ${paragraph.spacingBefore / 20.0}pt; \&quot;)\n        if (paragraph.spacingAfter \u003e 0) append(\&quot;margin-bottom: ${paragraph.spacingAfter / 20.0}pt; \&quot;)\n        if (paragraph.spacingLineRule \u003d\u003d LineSpacingRule.AUTO \u0026\u0026 paragraph.spacingBetween \u003e 0) {\n            append(\&quot;line-height: ${paragraph.spacingBetween / 240.0}; \&quot;)\n        }\n        if (paragraph.alignment !\u003d ParagraphAlignment.LEFT) {\n            append(\&quot;text-align: ${paragraph.alignment.name.lowercase()}; \&quot;)\n        }\n    }\n    val pTag \u003d StringBuilder()\n    pTag.append(\&quot;\u003cp style\u003d\u0027${style}\u0027\u003e\&quot;)\n    var contentAdded \u003d false\n    for (run in paragraph.runs) {\n        val runHtml \u003d convertRunToHtml(run)\n        if (runHtml.isNotBlank()) {\n            pTag.append(runHtml)\n            contentAdded \u003d true\n        }\n    }\n    if (!contentAdded \u0026\u0026 paragraph.text.isBlank()) {\n        pTag.append(\&quot;\u0026nbsp;\&quot;)\n    }\n    pTag.append(\&quot;\u003c/p\u003e\&quot;)\n    return pTag.toString()\n}\n\nfun convertRunToHtml(run: XWPFRun): String {\n    val style \u003d buildString {\n        val fontSizeInPoints: Double? \u003d run.getFontSizeAsDouble()\n        if (fontSizeInPoints !\u003d null \u0026\u0026 fontSizeInPoints \u003e 0) {\n            append(\&quot;font-size: ${fontSizeInPoints}pt; \&quot;)\n        }\n        if (!run.fontFamily.isNullOrEmpty()) append(\&quot;font-family: \u0027${run.fontFamily}\u0027; \&quot;)\n        if (run.color !\u003d null \u0026\u0026 run.color !\u003d \&quot;auto\&quot;) append(\&quot;color: #${run.color}; \&quot;)\n        if (run.isBold) append(\&quot;font-weight: bold; \&quot;)\n        if (run.isItalic) append(\&quot;font-style: italic; \&quot;)\n        if (run.isStrikeThrough) append(\&quot;text-decoration: line-through; \&quot;)\n        if (run.underline !\u003d UnderlinePatterns.NONE \u0026\u0026 run.underline !\u003d null) append(\&quot;text-decoration: underline; \&quot;)\n    }\n    var text \u003d run.text() ?: \&quot;\&quot;\n    text \u003d text.replace(\&quot;\u0026\&quot;, \&quot;\u0026amp;\&quot;)\n        .replace(\&quot;\u003c\&quot;, \&quot;\u0026lt;\&quot;)\n        .replace(\&quot;\u003e\&quot;, \&quot;\u0026gt;\&quot;)\n        .replace(\&quot;\\\&quot;\&quot;, \&quot;\u0026quot;\&quot;)\n        .replace(\&quot;\\t\&quot;, \&quot;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\&quot;)\n        .replace(\&quot;\\n\&quot;, \&quot;\u003cbr\u003e\&quot;)\n    var html \u003d \&quot;\u003cspan style\u003d\u0027${style}\u0027\u003e$text\u003c/span\u003e\&quot;\n    when (run.getVerticalAlignment()) {\n        OfficeSTVerticalAlignRun.SUBSCRIPT -\u003e html \u003d \&quot;\u003csub\u003e$html\u003c/sub\u003e\&quot;\n        OfficeSTVerticalAlignRun.SUPERSCRIPT -\u003e html \u003d \&quot;\u003csup\u003e$html\u003c/sup\u003e\&quot;\n        else -\u003e {}\n    }\n    for (pic in run.embeddedPictures) {\n        try {\n            val picData \u003d pic.pictureData\n            val ext \u003d when (picData.pictureTypeEnum) {\n                PictureType.JPEG -\u003e \&quot;jpeg\&quot;\n                PictureType.PNG -\u003e \&quot;png\&quot;\n                PictureType.GIF -\u003e \&quot;gif\&quot;\n                PictureType.BMP -\u003e \&quot;bmp\&quot;\n                PictureType.WMF -\u003e \&quot;wmf\&quot;\n                PictureType.EMF -\u003e \&quot;emf\&quot;\n                PictureType.PICT -\u003e \&quot;pict\&quot;\n                PictureType.TIFF -\u003e \&quot;tiff\&quot;\n                else -\u003e \&quot;png\&quot;\n            }\n            val base64 \u003d Base64.encodeToString(picData.data, Base64.DEFAULT)\n            val xfrm \u003d pic.ctPicture?.spPr?.xfrm\n            var imgWidth \u003d \&quot;auto\&quot;\n            var imgHeight \u003d \&quot;auto\&quot;\n            if (xfrm?.ext !\u003d null) {\n                 val widthEmu \u003d xfrm.ext.cx\n                 val heightEmu \u003d xfrm.ext.cy\n                 imgWidth \u003d \&quot;${widthEmu / Units.EMU_PER_PIXEL}px\&quot;\n                 imgHeight \u003d \&quot;${heightEmu / Units.EMU_PER_PIXEL}px\&quot;\n            }\n            html +\u003d \&quot;\u003cimg src\u003d\u0027data:image/$ext;base64,$base64\u0027 width\u003d\u0027$imgWidth\u0027 height\u003d\u0027$imgHeight\u0027 alt\u003d\u0027${pic.description ?: \&quot;Embedded image\&quot;}\u0027 /\u003e\&quot;\n        } catch (e: Exception) {\n            Logger.e(\&quot;Error processing embedded picture in CreateNewDocxScreen: ${e.message}\&quot;, e)\n            html +\u003d \&quot;\u003c!-- Error loading image: ${e.message} --\u003e\&quot;\n        }\n    }\n    return html\n}\n\nfun convertTableToHtml(table: XWPFTable): String {\n    val html \u003d StringBuilder(\&quot;\u003ctable\u003e\&quot;)\n    for (row in table.rows) {\n        html.append(\&quot;\u003ctr\u003e\&quot;)\n        for (cell in row.tableCells) {\n            html.append(\&quot;\u003ctd\u003e\&quot;)\n            cell.bodyElements.forEach { element -\u003e\n                when (element) {\n                    is XWPFParagraph -\u003e html.append(convertParagraphToHtml(element))\n                    is XWPFTable -\u003e html.append(convertTableToHtml(element))\n                }\n            }\n            html.append(\&quot;\u003c/td\u003e\&quot;)\n        }\n        html.append(\&quot;\u003c/tr\u003e\&quot;)\n    }\n    html.append(\&quot;\u003c/table\u003e\&quot;)\n    return html.toString()\n}\n\n// HTML -\u003e DOCX CONVERSION\nsuspend fun writeHtmlToDoc(context: Context, uri: Uri, htmlContent: String): Result\u003cUnit\u003e {\n    Logger.d(\&quot;Starting writeHtmlToDoc for $uri in CreateNewDocxScreen\&quot;)\n    return withContext(Dispatchers.IO) {\n        runCatching {\n            val rawHtml \u003d htmlContent.let {\n                var h \u003d it\n                if (h.startsWith(\&quot;\\\&quot;\&quot;) \u0026\u0026 h.endsWith(\&quot;\\\&quot;\&quot;)) {\n                    h \u003d h.substring(1, h.length - 1)\n                }\n                h.replace(\&quot;\\\\u003C\&quot;, \&quot;\u003c\&quot;)\n                 .replace(\&quot;\\\\\\\&quot;\&quot;, \&quot;\\\&quot;\&quot;)\n                 .replace(\&quot;\\\\n\&quot;, \&quot;\\n\&quot;)\n            }\n            Logger.d(\&quot;Cleaned HTML (first 500 chars) in CreateNewDocxScreen: ${rawHtml.take(500)}\&quot;)\n            val jsoupDoc: org.jsoup.nodes.Document \u003d Jsoup.parse(rawHtml)\n\n            context.contentResolver.openOutputStream(uri)?.use { outputStream -\u003e\n                val document \u003d XWPFDocument()\n                // Set A4 page size and margins\n                setA4PageSize(document)\n                val body \u003d jsoupDoc.body()\n                parseJsoupNode(body, document, null, context)\n\n                if (document.paragraphs.isNotEmpty() \u0026\u0026 document.paragraphs[0].text.isBlank() \u0026\u0026 document.paragraphs[0].runs.isEmpty()) {\n                    if(document.bodyElements.size \u003e 0) document.removeBodyElement(0)\n                }\n                document.write(outputStream)\n                document.close()\n                Logger.i(\&quot;DOCX saved successfully to $uri from CreateNewDocxScreen\&quot;)\n            } ?: throw IOException(\&quot;Unable to open output stream for $uri\&quot;)\n        }.onFailure { e -\u003e\n            Logger.e(\&quot;Error in writeHtmlToDoc in CreateNewDocxScreen: ${e.message}\&quot;, e)\n        }\n    }\n}\n\n// Set A4 page size and margins\nprivate fun setA4PageSize(document: XWPFDocument) {\n    try {\n        val ctDocument \u003d document.document\n        val ctBody \u003d ctDocument.body\n\n        val sectPr \u003d if (ctBody.isSetSectPr) ctBody.sectPr else ctBody.addNewSectPr()\n\n        // Set page size to A4 (210mm x 297mm \u003d 11906 twips x 16838 twips)\n        val pgSz \u003d if (sectPr.isSetPgSz) sectPr.pgSz else sectPr.addNewPgSz()\n        pgSz.w \u003d java.math.BigInteger.valueOf(11906) // A4 width in twips\n        pgSz.h \u003d java.math.BigInteger.valueOf(16838) // A4 height in twips\n\n        // Set margins (2.54cm \u003d 1440 twips)\n        val pgMar \u003d if (sectPr.isSetPgMar) sectPr.pgMar else sectPr.addNewPgMar()\n        pgMar.top \u003d java.math.BigInteger.valueOf(1440)    // 2.54cm\n        pgMar.bottom \u003d java.math.BigInteger.valueOf(1440) // 2.54cm\n        pgMar.left \u003d java.math.BigInteger.valueOf(1440)   // 2.54cm\n        pgMar.right \u003d java.math.BigInteger.valueOf(1440)  // 2.54cm\n\n    } catch (e: Exception) {\n        Logger.w(\&quot;Failed to set A4 page size: ${e.message}\&quot;)\n    }\n}\n\nprivate fun parseJsoupNode(\n    jsoupNode: Node,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    context: Context\n) {\n    when (jsoupNode) {\n        is TextNode -\u003e {\n            val text \u003d jsoupNode.text().replace(\&quot;\\u00A0\&quot;, \&quot; \&quot;)\n            if (text.isNotEmpty()) {\n                val para \u003d currentParagraph ?: document.createParagraph()\n                para.createRun().setText(text)\n            }\n        }\n        is Element -\u003e {\n            var nextParagraph: XWPFParagraph? \u003d currentParagraph\n            var currentRun: XWPFRun? \u003d null\n\n            val tagName \u003d jsoupNode.tagName().lowercase()\n            val isBlockElement \u003d tagName in listOf(\&quot;p\&quot;, \&quot;div\&quot;, \&quot;h1\&quot;, \&quot;h2\&quot;, \&quot;h3\&quot;, \&quot;h4\&quot;, \&quot;h5\&quot;, \&quot;h6\&quot;, \&quot;table\&quot;, \&quot;ul\&quot;, \&quot;ol\&quot;, \&quot;li\&quot;, \&quot;blockquote\&quot;, \&quot;hr\&quot;, \&quot;header\&quot;, \&quot;footer\&quot;, \&quot;section\&quot;, \&quot;article\&quot;, \&quot;aside\&quot;, \&quot;nav\&quot;)\n\n            if (isBlockElement || nextParagraph \u003d\u003d null) {\n                nextParagraph \u003d document.createParagraph()\n            }\n            currentRun \u003d nextParagraph.createRun()\n\n            parseStyleAndApply(jsoupNode.attr(\&quot;style\&quot;), nextParagraph, currentRun)\n            applyParagraphAlignment(jsoupNode, nextParagraph)\n\n            when (tagName) {\n                \&quot;h1\&quot; -\u003e { currentRun?.fontSize \u003d 22; currentRun?.isBold \u003d true }\n                \&quot;h2\&quot; -\u003e { currentRun?.fontSize \u003d 18; currentRun?.isBold \u003d true }\n                \&quot;h3\&quot; -\u003e { currentRun?.fontSize \u003d 16; currentRun?.isBold \u003d true }\n                \&quot;h4\&quot; -\u003e { currentRun?.fontSize \u003d 14; currentRun?.isBold \u003d true }\n                \&quot;h5\&quot; -\u003e { currentRun?.fontSize \u003d 12; currentRun?.isBold \u003d true }\n                \&quot;h6\&quot; -\u003e { currentRun?.fontSize \u003d 10; currentRun?.isBold \u003d true }\n                \&quot;strong\&quot;, \&quot;b\&quot; -\u003e currentRun?.isBold \u003d true\n                \&quot;em\&quot;, \&quot;i\&quot; -\u003e currentRun?.isItalic \u003d true\n                \&quot;u\&quot; -\u003e currentRun?.underline \u003d UnderlinePatterns.SINGLE\n                \&quot;s\&quot;, \&quot;strike\&quot; -\u003e currentRun?.isStrikeThrough \u003d true\n                \&quot;br\&quot; -\u003e currentRun?.addBreak()\n                \&quot;img\&quot; -\u003e {\n                    val src \u003d jsoupNode.attr(\&quot;src\&quot;)\n                    if (src.startsWith(\&quot;data:image\&quot;)) {\n                        try {\n                            val parts \u003d src.split(\&quot;,\&quot;)\n                            if (parts.size \u003d\u003d 2) {\n                                val meta \u003d parts[0]\n                                val base64Data \u003d parts[1]\n                                val decodedData \u003d Base64.decode(base64Data, Base64.DEFAULT)\n                                val pictureType \u003d when {\n                                    meta.contains(\&quot;jpeg\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_JPEG\n                                    meta.contains(\&quot;png\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                                    meta.contains(\&quot;gif\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_GIF\n                                    meta.contains(\&quot;bmp\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_BMP\n                                    meta.contains(\&quot;tiff\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_TIFF\n                                    else -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                                }\n                                val widthPx \u003d jsoupNode.attr(\&quot;width\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 200\n                                val heightPx \u003d jsoupNode.attr(\&quot;height\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 150\n                                val widthEmu \u003d widthPx * Units.EMU_PER_PIXEL\n                                val heightEmu \u003d heightPx * Units.EMU_PER_PIXEL\n\n                                val imageParagraph \u003d document.createParagraph()\n                                imageParagraph.createRun().addPicture(ByteArrayInputStream(decodedData), pictureType, \&quot;image.dat\&quot;, widthEmu, heightEmu)\n                                nextParagraph \u003d null \n                            }\n                        } catch (e: Exception) {\n                            Logger.e(\&quot;Error processing base64 image in CreateNewDocxScreen: ${e.message}\&quot;, e)\n                        }\n                    }\n                }\n            }\n\n            val paragraphForChildren \u003d if (tagName \u003d\u003d \&quot;img\&quot;) null else nextParagraph\n            jsoupNode.childNodes().forEach { child -\u003e\n                parseJsoupNode(child, document, paragraphForChildren, context)\n            }\n        }\n    }\n}\n\nprivate fun applyParagraphAlignment(element: Element, paragraph: XWPFParagraph?) {\n    if (paragraph \u003d\u003d null) return\n    val style \u003d element.attr(\&quot;style\&quot;)\n    when {\n        style.contains(\&quot;text-align: center\&quot;) -\u003e paragraph.alignment \u003d ParagraphAlignment.CENTER\n        style.contains(\&quot;text-align: right\&quot;) -\u003e paragraph.alignment \u003d ParagraphAlignment.RIGHT\n        style.contains(\&quot;text-align: justify\&quot;) -\u003e paragraph.alignment \u003d ParagraphAlignment.BOTH\n        style.contains(\&quot;text-align: left\&quot;) -\u003e paragraph.alignment \u003d ParagraphAlignment.LEFT\n        else -\u003e {\n            val classes \u003d element.className()\n            when {\n                classes.contains(\&quot;text-center\&quot;) -\u003e paragraph.alignment \u003d ParagraphAlignment.CENTER\n                classes.contains(\&quot;text-right\&quot;) -\u003e paragraph.alignment \u003d ParagraphAlignment.RIGHT\n                classes.contains(\&quot;text-justify\&quot;) -\u003e paragraph.alignment \u003d ParagraphAlignment.BOTH\n                classes.contains(\&quot;text-left\&quot;) -\u003e paragraph.alignment \u003d ParagraphAlignment.LEFT\n            }\n        }\n    }\n}\n\n//private fun parseStyleAndApply(styleAttribute: String, paragraph: XWPFParagraph?, run: XWPFRun?) {\n//    if (run \u003d\u003d null \u0026\u0026 paragraph \u003d\u003d null) return\n//\n//    styleAttribute.split(\u0027;\u0027).map { it.trim() }.filter { it.isNotEmpty() }.forEach { style -\u003e\n//        val parts \u003d style.split(\u0027:\u0027).map { it.trim() }\n//        if (parts.size \u003d\u003d 2) {\n//            val property \u003d parts[0].lowercase()\n//            val value \u003d parts[1]\n//            try {\n//                when (property) {\n//                    \&quot;color\&quot; -\u003e if (value.startsWith(\&quot;#\&quot;) \u0026\u0026 (value.length \u003d\u003d 7 || value.length \u003d\u003d 4)) {\n//                        run?.setColor(value.removePrefix(\&quot;#\&quot;))\n//                    }\n//                    \&quot;font-weight\&quot; -\u003e if (value \u003d\u003d \&quot;bold\&quot; || (value.toIntOrNull() ?: 400) \u003e\u003d 600) {\n//                        run?.isBold \u003d true\n//                    }\n//                    \&quot;font-style\&quot; -\u003e if (value \u003d\u003d \&quot;italic\&quot;) {\n//                        run?.isItalic \u003d true\n//                    }\n//                    \&quot;font-size\&quot; -\u003e {\n//                        val size \u003d when {\n//                            value.endsWith(\&quot;pt\&quot;) -\u003e value.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.toInt()\n//                            value.endsWith(\&quot;px\&quot;) -\u003e (value.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(0.75))?.toInt()\n//                            else -\u003e null\n//                        }\n//                        if (size !\u003d null) run?.fontSize \u003d size\n//                    }\n//                    \&quot;font-family\&quot; -\u003e run?.fontFamily \u003d value.replace(\&quot;\\\u0027\&quot;, \&quot;\&quot;).split(\&quot;,\&quot;)[0].trim()\n//                    \&quot;text-decoration\&quot;, \&quot;text-decoration-line\&quot; -\u003e {\n//                        if (value.contains(\&quot;underline\&quot;)) run?.underline \u003d UnderlinePatterns.SINGLE\n//                        if (value.contains(\&quot;line-through\&quot;)) run?.isStrikeThrough \u003d true\n//                    }\n//                    \&quot;margin-top\&quot; -\u003e {\n//                        if (paragraph !\u003d null \u0026\u0026 value.endsWith(\&quot;pt\&quot;)) {\n//                            paragraph.spacingBefore \u003d (value.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20))?.toInt() ?: paragraph.spacingBefore\n//                        }\n//                    }\n//                    \&quot;margin-bottom\&quot; -\u003e {\n//                        if (paragraph !\u003d null \u0026\u0026 value.endsWith(\&quot;pt\&quot;)) {\n//                            paragraph.spacingAfter \u003d (value.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20))?.toInt() ?: paragraph.spacingAfter\n//                        }\n//                    }\n//                    \&quot;line-height\&quot; -\u003e {\n//                        if (paragraph !\u003d null) {\n//                            val lineHeightValue \u003d value.toDoubleOrNull()\n//                            if (lineHeightValue !\u003d null) {\n//                                paragraph.setSpacingBetween(lineHeightValue * 240, LineSpacingRule.AUTO)\n//                            }\n//                        }\n//                    }\n//                }\n//            } catch (e: Exception) {\n//                Logger.w(\&quot;Failed to parse style in CreateNewDocxScreen: $property \u003d $value. Error: ${e.message}\&quot;)\n//            }\n//        }\n//    }\n//}\n&quot;},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;read_file&quot;,&quot;tool_call_id&quot;:&quot;call_5sKJrGOWmb4opThGRI4JImlF&quot;,&quot;content&quot;:&quot;package com.example.docx.ui\n\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.net.Uri\nimport android.util.Base64\nimport android.webkit.WebView\nimport androidx.activity.compose.rememberLauncherForActivityResult\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.ColorFilter\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.viewinterop.AndroidView\nimport androidx.documentfile.provider.DocumentFile\nimport androidx.navigation.NavController\nimport com.example.docx.R\nimport com.example.docx.util.Logger\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport org.apache.poi.common.usermodel.PictureType\nimport org.apache.poi.util.Units\nimport org.apache.poi.xwpf.usermodel.*\nimport org.openxmlformats.schemas.officeDocument.x2006.sharedTypes.STVerticalAlignRun as OfficeSTVerticalAlignRun\nimport org.openxmlformats.schemas.wordprocessingml.x2006.main.*\nimport org.jsoup.Jsoup\nimport org.jsoup.nodes.Element\nimport org.jsoup.nodes.Node\nimport org.jsoup.nodes.TextNode\nimport java.io.ByteArrayInputStream\nimport java.io.ByteArrayOutputStream\nimport java.io.IOException\nimport java.math.BigInteger\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// EditDocxScreen Composable\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n@OptIn(ExperimentalMaterial3Api::class)\n@SuppressLint(\&quot;SetJavaScriptEnabled\&quot;)\n@Composable\nfun EditDocxScreen(navController: NavController, fileUriString: String) {\n    var documentHtml by remember { mutableStateOf(\&quot;\u003cp\u003e\u003c/p\u003e\&quot;) }\n    var isLoading by remember { mutableStateOf(true) }\n    var isSaving by remember { mutableStateOf(false) }\n    val context \u003d LocalContext.current\n    val scope \u003d rememberCoroutineScope()\n    var errorMessage by remember { mutableStateOf\u003cString?\u003e(null) }\n    var showErrorDialog by remember { mutableStateOf(false) }\n    val webView \u003d remember { WebView(context) }\n\n    val currentFileUri \u003d remember { Uri.parse(fileUriString) }\n\n    val saveAsLauncher \u003d rememberLauncherForActivityResult(\n        contract \u003d ActivityResultContracts.CreateDocument(\&quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document\&quot;),\n        onResult \u003d { newFileUri: Uri? -\u003e\n            if (newFileUri !\u003d null) {\n                webView.evaluateJavascript(\n                    \&quot;(function() { return document.documentElement.outerHTML; })();\&quot;\n                ) { htmlContent -\u003e\n                    scope.launch {\n                        isSaving \u003d true\n                        val result \u003d writeHtmlToDocx(context, newFileUri, htmlContent ?: \&quot;\u003chtml\u003e\u003cbody\u003e\u003c/body\u003e\u003c/html\u003e\&quot;)\n                        result.fold(\n                            onSuccess \u003d {\n                                Logger.i(\&quot;Document saved successfully to $newFileUri\&quot;)\n                                navController.navigateUp()\n                            },\n                            onFailure \u003d { error -\u003e\n                                errorMessage \u003d \&quot;Save failed: ${error.message}\&quot;\n                                showErrorDialog \u003d true\n                            }\n                        )\n                        if(!showErrorDialog) isSaving \u003d false\n                    }\n                }\n            } else {\n                isSaving \u003d false\n                Logger.d(\&quot;Save As action cancelled.\&quot;)\n            }\n        }\n    )\n\n    LaunchedEffect(currentFileUri) {\n        isLoading \u003d true\n        Logger.d(\&quot;LaunchedEffect: Loading DOCX from $currentFileUri\&quot;)\n        withContext(Dispatchers.IO) {\n            try {\n                context.contentResolver.openInputStream(currentFileUri)?.use { inputStream -\u003e\n                    val document \u003d XWPFDocument(inputStream)\n                    val html \u003d convertDocxToHtmlEnhanced(document)\n                    withContext(Dispatchers.Main) {\n                        documentHtml \u003d html\n                        Logger.d(\&quot;Document loaded and converted to HTML successfully.\&quot;)\n                    }\n                    document.close()\n                } ?: throw IOException(\&quot;Failed to open input stream for $currentFileUri\&quot;)\n            } catch (e: Exception) {\n                Logger.e(\&quot;Error loading DOCX: ${e.localizedMessage}\&quot;, e)\n                withContext(Dispatchers.Main) {\n                    errorMessage \u003d \&quot;Load failed: ${e.localizedMessage}\&quot;\n                    showErrorDialog \u003d true\n                }\n            } finally {\n                withContext(Dispatchers.Main) {\n                    isLoading \u003d false\n                }\n            }\n        }\n    }\n\n    if (showErrorDialog) {\n        AlertDialog(\n            onDismissRequest \u003d {\n                showErrorDialog \u003d false\n                isSaving \u003d false\n            },\n            title \u003d { Text(\&quot;Error\&quot;) },\n            text \u003d { Text(errorMessage ?: \&quot;An unknown error occurred.\&quot;) },\n            confirmButton \u003d {\n                TextButton(onClick \u003d {\n                    showErrorDialog \u003d false\n                    isSaving \u003d false\n                    if (errorMessage?.startsWith(\&quot;Load failed\&quot;) \u003d\u003d true) navController.navigateUp()\n                }) { Text(\&quot;OK\&quot;) }\n            }\n        )\n    }\n\n    Scaffold(\n        topBar \u003d {\n            TopAppBar(\n                title \u003d { Text(DocumentFile.fromSingleUri(context, currentFileUri)?.name ?: \&quot;Edit Document\&quot;) },\n                navigationIcon \u003d {\n                    IconButton(onClick \u003d { navController.navigateUp() }, enabled \u003d !isSaving) {\n                        Icon(Icons.AutoMirrored.Filled.ArrowBack, \&quot;Back\&quot;)\n                    }\n                },\n                actions \u003d {\n                    TextButton(\n                        onClick \u003d {\n                            isSaving \u003d true\n                            val originalFileName \u003d DocumentFile.fromSingleUri(context, currentFileUri)?.name ?: \&quot;Untitled.docx\&quot;\n                            saveAsLauncher.launch(originalFileName)\n                        },\n                        enabled \u003d !isLoading \u0026\u0026 !isSaving\n                    ) {\n                        Text(if (isSaving) \&quot;Saving...\&quot; else \&quot;Save\&quot;)\n                    }\n                }\n            )\n        }\n    ) { paddingValues -\u003e\n        Column(\n            modifier \u003d Modifier\n                .fillMaxSize()\n                .padding(paddingValues)\n        ) {\n            FormattingToolbar(webView \u003d webView)\n            Box(modifier \u003d Modifier.weight(1f)) {\n                if (isLoading) {\n                    CircularProgressIndicator(modifier \u003d Modifier.align(Alignment.Center))\n                } else {\n                    AndroidView(\n                        factory \u003d { webViewContext -\u003e\n                            webView.apply {\n                                settings.javaScriptEnabled \u003d true\n                                settings.domStorageEnabled \u003d true\n                                settings.allowFileAccess \u003d true\n                                settings.defaultTextEncodingName \u003d \&quot;utf-8\&quot;\n                                settings.builtInZoomControls \u003d true\n                                settings.displayZoomControls \u003d false\n\n                                webViewClient \u003d object : android.webkit.WebViewClient() {\n                                    override fun onPageFinished(view: WebView?, url: String?) {\n                                        evaluateJavascript(\&quot;document.body.contentEditable \u003d true;\&quot;) {}\n                                    }\n                                }\n                                loadDataWithBaseURL(null, documentHtml, \&quot;text/html\&quot;, \&quot;utf-8\&quot;, null)\n                            }\n                        },\n                        modifier \u003d Modifier\n                            .fillMaxSize()\n                            .padding(horizontal \u003d 16.dp)\n                    )\n                }\n                if (isSaving) {\n                    Surface(modifier \u003d Modifier.fillMaxSize(), color \u003d MaterialTheme.colorScheme.surface.copy(alpha \u003d 0.8f)) {\n                        Column(\n                            modifier \u003d Modifier.fillMaxSize(),\n                            horizontalAlignment \u003d Alignment.CenterHorizontally,\n                            verticalArrangement \u003d Arrangement.Center\n                        ) {\n                            CircularProgressIndicator()\n                            Spacer(modifier \u003d Modifier.height(16.dp))\n                            Text(\&quot;Preparing to save...\&quot;)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun FormattingToolbar(webView: WebView) {\n    val fonts \u003d listOf(\&quot;Arial\&quot;, \&quot;Calibri\&quot;, \&quot;Courier New\&quot;, \&quot;Georgia\&quot;, \&quot;Times New Roman\&quot;, \&quot;Verdana\&quot;)\n    var selectedFont by remember { mutableStateOf(fonts[0]) }\n    var isFontDropdownExpanded by remember { mutableStateOf(false) }\n\n    var isBoldSelected by remember { mutableStateOf(false) }\n    var isItalicSelected by remember { mutableStateOf(false) }\n    var isUnderlineSelected by remember { mutableStateOf(false) }\n\n    Row(\n        modifier \u003d Modifier\n            .fillMaxWidth()\n            .padding(horizontal \u003d 8.dp, vertical \u003d 4.dp),\n        verticalAlignment \u003d Alignment.CenterVertically,\n        horizontalArrangement \u003d Arrangement.spacedBy(8.dp)\n    ) {\n        ExposedDropdownMenuBox(\n            expanded \u003d isFontDropdownExpanded,\n            onExpandedChange \u003d { isFontDropdownExpanded \u003d !isFontDropdownExpanded },\n            modifier \u003d Modifier.weight(1f)\n        ) {\n            OutlinedTextField(\n                value \u003d selectedFont,\n                onValueChange \u003d {},\n                readOnly \u003d true,\n                label \u003d { Text(\&quot;Font\&quot;) },\n                trailingIcon \u003d { ExposedDropdownMenuDefaults.TrailingIcon(expanded \u003d isFontDropdownExpanded) },\n                modifier \u003d Modifier.menuAnchor()\n            )\n            ExposedDropdownMenu(\n                expanded \u003d isFontDropdownExpanded,\n                onDismissRequest \u003d { isFontDropdownExpanded \u003d false }\n            ) {\n                fonts.forEach { fontName -\u003e\n                    DropdownMenuItem(\n                        text \u003d { Text(fontName) },\n                        onClick \u003d {\n                            selectedFont \u003d fontName\n                            isFontDropdownExpanded \u003d false\n                            webView.evaluateJavascript(\&quot;document.execCommand(\u0027fontName\u0027, false, \u0027$fontName\u0027);\&quot;, null)\n                        }\n                    )\n                }\n            }\n        }\n\n        IconButton(onClick \u003d {\n            isBoldSelected \u003d !isBoldSelected\n            webView.evaluateJavascript(\&quot;document.execCommand(\u0027bold\u0027);\&quot;, null)\n        }) {\n            Image(\n                painter \u003d painterResource(id \u003d R.drawable.bold),\n                contentDescription \u003d \&quot;Bold\&quot;,\n                colorFilter \u003d if (isBoldSelected) ColorFilter.tint(MaterialTheme.colorScheme.primary) else null\n            )\n        }\n\n        IconButton(onClick \u003d {\n            isItalicSelected \u003d !isItalicSelected\n            webView.evaluateJavascript(\&quot;document.execCommand(\u0027italic\u0027);\&quot;, null)\n        }) {\n            Icon(\n                painter \u003d painterResource(R.drawable.bold),\n                contentDescription \u003d \&quot;Italic\&quot;,\n                tint \u003d if (isItalicSelected) MaterialTheme.colorScheme.primary else Color.Unspecified\n            )\n        }\n\n        IconButton(onClick \u003d {\n            isUnderlineSelected \u003d !isUnderlineSelected\n            webView.evaluateJavascript(\&quot;document.execCommand(\u0027underline\u0027);\&quot;, null)\n        }) {\n            Icon(\n                painter \u003d painterResource(R.drawable.bold),\n                contentDescription \u003d \&quot;Underline\&quot;,\n                tint \u003d if (isUnderlineSelected) MaterialTheme.colorScheme.primary else Color.Unspecified\n            )\n        }\n    }\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// DOCX -\u003e HTML CONVERSION (Enhanced)\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nfun convertDocxToHtmlEnhanced(document: XWPFDocument): String {\n    val html \u003d StringBuilder()\n    html.append(\&quot;\u003c!DOCTYPE html\u003e\u003chtml\u003e\u003chead\u003e\&quot;)\n    html.append(\&quot;\u003cmeta charset\u003d\\\&quot;UTF-8\\\&quot;\u003e\&quot;)\n    html.append(\&quot;\u003cmeta name\u003d\\\&quot;viewport\\\&quot; content\u003d\\\&quot;width\u003ddevice-width, initial-scale\u003d1.0, user-scalable\u003dyes\\\&quot;\u003e\&quot;)\n    html.append(\&quot;\u003cstyle\u003e\&quot;)\n    html.append(\&quot;body { font-family: Arial, sans-serif; font-size: 12pt; margin: 0; padding: 20px; background: #f0f0f0; word-wrap: break-word; }\&quot;)\n    html.append(\&quot;.page { background: white; width: 21cm; min-height: 29.7cm; margin: 0 auto 20px auto; padding: 2.54cm; box-shadow: 0 4px 8px rgba(0,0,0,0.1); position: relative; page-break-after: always; overflow-wrap: break-word; }\&quot;)\n    html.append(\&quot;.page:last-child { page-break-after: auto; }\&quot;)\n    html.append(\&quot;p { margin-bottom: 0.5em; }\&quot;)\n    html.append(\&quot;table { border-collapse: collapse; width: 100%; margin-bottom: 1em; table-layout: fixed; }\&quot;)\n    html.append(\&quot;td, th { border: 1px solid #BFBFBF; padding: 6px 8px; vertical-align: top; text-align: left; word-wrap: break-word; font-size: 10pt; }\&quot;)\n    html.append(\&quot;img { max-width: 100%; height: auto; display: block; margin: 0.2em 0; }\&quot;)\n    html.append(\&quot;ul, ol { margin: 0.5em 0; padding-left: 2em; }\&quot;)\n    html.append(\&quot;li { margin-bottom: 0.25em; }\&quot;)\n    html.append(\&quot;h1, h2, h3, h4, h5, h6 { margin-top: 1em; margin-bottom: 0.5em; }\&quot;)\n    html.append(\&quot;.page-number { position: absolute; bottom: 1.27cm; right: 2.54cm; font-size: 10pt; color: #666; pointer-events: none; }\&quot;)\n    html.append(\&quot;\u003c/style\u003e\&quot;)\n    html.append(\&quot;\u003cscript\u003e\&quot;)\n    html.append(\&quot;let pageCounter \u003d 1;\&quot;)\n    html.append(\&quot;let isProcessing \u003d false;\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;function createNewPage() {\&quot;)\n    html.append(\&quot;  pageCounter++;\&quot;)\n    html.append(\&quot;  const newPage \u003d document.createElement(\u0027div\u0027);\&quot;)\n    html.append(\&quot;  newPage.className \u003d \u0027page\u0027;\&quot;)\n    html.append(\&quot;  newPage.id \u003d \u0027page\u0027 + pageCounter;\&quot;)\n    html.append(\&quot;  newPage.innerHTML \u003d \u0027\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u0027;\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  // Add page number\&quot;)\n    html.append(\&quot;  const pageNum \u003d document.createElement(\u0027div\u0027);\&quot;)\n    html.append(\&quot;  pageNum.className \u003d \u0027page-number\u0027;\&quot;)\n    html.append(\&quot;  pageNum.textContent \u003d pageCounter;\&quot;)\n    html.append(\&quot;  newPage.appendChild(pageNum);\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  document.body.appendChild(newPage);\&quot;)\n    html.append(\&quot;  return newPage;\&quot;)\n    html.append(\&quot;}\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;function updatePageNumbers() {\&quot;)\n    html.append(\&quot;  const pages \u003d document.querySelectorAll(\u0027.page\u0027);\&quot;)\n    html.append(\&quot;  pages.forEach((page, index) \u003d\u003e {\&quot;)\n    html.append(\&quot;    let pageNum \u003d page.querySelector(\u0027.page-number\u0027);\&quot;)\n    html.append(\&quot;    if (!pageNum) {\&quot;)\n    html.append(\&quot;      pageNum \u003d document.createElement(\u0027div\u0027);\&quot;)\n    html.append(\&quot;      pageNum.className \u003d \u0027page-number\u0027;\&quot;)\n    html.append(\&quot;      page.appendChild(pageNum);\&quot;)\n    html.append(\&quot;    }\&quot;)\n    html.append(\&quot;    pageNum.textContent \u003d index + 1;\&quot;)\n    html.append(\&quot;  });\&quot;)\n    html.append(\&quot;}\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;function checkPageOverflow() {\&quot;)\n    html.append(\&quot;  if (isProcessing) return;\&quot;)\n    html.append(\&quot;  isProcessing \u003d true;\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  const pages \u003d document.querySelectorAll(\u0027.page\u0027);\&quot;)\n    html.append(\&quot;  const pageHeight \u003d 29.7 * 37.795; // A4 height in pixels\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  pages.forEach((page, index) \u003d\u003e {\&quot;)\n    html.append(\&quot;    const contentHeight \u003d page.scrollHeight;\&quot;)\n    html.append(\&quot;    if (contentHeight \u003e pageHeight) {\&quot;)\n    html.append(\&quot;      // Create new page if it doesn\u0027t exist\&quot;)\n    html.append(\&quot;      let nextPage \u003d document.getElementById(\u0027page\u0027 + (index + 2));\&quot;)\n    html.append(\&quot;      if (!nextPage) {\&quot;)\n    html.append(\&quot;        nextPage \u003d createNewPage();\&quot;)\n    html.append(\&quot;      }\&quot;)\n    html.append(\&quot;      \&quot;)\n    html.append(\&quot;      // Move overflow content to next page\&quot;)\n    html.append(\&quot;      const elements \u003d Array.from(page.children);\&quot;)\n    html.append(\&quot;      let totalHeight \u003d 0;\&quot;)\n    html.append(\&quot;      let moveIndex \u003d -1;\&quot;)\n    html.append(\&quot;      \&quot;)\n    html.append(\&quot;      for (let i \u003d 0; i \u003c elements.length; i++) {\&quot;)\n    html.append(\&quot;        const elem \u003d elements[i];\&quot;)\n    html.append(\&quot;        if (elem.className \u003d\u003d\u003d \u0027page-number\u0027) continue;\&quot;)\n    html.append(\&quot;        \&quot;)\n    html.append(\&quot;        const elemHeight \u003d elem.offsetHeight;\&quot;)\n    html.append(\&quot;        if (totalHeight + elemHeight \u003e pageHeight - 100) {\&quot;) // Leave some margin\n    html.append(\&quot;          moveIndex \u003d i;\&quot;)\n    html.append(\&quot;          break;\&quot;)\n    html.append(\&quot;        }\&quot;)\n    html.append(\&quot;        totalHeight +\u003d elemHeight;\&quot;)\n    html.append(\&quot;      }\&quot;)\n    html.append(\&quot;      \&quot;)\n    html.append(\&quot;      if (moveIndex !\u003d\u003d -1) {\&quot;)\n    html.append(\&quot;        for (let i \u003d moveIndex; i \u003c elements.length; i++) {\&quot;)\n    html.append(\&quot;          const elem \u003d elements[i];\&quot;)\n    html.append(\&quot;          if (elem.className !\u003d\u003d \u0027page-number\u0027) {\&quot;)\n    html.append(\&quot;            nextPage.insertBefore(elem, nextPage.querySelector(\u0027.page-number\u0027));\&quot;)\n    html.append(\&quot;          }\&quot;)\n    html.append(\&quot;        }\&quot;)\n    html.append(\&quot;      }\&quot;)\n    html.append(\&quot;    }\&quot;)\n    html.append(\&quot;  });\&quot;)\n    html.append(\&quot;  \&quot;)\n    html.append(\&quot;  updatePageNumbers();\&quot;)\n    html.append(\&quot;  isProcessing \u003d false;\&quot;)\n    html.append(\&quot;}\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;function ensureMinimumOnePage() {\&quot;)\n    html.append(\&quot;  if (document.querySelectorAll(\u0027.page\u0027).length \u003d\u003d\u003d 0) {\&quot;)\n    html.append(\&quot;    const firstPage \u003d document.createElement(\u0027div\u0027);\&quot;)\n    html.append(\&quot;    firstPage.className \u003d \u0027page\u0027;\&quot;)\n    html.append(\&quot;    firstPage.id \u003d \u0027page1\u0027;\&quot;)\n    html.append(\&quot;    firstPage.innerHTML \u003d \u0027\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u0027;\&quot;)\n    html.append(\&quot;    document.body.appendChild(firstPage);\&quot;)\n    html.append(\&quot;  }\&quot;)\n    html.append(\&quot;  updatePageNumbers();\&quot;)\n    html.append(\&quot;}\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;document.addEventListener(\u0027DOMContentLoaded\u0027, function() {\&quot;)\n    html.append(\&quot;  ensureMinimumOnePage();\&quot;)\n    html.append(\&quot;  setTimeout(checkPageOverflow, 500);\&quot;)\n    html.append(\&quot;});\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;document.addEventListener(\u0027input\u0027, function() {\&quot;)\n    html.append(\&quot;  setTimeout(checkPageOverflow, 300);\&quot;)\n    html.append(\&quot;});\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;document.addEventListener(\u0027keydown\u0027, function(e) {\&quot;)\n    html.append(\&quot;  if (e.ctrlKey \u0026\u0026 e.key \u003d\u003d\u003d \u0027Enter\u0027) {\&quot;)\n    html.append(\&quot;    e.preventDefault();\&quot;)\n    html.append(\&quot;    createNewPage();\&quot;)\n    html.append(\&quot;    updatePageNumbers();\&quot;)\n    html.append(\&quot;  }\&quot;)\n    html.append(\&quot;});\&quot;)\n    html.append(\&quot;\&quot;)\n    html.append(\&quot;// Periodic check for content changes\&quot;)\n    html.append(\&quot;setInterval(checkPageOverflow, 2000);\&quot;)\n    html.append(\&quot;\u003c/script\u003e\&quot;)\n    html.append(\&quot;\u003c/head\u003e\u003cbody\u003e\&quot;)\n\n    html.append(\&quot;\u003cdiv class\u003d\u0027page\u0027 id\u003d\u0027page1\u0027\u003e\&quot;)\n\n    for (bodyElement in document.bodyElements) {\n        when (bodyElement) {\n            is XWPFParagraph -\u003e html.append(convertParagraphToHtmlExact(bodyElement))\n            is XWPFTable -\u003e html.append(convertTableToHtmlExact(bodyElement))\n        }\n    }\n\n    html.append(\&quot;\u003c/div\u003e\&quot;) // Close first page\n    html.append(\&quot;\u003c/body\u003e\u003c/html\u003e\&quot;)\n    return html.toString()\n}\n\nfun convertParagraphToHtmlExact(paragraph: XWPFParagraph): String {\n    val style \u003d buildString {\n        if (paragraph.spacingBefore \u003e 0) append(\&quot;margin-top: ${paragraph.spacingBefore / 20.0}pt; \&quot;)\n        if (paragraph.spacingAfter \u003e 0) append(\&quot;margin-bottom: ${paragraph.spacingAfter / 20.0}pt; \&quot;)\n        if (paragraph.spacingLineRule \u003d\u003d LineSpacingRule.AUTO \u0026\u0026 paragraph.spacingBetween \u003e 0) {\n            append(\&quot;line-height: ${paragraph.spacingBetween / 240.0}; \&quot;)\n        }\n        if (paragraph.alignment !\u003d ParagraphAlignment.LEFT) {\n            append(\&quot;text-align: ${paragraph.alignment.name.lowercase()}; \&quot;)\n        }\n    }\n    val pTag \u003d StringBuilder()\n    pTag.append(\&quot;\u003cp style\u003d\u0027${style}\u0027\u003e\&quot;)\n    var contentAdded \u003d false\n    for (run in paragraph.runs) {\n        val runHtml \u003d convertRunToHtmlExact(run)\n        if (runHtml.isNotBlank()) {\n            pTag.append(runHtml)\n            contentAdded \u003d true\n        }\n    }\n    if (!contentAdded \u0026\u0026 paragraph.text.isBlank()) {\n        pTag.append(\&quot;\u0026nbsp;\&quot;)\n    }\n    pTag.append(\&quot;\u003c/p\u003e\&quot;)\n    return pTag.toString()\n}\n\nfun convertRunToHtmlExact(run: XWPFRun): String {\n    val style \u003d buildString {\n        val fontSizeInPoints: Double? \u003d run.getFontSizeAsDouble()\n        if (fontSizeInPoints !\u003d null \u0026\u0026 fontSizeInPoints \u003e 0) {\n            append(\&quot;font-size: ${fontSizeInPoints}pt; \&quot;)\n        }\n        if (!run.fontFamily.isNullOrEmpty()) append(\&quot;font-family: \u0027${run.fontFamily}\u0027; \&quot;)\n        if (run.color !\u003d null \u0026\u0026 run.color !\u003d \&quot;auto\&quot;) append(\&quot;color: #${run.color}; \&quot;)\n        if (run.isBold) append(\&quot;font-weight: bold; \&quot;)\n        if (run.isItalic) append(\&quot;font-style: italic; \&quot;)\n        if (run.isStrikeThrough) append(\&quot;text-decoration: line-through; \&quot;)\n        if (run.underline !\u003d UnderlinePatterns.NONE \u0026\u0026 run.underline !\u003d null) append(\&quot;text-decoration: underline; \&quot;)\n    }\n    var text \u003d run.text() ?: \&quot;\&quot;\n    text \u003d text.replace(\&quot;\u0026\&quot;, \&quot;\u0026amp;\&quot;)\n        .replace(\&quot;\u003c\&quot;, \&quot;\u0026lt;\&quot;)\n        .replace(\&quot;\u003e\&quot;, \&quot;\u0026gt;\&quot;)\n        .replace(\&quot;\\\&quot;\&quot;, \&quot;\u0026quot;\&quot;)\n        .replace(\&quot;\\t\&quot;, \&quot;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\&quot;)\n        .replace(\&quot;\\n\&quot;, \&quot;\u003cbr\u003e\&quot;)\n    var html \u003d \&quot;\u003cspan style\u003d\u0027${style}\u0027\u003e$text\u003c/span\u003e\&quot;\n    when (run.getVerticalAlignment()) {\n        OfficeSTVerticalAlignRun.SUBSCRIPT -\u003e html \u003d \&quot;\u003csub\u003e$html\u003c/sub\u003e\&quot;\n        OfficeSTVerticalAlignRun.SUPERSCRIPT -\u003e html \u003d \&quot;\u003csup\u003e$html\u003c/sup\u003e\&quot;\n        else -\u003e {}\n    }\n    for (pic in run.embeddedPictures) {\n        try {\n            val picData \u003d pic.pictureData\n            val ext \u003d when (picData.pictureTypeEnum) {\n                PictureType.JPEG -\u003e \&quot;jpeg\&quot;\n                PictureType.PNG -\u003e \&quot;png\&quot;\n                PictureType.GIF -\u003e \&quot;gif\&quot;\n                PictureType.BMP -\u003e \&quot;bmp\&quot;\n                PictureType.WMF -\u003e \&quot;wmf\&quot;\n                PictureType.EMF -\u003e \&quot;emf\&quot;\n                PictureType.PICT -\u003e \&quot;pict\&quot;\n                PictureType.TIFF -\u003e \&quot;tiff\&quot;\n                else -\u003e \&quot;png\&quot;\n            }\n            val base64 \u003d Base64.encodeToString(picData.data, Base64.DEFAULT)\n            val xfrm \u003d pic.ctPicture?.spPr?.xfrm\n            var imgWidth \u003d \&quot;auto\&quot;\n            var imgHeight \u003d \&quot;auto\&quot;\n            if (xfrm?.ext !\u003d null) {\n                val widthEmu \u003d xfrm.ext.cx\n                val heightEmu \u003d xfrm.ext.cy\n                imgWidth \u003d \&quot;${widthEmu / Units.EMU_PER_PIXEL}px\&quot;\n                imgHeight \u003d \&quot;${heightEmu / Units.EMU_PER_PIXEL}px\&quot;\n            }\n            html +\u003d \&quot;\u003cimg src\u003d\u0027data:image/$ext;base64,$base64\u0027 width\u003d\u0027$imgWidth\u0027 height\u003d\u0027$imgHeight\u0027 alt\u003d\u0027${pic.description ?: \&quot;Embedded image\&quot;}\u0027 /\u003e\&quot;\n        } catch (e: Exception) {\n            Logger.e(\&quot;Error processing embedded picture: ${e.message}\&quot;, e)\n            html +\u003d \&quot;\u003c!-- Error loading image: ${e.message} --\u003e\&quot;\n        }\n    }\n    return html\n}\n\nfun convertTableToHtmlExact(table: XWPFTable): String {\n    val html \u003d StringBuilder(\&quot;\u003ctable\u003e\&quot;)\n    for (row in table.rows) {\n        html.append(\&quot;\u003ctr\u003e\&quot;)\n        for (cell in row.tableCells) {\n            html.append(\&quot;\u003ctd\u003e\&quot;)\n            cell.bodyElements.forEach { element -\u003e\n                when (element) {\n                    is XWPFParagraph -\u003e html.append(convertParagraphToHtmlExact(element))\n                    is XWPFTable -\u003e html.append(convertTableToHtmlExact(element))\n                }\n            }\n            html.append(\&quot;\u003c/td\u003e\&quot;)\n        }\n        html.append(\&quot;\u003c/tr\u003e\&quot;)\n    }\n    html.append(\&quot;\u003c/table\u003e\&quot;)\n    return html.toString()\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// ENHANCED HTML -\u003e DOCX CONVERSION WITH FULL FORMATTING SUPPORT\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nsuspend fun writeHtmlToDocx(context: Context, uri: Uri, htmlContent: String): Result\u003cUnit\u003e {\n    Logger.d(\&quot;Starting enhanced writeHtmlToDocx for $uri\&quot;)\n    return withContext(Dispatchers.IO) {\n        runCatching {\n            // First, try to preserve the original document structure by reading the existing file\n            val originalDocument \u003d try {\n                context.contentResolver.openInputStream(uri)?.use { inputStream -\u003e\n                    val doc \u003d XWPFDocument(inputStream)\n                    // Create a copy of the document structure\n                    val newDoc \u003d XWPFDocument()\n\n                    // Copy document properties\n                    try {\n                        // Document properties are often read-only, so we skip copying them\n                        Logger.d(\&quot;Skipping document properties copying - not supported\&quot;)\n                    } catch (e: Exception) {\n                        Logger.w(\&quot;Could not copy document properties: ${e.message}\&quot;)\n                    }\n\n                    doc.close()\n                    newDoc\n                }\n            } catch (e: Exception) {\n                Logger.w(\&quot;Could not read original document, creating new one: ${e.message}\&quot;)\n                null\n            }\n\n            val document \u003d originalDocument ?: XWPFDocument()\n\n            try {\n                val rawHtml \u003d cleanHtmlContent(htmlContent)\n                Logger.d(\&quot;Cleaned HTML (first 500 chars): ${rawHtml.take(500)}\&quot;)\n\n                val jsoupDoc \u003d Jsoup.parse(rawHtml)\n\n                // Set document defaults to ensure proper DOCX structure\n                setDocumentDefaults(document)\n\n                // Clear existing content while preserving document structure\n                clearDocumentContent(document)\n\n                val body \u003d jsoupDoc.body()\n                val docContext \u003d DocumentContext()\n\n                // Parse with enhanced processor\n                parseEnhancedJsoupNode(body, document, null, context, docContext)\n\n                // Remove empty first paragraph if exists\n                removeEmptyFirstParagraph(document)\n\n                // Ensure document has at least one paragraph (required for valid DOCX)\n                ensureMinimumContent(document)\n\n                // Write to temporary buffer first to validate\n                val tempBuffer \u003d ByteArrayOutputStream()\n                document.write(tempBuffer)\n\n                // If successful, write to actual file\n                context.contentResolver.openOutputStream(uri, \&quot;wt\&quot;)?.use { outputStream -\u003e\n                    outputStream.write(tempBuffer.toByteArray())\n                    outputStream.flush()\n                } ?: throw IOException(\&quot;Unable to open output stream for $uri\&quot;)\n\n                document.close()\n                Logger.i(\&quot;DOCX saved successfully to $uri with enhanced formatting\&quot;)\n            } catch (e: Exception) {\n                document.close()\n                throw e\n            }\n        }.onFailure { e -\u003e\n            Logger.e(\&quot;Error in enhanced writeHtmlToDocx: ${e.message}\&quot;, e)\n        }\n    }\n}\n\n// Clear document content while preserving structure\nprivate fun clearDocumentContent(document: XWPFDocument) {\n    try {\n        // Remove all body elements\n        val bodyElements \u003d document.bodyElements.toList()\n        bodyElements.forEachIndexed { index, _ -\u003e\n            if (document.bodyElements.isNotEmpty()) {\n                document.removeBodyElement(0)\n            }\n        }\n    } catch (e: Exception) {\n        Logger.w(\&quot;Failed to clear document content: ${e.message}\&quot;)\n    }\n}\n\n// Ensure document has minimum required content\nprivate fun ensureMinimumContent(document: XWPFDocument) {\n    if (document.bodyElements.isEmpty()) {\n        val paragraph \u003d document.createParagraph()\n        val run \u003d paragraph.createRun()\n        run.setText(\&quot; \&quot;) // Add a space to ensure the paragraph is not completely empty\n    }\n}\n\n// Clean HTML content\nprivate fun cleanHtmlContent(htmlContent: String): String {\n    var cleaned \u003d htmlContent\n\n    // Remove JSON escaping if present\n    if (cleaned.startsWith(\&quot;\\\&quot;\&quot;) \u0026\u0026 cleaned.endsWith(\&quot;\\\&quot;\&quot;)) {\n        cleaned \u003d cleaned.substring(1, cleaned.length - 1)\n    }\n\n    cleaned \u003d cleaned\n        .replace(\&quot;\\\\u003C\&quot;, \&quot;\u003c\&quot;)\n        .replace(\&quot;\\\\u003E\&quot;, \&quot;\u003e\&quot;)\n        .replace(\&quot;\\\\\\\&quot;\&quot;, \&quot;\\\&quot;\&quot;)\n        .replace(\&quot;\\\\n\&quot;, \&quot;\\n\&quot;)\n        .replace(\&quot;\\\\t\&quot;, \&quot;\\t\&quot;)\n        .replace(\&quot;\\\\r\&quot;, \&quot;\\r\&quot;)\n        .replace(\&quot;\u0026nbsp;\&quot;, \&quot; \&quot;)\n        .replace(\&quot;\\\\\\\\\&quot;, \&quot;\\\\\&quot;)\n\n    // Remove script tags and their content\n    cleaned \u003d cleaned.replace(Regex(\&quot;\u003cscript[^\u003e]*\u003e.*?\u003c/script\u003e\&quot;, RegexOption.DOT_MATCHES_ALL), \&quot;\&quot;)\n\n    // Remove style tags but keep the content structure\n    cleaned \u003d cleaned.replace(Regex(\&quot;\u003cstyle[^\u003e]*\u003e.*?\u003c/style\u003e\&quot;, RegexOption.DOT_MATCHES_ALL), \&quot;\&quot;)\n\n    // Clean up page containers but preserve content\n    cleaned \u003d cleaned.replace(Regex(\&quot;\u003cdiv[^\u003e]*class\u003d[\u0027\\\&quot;]page[\u0027\\\&quot;][^\u003e]*\u003e\&quot;), \&quot;\u003cdiv\u003e\&quot;)\n\n    return cleaned\n}\n\n// Set document defaults with proper validation\nprivate fun setDocumentDefaults(document: XWPFDocument) {\n    try {\n        val ctDocument \u003d document.document\n        if (ctDocument \u003d\u003d null) {\n            Logger.w(\&quot;Document CTDocument is null, cannot set defaults\&quot;)\n            return\n        }\n\n        val ctBody \u003d ctDocument.body\n        if (ctBody \u003d\u003d null) {\n            Logger.w(\&quot;Document body is null, cannot set defaults\&quot;)\n            return\n        }\n\n        val sectPr \u003d if (ctBody.isSetSectPr) ctBody.sectPr else ctBody.addNewSectPr()\n\n        // Set page size to A4 (210mm x 297mm \u003d 11906 twips x 16838 twips)\n        val pgSz \u003d if (sectPr.isSetPgSz) sectPr.pgSz else sectPr.addNewPgSz()\n        pgSz.w \u003d BigInteger.valueOf(11906) // A4 width in twips\n        pgSz.h \u003d BigInteger.valueOf(16838) // A4 height in twips\n\n        // Set margins (2.54cm \u003d 1440 twips)\n        val pgMar \u003d if (sectPr.isSetPgMar) sectPr.pgMar else sectPr.addNewPgMar()\n        pgMar.top \u003d BigInteger.valueOf(1440)    // 2.54cm\n        pgMar.bottom \u003d BigInteger.valueOf(1440) // 2.54cm\n        pgMar.left \u003d BigInteger.valueOf(1440)   // 2.54cm\n        pgMar.right \u003d BigInteger.valueOf(1440)  // 2.54cm\n\n        // Set default font for the document\n\n    } catch (e: Exception) {\n        Logger.w(\&quot;Failed to set document defaults: ${e.message}\&quot;)\n    }\n}\n\n// Remove empty first paragraph\nprivate fun removeEmptyFirstParagraph(document: XWPFDocument) {\n    if (document.paragraphs.isNotEmpty()) {\n        val firstPara \u003d document.paragraphs[0]\n        if (firstPara.text.isBlank() \u0026\u0026 firstPara.runs.isEmpty()) {\n            if (document.bodyElements.size \u003e 0) {\n                document.removeBodyElement(0)\n            }\n        }\n    }\n}\n\n// Document context\ndata class DocumentContext(\n    var currentListLevel: Int \u003d 0,\n    var isInList: Boolean \u003d false,\n    var currentListType: ListType \u003d ListType.BULLET,\n    var preserveSpacing: Boolean \u003d true,\n    var numberingMap: MutableMap\u003cString, Int\u003e \u003d mutableMapOf()\n)\n\nenum class ListType {\n    BULLET, NUMBERED\n}\n\n// Enhanced HTML node parser with full formatting support\nprivate fun parseEnhancedJsoupNode(\n    jsoupNode: Node,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    context: Context,\n    docContext: DocumentContext\n): XWPFParagraph? {\n    var paragraph \u003d currentParagraph\n\n    when (jsoupNode) {\n        is TextNode -\u003e {\n            val text \u003d jsoupNode.text().replace(\&quot;\\u00A0\&quot;, \&quot; \&quot;)\n            if (text.isNotEmpty() || docContext.preserveSpacing) {\n                paragraph \u003d paragraph ?: document.createParagraph()\n                val run \u003d paragraph.createRun()\n                run.setText(text)\n            }\n        }\n\n        is Element -\u003e {\n            val tagName \u003d jsoupNode.tagName().lowercase()\n\n            paragraph \u003d when (tagName) {\n                // Block elements\n                \&quot;p\&quot;, \&quot;div\&quot; -\u003e handleParagraphElement(jsoupNode, document, docContext, context)\n                \&quot;br\&quot; -\u003e handleLineBreak(document, paragraph)\n\n                // Headings\n                \&quot;h1\&quot;, \&quot;h2\&quot;, \&quot;h3\&quot;, \&quot;h4\&quot;, \&quot;h5\&quot;, \&quot;h6\&quot; -\u003e handleHeading(jsoupNode, document, tagName, docContext, context)\n\n                // Lists\n                \&quot;ul\&quot; -\u003e handleUnorderedList(jsoupNode, document, docContext, context)\n                \&quot;ol\&quot; -\u003e handleOrderedList(jsoupNode, document, docContext, context)\n                \&quot;li\&quot; -\u003e handleListItem(jsoupNode, document, paragraph, docContext, context)\n\n                // Tables\n                \&quot;table\&quot; -\u003e {\n                    handleTable(jsoupNode, document, context, docContext)\n                    null\n                }\n\n                // Inline formatting\n                \&quot;span\&quot;, \&quot;strong\&quot;, \&quot;b\&quot;, \&quot;em\&quot;, \&quot;i\&quot;, \&quot;u\&quot;, \&quot;s\&quot;, \&quot;strike\&quot;, \&quot;del\&quot;,\n                \&quot;sub\&quot;, \&quot;sup\&quot;, \&quot;code\&quot;, \&quot;mark\&quot; -\u003e handleInlineFormatting(jsoupNode, document, paragraph, docContext, context)\n\n                // Images\n                \&quot;img\&quot; -\u003e {\n                    handleImage(jsoupNode, document, context)\n                    null\n                }\n\n                // Blockquote\n                \&quot;blockquote\&quot; -\u003e handleBlockquote(jsoupNode, document, docContext, context)\n\n                // Horizontal rule\n                \&quot;hr\&quot; -\u003e {\n                    handleHorizontalRule(document)\n                    null\n                }\n\n                else -\u003e {\n                    // For unknown elements, process children\n                    for (child in jsoupNode.childNodes()) {\n                        paragraph \u003d parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n                    }\n                    paragraph\n                }\n            }\n        }\n    }\n\n    return paragraph\n}\n\n// Handle paragraph element\nprivate fun handleParagraphElement(\n    element: Element,\n    document: XWPFDocument,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph {\n    val paragraph \u003d document.createParagraph()\n    applyParagraphStyle(paragraph, element)\n\n    for (child in element.childNodes()) {\n        parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n    }\n\n    return paragraph\n}\n\n// Handle line break\nprivate fun handleLineBreak(document: XWPFDocument, currentParagraph: XWPFParagraph?): XWPFParagraph {\n    val paragraph \u003d currentParagraph ?: document.createParagraph()\n    val run \u003d paragraph.createRun()\n    run.addBreak()\n    return paragraph\n}\n\n// Handle headings\nprivate fun handleHeading(\n    element: Element,\n    document: XWPFDocument,\n    tagName: String,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph {\n    val paragraph \u003d document.createParagraph()\n    val level \u003d tagName.substring(1).toIntOrNull() ?: 1\n\n    val fontSize \u003d when (level) {\n        1 -\u003e 22\n        2 -\u003e 18\n        3 -\u003e 16\n        4 -\u003e 14\n        5 -\u003e 12\n        else -\u003e 10\n    }\n\n    applyParagraphStyle(paragraph, element)\n\n    for (child in element.childNodes()) {\n        parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n    }\n\n    // Apply heading formatting to all runs\n    paragraph.runs.forEach { run -\u003e\n        run.isBold \u003d true\n        if (run.fontSize \u003c\u003d 0) {\n            run.fontSize \u003d fontSize\n        }\n    }\n\n    return paragraph\n}\n\n// Handle unordered list\nprivate fun handleUnorderedList(\n    element: Element,\n    document: XWPFDocument,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph? {\n    val previousContext \u003d docContext.copy()\n    docContext.isInList \u003d true\n    docContext.currentListType \u003d ListType.BULLET\n    docContext.currentListLevel++\n\n    var lastParagraph: XWPFParagraph? \u003d null\n    for (child in element.children()) {\n        if (child.tagName().equals(\&quot;li\&quot;, ignoreCase \u003d true)) {\n            lastParagraph \u003d handleListItem(child, document, null, docContext, context)\n        }\n    }\n\n    docContext.currentListLevel \u003d previousContext.currentListLevel\n    docContext.isInList \u003d previousContext.isInList\n    docContext.currentListType \u003d previousContext.currentListType\n\n    return lastParagraph\n}\n\n// Handle ordered list\nprivate fun handleOrderedList(\n    element: Element,\n    document: XWPFDocument,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph? {\n    val previousContext \u003d docContext.copy()\n    docContext.isInList \u003d true\n    docContext.currentListType \u003d ListType.NUMBERED\n    docContext.currentListLevel++\n\n    var lastParagraph: XWPFParagraph? \u003d null\n    for (child in element.children()) {\n        if (child.tagName().equals(\&quot;li\&quot;, ignoreCase \u003d true)) {\n            lastParagraph \u003d handleListItem(child, document, null, docContext, context)\n        }\n    }\n\n    docContext.currentListLevel \u003d previousContext.currentListLevel\n    docContext.isInList \u003d previousContext.isInList\n    docContext.currentListType \u003d previousContext.currentListType\n\n    return lastParagraph\n}\n\n// Handle list item\nprivate fun handleListItem(\n    element: Element,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph {\n    val paragraph \u003d document.createParagraph()\n\n    // Set numbering\n    try {\n//        val numId \u003d getOrCreateNumbering(document, docContext)\n//        paragraph.numID \u003d BigInteger.valueOf(numId.toLong())\n//        paragraph.numILvl \u003d BigInteger.valueOf((docContext.currentListLevel - 1).toLong())\n    } catch (e: Exception) {\n        Logger.w(\&quot;Failed to apply numbering: ${e.message}\&quot;)\n        // Fallback: add bullet/number manually\n        val run \u003d paragraph.createRun()\n        run.setText(if (docContext.currentListType \u003d\u003d ListType.BULLET) \&quot; \&quot; else \&quot;${docContext.currentListLevel}. \&quot;)\n    }\n\n    // Set indentation\n    paragraph.indentationLeft \u003d 720 * docContext.currentListLevel\n\n    for (child in element.childNodes()) {\n        parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n    }\n\n    return paragraph\n}\n\n// Get or create numbering\n//private fun getOrCreateNumbering(document: XWPFDocument, docContext: DocumentContext): Int {\n//    val key \u003d \&quot;${docContext.currentListType}_${docContext.currentListLevel}\&quot;\n//\n//    return docContext.numberingMap.getOrPut(key) {\n//        try {\n//            val numbering \u003d document.createNumbering()\n//            val abstractNumId \u003d numbering.addAbstractNum()\n//            numbering.addNum(abstractNumId)\n//        } catch (e: Exception) {\n//            1\n//        }\n//    }\n//}\n\n// Handle table with full formatting\nprivate fun handleTable(\n    element: Element,\n    document: XWPFDocument,\n    context: Context,\n    docContext: DocumentContext\n) {\n    try {\n        val rows \u003d element.select(\&quot;tr\&quot;)\n        if (rows.isEmpty()) return\n\n        val firstRow \u003d rows.first()\n        val columns \u003d firstRow?.select(\&quot;td, th\&quot;)?.size ?: 0\n\n        val table \u003d document.createTable(rows.size, columns)\n\n        // Set table properties\n        table.width \u003d 5000\n\n        rows.forEachIndexed { rowIndex, rowElement -\u003e\n            val tableRow \u003d table.getRow(rowIndex)\n            val cells \u003d rowElement.select(\&quot;td, th\&quot;)\n\n            cells.forEachIndexed { colIndex, cellElement -\u003e\n                if (colIndex \u003c tableRow.tableCells.size) {\n                    val cell \u003d tableRow.getCell(colIndex)\n\n                    // Apply cell styling\n                    applyCellStyle(cell, cellElement)\n\n                    // Clear default paragraph\n                    if (cell.paragraphs.isNotEmpty()) {\n                        cell.removeParagraph(0)\n                    }\n\n                    // Parse cell content directly in the cell context\n                    var cellParagraph: XWPFParagraph? \u003d null\n\n                    for (child in cellElement.childNodes()) {\n                        cellParagraph \u003d parseEnhancedJsoupNodeInCell(\n                            child,\n                            cell,\n                            cellParagraph,\n                            context,\n                            docContext\n                        )\n                    }\n\n                    // Make header cells bold\n                    if (cellElement.tagName().equals(\&quot;th\&quot;, ignoreCase \u003d true)) {\n                        cell.paragraphs.forEach { para -\u003e\n                            para.runs.forEach { run -\u003e\n                                run.isBold \u003d true\n                            }\n                        }\n                    }\n\n                    // Ensure cell has at least one paragraph\n                    if (cell.paragraphs.isEmpty()) {\n                        cell.addParagraph()\n                    }\n                }\n            }\n        }\n    } catch (e: Exception) {\n        Logger.e(\&quot;Error creating table: ${e.message}\&quot;, e)\n    }\n}\n\n// Enhanced HTML node parser specifically for table cells to handle images correctly\nprivate fun parseEnhancedJsoupNodeInCell(\n    jsoupNode: Node,\n    cell: XWPFTableCell,\n    currentParagraph: XWPFParagraph?,\n    context: Context,\n    docContext: DocumentContext\n): XWPFParagraph? {\n    var paragraph \u003d currentParagraph\n\n    when (jsoupNode) {\n        is TextNode -\u003e {\n            val text \u003d jsoupNode.text().replace(\&quot;\\u00A0\&quot;, \&quot; \&quot;)\n            if (text.isNotEmpty() || docContext.preserveSpacing) {\n                paragraph \u003d paragraph ?: cell.addParagraph()\n                val run \u003d paragraph.createRun()\n                run.setText(text)\n            }\n        }\n\n        is Element -\u003e {\n            val tagName \u003d jsoupNode.tagName().lowercase()\n\n            paragraph \u003d when (tagName) {\n                // Block elements\n                \&quot;p\&quot;, \&quot;div\&quot; -\u003e {\n                    val newParagraph \u003d cell.addParagraph()\n                    applyParagraphStyle(newParagraph, jsoupNode)\n\n                    for (child in jsoupNode.childNodes()) {\n                        paragraph \u003d parseEnhancedJsoupNodeInCell(\n                            child,\n                            cell,\n                            newParagraph,\n                            context,\n                            docContext\n                        )\n                    }\n                    newParagraph\n                }\n\n                \&quot;br\&quot; -\u003e {\n                    val para \u003d paragraph ?: cell.addParagraph()\n                    val run \u003d para.createRun()\n                    run.addBreak()\n                    para\n                }\n\n                // Images - handle directly in cell\n                \&quot;img\&quot; -\u003e {\n                    val imagePara \u003d paragraph ?: cell.addParagraph()\n                    handleImageInCell(jsoupNode, imagePara, context)\n                    imagePara\n                }\n\n                // Inline formatting\n                \&quot;span\&quot;, \&quot;strong\&quot;, \&quot;b\&quot;, \&quot;em\&quot;, \&quot;i\&quot;, \&quot;u\&quot;, \&quot;s\&quot;, \&quot;strike\&quot;, \&quot;del\&quot;,\n                \&quot;sub\&quot;, \&quot;sup\&quot;, \&quot;code\&quot;, \&quot;mark\&quot; -\u003e {\n                    val para \u003d paragraph ?: cell.addParagraph()\n\n                    for (child in jsoupNode.childNodes()) {\n                        when (child) {\n                            is TextNode -\u003e {\n                                val run \u003d para.createRun()\n                                run.setText(child.text())\n                                applyRunFormatting(run, jsoupNode)\n                            }\n\n                            is Element -\u003e {\n                                paragraph \u003d parseEnhancedJsoupNodeInCell(\n                                    child,\n                                    cell,\n                                    para,\n                                    context,\n                                    docContext\n                                )\n                            }\n                        }\n                    }\n                    para\n                }\n\n                else -\u003e {\n                    // For unknown elements, process children\n                    for (child in jsoupNode.childNodes()) {\n                        paragraph \u003d parseEnhancedJsoupNodeInCell(\n                            child,\n                            cell,\n                            paragraph,\n                            context,\n                            docContext\n                        )\n                    }\n                    paragraph\n                }\n            }\n        }\n    }\n\n    return paragraph\n}\n\n// Handle image specifically within a table cell paragraph\nprivate fun handleImageInCell(element: Element, paragraph: XWPFParagraph, context: Context) {\n    try {\n        val src \u003d element.attr(\&quot;src\&quot;)\n\n        if (src.startsWith(\&quot;data:image\&quot;)) {\n            val parts \u003d src.split(\&quot;,\&quot;)\n            if (parts.size \u003d\u003d 2) {\n                val meta \u003d parts[0]\n                val base64Data \u003d parts[1]\n                val decodedData \u003d Base64.decode(base64Data, Base64.DEFAULT)\n\n                val pictureType \u003d when {\n                    meta.contains(\&quot;jpeg\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_JPEG\n                    meta.contains(\&quot;png\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                    meta.contains(\&quot;gif\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_GIF\n                    meta.contains(\&quot;bmp\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_BMP\n                    meta.contains(\&quot;tiff\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_TIFF\n                    else -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                }\n\n                val widthPx \u003d element.attr(\&quot;width\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 200\n                val heightPx \u003d element.attr(\&quot;height\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 150\n                val widthEmu \u003d widthPx * Units.EMU_PER_PIXEL\n                val heightEmu \u003d heightPx * Units.EMU_PER_PIXEL\n\n                paragraph.createRun().addPicture(\n                    ByteArrayInputStream(decodedData),\n                    pictureType,\n                    \&quot;image.dat\&quot;,\n                    widthEmu,\n                    heightEmu\n                )\n            }\n        }\n    } catch (e: Exception) {\n        Logger.e(\&quot;Error processing image in cell: ${e.message}\&quot;, e)\n    }\n}\n\n// Handle inline formatting\nprivate fun handleInlineFormatting(\n    element: Element,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph {\n    val paragraph \u003d currentParagraph ?: document.createParagraph()\n\n    for (child in element.childNodes()) {\n        when (child) {\n            is TextNode -\u003e {\n                val run \u003d paragraph.createRun()\n                run.setText(child.text())\n                applyRunFormatting(run, element)\n            }\n            is Element -\u003e {\n                parseEnhancedJsoupNode(child, document, paragraph, context, docContext)\n            }\n        }\n    }\n\n    // Apply formatting to runs that were just created\n    val tagName \u003d element.tagName().lowercase()\n    if (tagName in listOf(\&quot;span\&quot;, \&quot;strong\&quot;, \&quot;b\&quot;, \&quot;em\&quot;, \&quot;i\&quot;, \&quot;u\&quot;, \&quot;s\&quot;, \&quot;strike\&quot;, \&quot;del\&quot;, \&quot;sub\&quot;, \&quot;sup\&quot;, \&quot;code\&quot;, \&quot;mark\&quot;)) {\n        // Get recently created runs for this element\n        val recentRunCount \u003d element.childNodes().filterIsInstance\u003cTextNode\u003e().size\n        if (recentRunCount \u003e 0 \u0026\u0026 paragraph.runs.size \u003e\u003d recentRunCount) {\n            val runsToFormat \u003d paragraph.runs.takeLast(recentRunCount)\n            runsToFormat.forEach { run -\u003e\n                applyRunFormatting(run, element)\n            }\n        }\n    }\n\n    return paragraph\n}\n\n// Apply run formatting\nprivate fun applyRunFormatting(run: XWPFRun, element: Element) {\n    val tagName \u003d element.tagName().lowercase()\n    val style \u003d element.attr(\&quot;style\&quot;)\n\n    when (tagName) {\n        \&quot;strong\&quot;, \&quot;b\&quot; -\u003e run.isBold \u003d true\n        \&quot;em\&quot;, \&quot;i\&quot; -\u003e run.isItalic \u003d true\n        \&quot;u\&quot; -\u003e run.underline \u003d UnderlinePatterns.SINGLE\n        \&quot;s\&quot;, \&quot;strike\&quot;, \&quot;del\&quot; -\u003e run.isStrikeThrough \u003d true\n//        \&quot;sub\&quot; -\u003e run.subscript \u003d VerticalAlign.SUBSCRIPT\n//        \&quot;sup\&quot; -\u003e run.subscript \u003d VerticalAlign.SUPERSCRIPT\n        \&quot;code\&quot; -\u003e {\n            run.fontFamily \u003d \&quot;Courier New\&quot;\n            if (run.fontSize \u003c\u003d 0) run.fontSize \u003d 10\n        }\n        \&quot;mark\&quot; -\u003e {\n            try {\n                run.setTextHighlightColor(\&quot;yellow\&quot;)\n            } catch (e: Exception) {\n                Logger.w(\&quot;Failed to set highlight: ${e.message}\&quot;)\n            }\n        }\n    }\n\n    // Parse inline styles\n    if (style.isNotBlank()) {\n        applyInlineStyle(run, style)\n    }\n\n    // Apply color attribute\n    val color \u003d element.attr(\&quot;color\&quot;)\n    if (color.isNotBlank()) {\n        run.color \u003d color.replace(\&quot;#\&quot;, \&quot;\&quot;)\n    }\n}\n\n// Apply inline CSS styles\nprivate fun applyInlineStyle(run: XWPFRun, style: String) {\n    val styles \u003d style.split(\&quot;;\&quot;).associate {\n        val parts \u003d it.split(\&quot;:\&quot;)\n        if (parts.size \u003d\u003d 2) {\n            parts[0].trim().lowercase() to parts[1].trim()\n        } else {\n            \&quot;\&quot; to \&quot;\&quot;\n        }\n    }\n\n    styles[\&quot;font-weight\&quot;]?.let {\n        if (it.contains(\&quot;bold\&quot;, ignoreCase \u003d true) || it.toIntOrNull()?.let { w -\u003e w \u003e\u003d 600 } \u003d\u003d true) {\n            run.isBold \u003d true\n        }\n    }\n\n    styles[\&quot;font-style\&quot;]?.let {\n        if (it.contains(\&quot;italic\&quot;, ignoreCase \u003d true)) {\n            run.isItalic \u003d true\n        }\n    }\n\n    styles[\&quot;text-decoration\&quot;]?.let {\n        when {\n            it.contains(\&quot;underline\&quot;, ignoreCase \u003d true) -\u003e run.underline \u003d UnderlinePatterns.SINGLE\n            it.contains(\&quot;line-through\&quot;, ignoreCase \u003d true) -\u003e run.isStrikeThrough \u003d true\n        }\n    }\n\n    styles[\&quot;font-size\&quot;]?.let {\n        val size \u003d when {\n            it.endsWith(\&quot;pt\&quot;) -\u003e it.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.toInt()\n            it.endsWith(\&quot;px\&quot;) -\u003e (it.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(0.75))?.toInt()\n            else -\u003e null\n        }\n        size?.let { s -\u003e run.fontSize \u003d s }\n    }\n\n    styles[\&quot;font-family\&quot;]?.let {\n        run.fontFamily \u003d it.replace(\&quot;\u0027\&quot;, \&quot;\&quot;).replace(\&quot;\\\&quot;\&quot;, \&quot;\&quot;).split(\&quot;,\&quot;)[0].trim()\n    }\n\n    styles[\&quot;color\&quot;]?.let {\n        val colorValue \u003d it.replace(\&quot;#\&quot;, \&quot;\&quot;).trim()\n        if (colorValue.length \u003d\u003d 6 || colorValue.length \u003d\u003d 3) {\n            run.color \u003d colorValue\n        }\n    }\n}\n\n// Handle image\nprivate fun handleImage(element: Element, document: XWPFDocument, context: Context) {\n    try {\n        val src \u003d element.attr(\&quot;src\&quot;)\n\n        if (src.startsWith(\&quot;data:image\&quot;)) {\n            val parts \u003d src.split(\&quot;,\&quot;)\n            if (parts.size \u003d\u003d 2) {\n                val meta \u003d parts[0]\n                val base64Data \u003d parts[1]\n                val decodedData \u003d Base64.decode(base64Data, Base64.DEFAULT)\n\n                val pictureType \u003d when {\n                    meta.contains(\&quot;jpeg\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_JPEG\n                    meta.contains(\&quot;png\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                    meta.contains(\&quot;gif\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_GIF\n                    meta.contains(\&quot;bmp\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_BMP\n                    meta.contains(\&quot;tiff\&quot;) -\u003e XWPFDocument.PICTURE_TYPE_TIFF\n                    else -\u003e XWPFDocument.PICTURE_TYPE_PNG\n                }\n\n                val widthPx \u003d element.attr(\&quot;width\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 200\n                val heightPx \u003d element.attr(\&quot;height\&quot;).removeSuffix(\&quot;px\&quot;).toIntOrNull() ?: 150\n                val widthEmu \u003d widthPx * Units.EMU_PER_PIXEL\n                val heightEmu \u003d heightPx * Units.EMU_PER_PIXEL\n\n                val imageParagraph \u003d document.createParagraph()\n                imageParagraph.createRun().addPicture(\n                    ByteArrayInputStream(decodedData),\n                    pictureType,\n                    \&quot;image.dat\&quot;,\n                    widthEmu,\n                    heightEmu\n                )\n            }\n        }\n    } catch (e: Exception) {\n        Logger.e(\&quot;Error processing image: ${e.message}\&quot;, e)\n    }\n}\n\n// Handle blockquote\nprivate fun handleBlockquote(\n    element: Element,\n    document: XWPFDocument,\n    docContext: DocumentContext,\n    context: Context\n): XWPFParagraph? {\n    var lastParagraph: XWPFParagraph? \u003d null\n\n    for (child in element.childNodes()) {\n        lastParagraph \u003d parseEnhancedJsoupNode(child, document, lastParagraph, context, docContext)\n        lastParagraph?.let { para -\u003e\n            para.indentationLeft \u003d 720 // Indent blockquote\n            para.borderLeft \u003d Borders.SINGLE\n        }\n    }\n\n    return lastParagraph\n}\n\n// Handle horizontal rule\nprivate fun handleHorizontalRule(document: XWPFDocument): XWPFParagraph {\n    val paragraph \u003d document.createParagraph()\n    paragraph.borderBottom \u003d Borders.SINGLE\n    return paragraph\n}\n\n// Apply paragraph style from HTML element\nprivate fun applyParagraphStyle(paragraph: XWPFParagraph, element: Element) {\n    val style \u003d element.attr(\&quot;style\&quot;)\n\n    if (style.isNotBlank()) {\n        val styles \u003d style.split(\&quot;;\&quot;).associate {\n            val parts \u003d it.split(\&quot;:\&quot;)\n            if (parts.size \u003d\u003d 2) {\n                parts[0].trim().lowercase() to parts[1].trim()\n            } else {\n                \&quot;\&quot; to \&quot;\&quot;\n            }\n        }\n\n        styles[\&quot;text-align\&quot;]?.let {\n            paragraph.alignment \u003d when (it.lowercase()) {\n                \&quot;center\&quot; -\u003e ParagraphAlignment.CENTER\n                \&quot;right\&quot; -\u003e ParagraphAlignment.RIGHT\n                \&quot;justify\&quot; -\u003e ParagraphAlignment.BOTH\n                \&quot;left\&quot; -\u003e ParagraphAlignment.LEFT\n                else -\u003e paragraph.alignment\n            }\n        }\n\n        styles[\&quot;margin-top\&quot;]?.let {\n            val spacing \u003d when {\n                it.endsWith(\&quot;pt\&quot;) -\u003e it.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20)?.toInt()\n                it.endsWith(\&quot;px\&quot;) -\u003e it.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(15)?.toInt()\n                else -\u003e null\n            }\n            spacing?.let { s -\u003e paragraph.spacingBefore \u003d s }\n        }\n\n        styles[\&quot;margin-bottom\&quot;]?.let {\n            val spacing \u003d when {\n                it.endsWith(\&quot;pt\&quot;) -\u003e it.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20)?.toInt()\n                it.endsWith(\&quot;px\&quot;) -\u003e it.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(15)?.toInt()\n                else -\u003e null\n            }\n            spacing?.let { s -\u003e paragraph.spacingAfter \u003d s }\n        }\n\n        styles[\&quot;line-height\&quot;]?.let {\n            val lineHeightValue \u003d it.toDoubleOrNull()\n            lineHeightValue?.let { lh -\u003e\n                paragraph.setSpacingBetween(lh * 240, LineSpacingRule.AUTO)\n            }\n        }\n    }\n\n    // Apply alignment from attribute\n    val align \u003d element.attr(\&quot;align\&quot;)\n    if (align.isNotBlank()) {\n        paragraph.alignment \u003d when (align.lowercase()) {\n            \&quot;center\&quot; -\u003e ParagraphAlignment.CENTER\n            \&quot;right\&quot; -\u003e ParagraphAlignment.RIGHT\n            \&quot;justify\&quot; -\u003e ParagraphAlignment.BOTH\n            \&quot;left\&quot; -\u003e ParagraphAlignment.LEFT\n            else -\u003e paragraph.alignment\n        }\n    }\n}\n\n// Apply cell style\nprivate fun applyCellStyle(cell: XWPFTableCell, element: Element) {\n    try {\n        // Background color\n        val bgColor \u003d element.attr(\&quot;bgcolor\&quot;)\n        if (bgColor.isNotBlank()) {\n            cell.color \u003d bgColor.replace(\&quot;#\&quot;, \&quot;\&quot;)\n        }\n\n        // Parse style attribute for background color\n        val style \u003d element.attr(\&quot;style\&quot;)\n        if (style.contains(\&quot;background-color\&quot;)) {\n            val bgMatch \u003d Regex(\&quot;background-color:\\\\s*#?([0-9A-Fa-f]{6})\&quot;).find(style)\n            bgMatch?.let {\n                cell.color \u003d it.groupValues[1]\n            }\n        }\n\n        // Set cell margins\n        val ctTc \u003d cell.ctTc\n        val tcPr \u003d ctTc.tcPr ?: ctTc.addNewTcPr()\n        val tcMar \u003d tcPr.tcMar ?: tcPr.addNewTcMar()\n\n        tcMar.left \u003d CTTblWidth.Factory.newInstance().apply {\n            w \u003d BigInteger.valueOf(100)\n            type \u003d STTblWidth.DXA\n        }\n        tcMar.right \u003d CTTblWidth.Factory.newInstance().apply {\n            w \u003d BigInteger.valueOf(100)\n            type \u003d STTblWidth.DXA\n        }\n    } catch (e: Exception) {\n        Logger.w(\&quot;Failed to apply cell style: ${e.message}\&quot;)\n    }\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// LEGACY FUNCTIONS (Keep for backward compatibility)\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nprivate fun parseJsoupNode(\n    jsoupNode: Node,\n    document: XWPFDocument,\n    currentParagraph: XWPFParagraph?,\n    context: Context\n) {\n    // Use enhanced parser\n    val docContext \u003d DocumentContext()\n    parseEnhancedJsoupNode(jsoupNode, document, currentParagraph, context, docContext)\n}\n\nprivate fun applyParagraphAlignment(element: Element, paragraph: XWPFParagraph?) {\n    if (paragraph \u003d\u003d null) return\n    applyParagraphStyle(paragraph, element)\n}\n\nfun parseStyleAndApply(styleAttribute: String, paragraph: XWPFParagraph?, run: XWPFRun?) {\n    if (run \u003d\u003d null \u0026\u0026 paragraph \u003d\u003d null) return\n\n    styleAttribute.split(\u0027;\u0027).map { it.trim() }.filter { it.isNotEmpty() }.forEach { style -\u003e\n        val parts \u003d style.split(\u0027:\u0027).map { it.trim() }\n        if (parts.size \u003d\u003d 2) {\n            val property \u003d parts[0].lowercase()\n            val value \u003d parts[1]\n            try {\n                when (property) {\n                    // Run-specific styles\n                    \&quot;color\&quot; -\u003e if (value.startsWith(\&quot;#\&quot;) \u0026\u0026 (value.length \u003d\u003d 7 || value.length \u003d\u003d 4)) {\n                        run?.setColor(value.removePrefix(\&quot;#\&quot;))\n                    }\n                    \&quot;font-weight\&quot; -\u003e if (value \u003d\u003d \&quot;bold\&quot; || (value.toIntOrNull() ?: 400) \u003e\u003d 600) {\n                        run?.isBold \u003d true\n                    }\n                    \&quot;font-style\&quot; -\u003e if (value \u003d\u003d \&quot;italic\&quot;) {\n                        run?.isItalic \u003d true\n                    }\n                    \&quot;font-size\&quot; -\u003e {\n                        val size \u003d when {\n                            value.endsWith(\&quot;pt\&quot;) -\u003e value.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.toInt()\n                            value.endsWith(\&quot;px\&quot;) -\u003e (value.removeSuffix(\&quot;px\&quot;).toDoubleOrNull()?.times(0.75))?.toInt()\n                            else -\u003e null\n                        }\n                        if (size !\u003d null) run?.fontSize \u003d size\n                    }\n                    \&quot;font-family\&quot; -\u003e run?.fontFamily \u003d value.replace(\&quot;\\\u0027\&quot;, \&quot;\&quot;).split(\&quot;,\&quot;)[0].trim()\n                    \&quot;text-decoration\&quot;, \&quot;text-decoration-line\&quot; -\u003e {\n                        if (value.contains(\&quot;underline\&quot;)) run?.underline \u003d UnderlinePatterns.SINGLE\n                        if (value.contains(\&quot;line-through\&quot;)) run?.isStrikeThrough \u003d true\n                    }\n                    // Paragraph-specific styles\n                    \&quot;margin-top\&quot; -\u003e {\n                        if (paragraph !\u003d null \u0026\u0026 value.endsWith(\&quot;pt\&quot;)) {\n                            paragraph.spacingBefore \u003d (value.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20))?.toInt() ?: paragraph.spacingBefore\n                        }\n                    }\n                    \&quot;margin-bottom\&quot; -\u003e {\n                        if (paragraph !\u003d null \u0026\u0026 value.endsWith(\&quot;pt\&quot;)) {\n                            paragraph.spacingAfter \u003d (value.removeSuffix(\&quot;pt\&quot;).toDoubleOrNull()?.times(20))?.toInt() ?: paragraph.spacingAfter\n                        }\n                    }\n                    \&quot;line-height\&quot; -\u003e {\n                        if (paragraph !\u003d null) {\n                            val lineHeightValue \u003d value.toDoubleOrNull()\n                            if (lineHeightValue !\u003d null) {\n                                paragraph.setSpacingBetween(lineHeightValue * 240, LineSpacingRule.AUTO)\n                            }\n                        }\n                    }\n                }\n            } catch (e: Exception) {\n                Logger.w(\&quot;Failed to parse style: $property \u003d $value. Error: ${e.message}\&quot;)\n            }\n        }\n    }\n}&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;thinking&quot;,&quot;thinking&quot;:&quot;gAAAAABo31xJnSIs_kDXa4cfUa6JBuPm7-iHQOMrekQ_5aTnuI9HRFDwjkbEiHVnqWgICGyp_xLg1WSXJFVqO7N4IF6MBXa0T-XQOBk1jI_66ECpAIW6ZWbWFrX8wTE-zuoIg5WyCyfLnn2UmgXV1zDatreG2b--uGr51vH2HlJ2zo8wgBMhUgpBpSqnHEKxqv4aiJejFwYaOCDN5nUAaNvO4HKbx0dXICCV4yQWFP0Kwk5yDQ78xPjfvmUXFbbmploC4Oyp8ydcS5nKgzas8cosctI-EVz019i0CRJvuoAA9S8_yDcYDn1-JDzfsxn72zSjwYIiB41YsuL7vNNNWTi475DMDA42l-0bG1wegud_jt1FLphWAmUbdLhLRKfhLC_c3dX477dUEk6ZoYYOkd8X3QGybD-NPNIteBoSWQz9qyNJVzYTLxqPOsyib7LvUKkKvJSh8yGyqYTC-fsqq8C5EVJoWmnAbxPDBeZFPsezHV_6sBDiILE3lZxYP3r7Ymqz1MOED1N_f9WED_noCdDkBGxrDZ6J0eAC8RAEOT92Qo2HzsHxG0urtxo511-Z41UiKhfy9zyd5pgZXRpjD_ckrsgjsZq1HRb8htAi1k2HNuU5JIO-6zvJwmRS-cR9Yijfl5SXodMiePhyStCLOJfUxs2-D-CpottFC47XdJODJsOD_drGIjL9WB7rC2CkmZlH6Lx6xCo5yKR7NhGGiWQ-5VyqLoUkxuGMuAltBhjTNgaT--if6l3cV84_PPM0_srsWgZuBIjB16TnkVPWj-Q0lrmVfYl9ShBzetWKQghS4Tul5p2oUiOd6FPnUM0Q0mbzVVKVSa19WwmPIwPGhN-Zjy5LuafxjW0QeDDSFeGKE-QduxJnqxtIE-1hdeJ-1ztaCqQ61ghTHix25sv7dz6QOgyCjcfr1DIdwRTSmdPtBniz_3-_xZhBsnb1F_93dTUjtoJoQCNIlFWGFYBT418eybn4UOgjAWiEtg_wg_wnEpDn5DDsuaTKa1Z72Bq7nk076T9Jc2WckOCp0Eoj9kinnVT3oIxhGsU-LZO8Z2WsVyXOP4D9XJjFkrBAfOwMxICBqfjFeBpFkSwzuFKLxtbdopgYRoAMB4Mi-lEm0AhRTdy8hQNk2XtleNFYMS-O_cpGj9CPh021QGewvla_mtKGjAqNdX3yEKg9AyEbjkpQRPW9iZXaiN5KlnlNvS9_BZuAWfF33D5GCh4TUjhg7kCybGEaPheAe8L9mFeAo8WwMdWE7IdmpZZYwpHrvQEZ3YFMIoLCy6zTh9tIqspKND3lHAkF2rWwjYcJVjtKhrTLBUbbfSG0gIULFdkm1-nhr65QVQTKIt7sdz6fVXRccMIwqRj8xsuaCDnq7Xz5cth78IRetOYXh_PZw7n8AyNEGbJ-h_SW5CyiXGHyPhhZ5JM4GlokBbiGDkEn2IVY-nSd8_nrDluh9VPh326hALUGx1Ed70dX3cMO9NvgPlcxwJbfDvVQtg9X9tIGAXydk4JiYSkcLLAyv3c0lDCulmCVqrRJkq2375WTkWvJSzGFZmu_e1V-CL87mWg_0LfLx1txG7wYQttU66N2wC0EuqUe8M7BWVgpm34SdMCy4taViXsDnWikKNEB-YRyqDKkIXwFXcW9uD6dEWhwFWSBo6P3GAFkOfFURud-kSpGlPizKlb0lH9x5NIgdzGr28crJFCmUkcgOQQIC83jN2OByDUtNM8EqKrxN7Sq210V1LtPd2lbYZbA93lCyhefkls8nbTIQGWbXhRyJJ3s1E2VWfD1DcX3AyDx0-gPMtcXOf0c3JimaR7mGNr43NVpisK2g1iEAQBhrrUvfvvwW4jBwQvkWIaE82hjuxoTYZuxEahTD1PYdAuv_FGgd0h-Yr5TGkPUdaKrQN5V-3b11iNM14fwqeNRBEtXQKcAmkiI53lu55tSVBROXx539P7iD1BDrwfaBdUKPcliSH3jXRYwurTrA33xzNC0PufCdLB8-FQnAu0MnAqrt9kU4fnalsMDfZu6t3tC224Ds4QF5Z2FjcTPTmvceLabAIQe4F36VHFnNtMrJ33AVhjdwLQBUec_-QYMp0fWVF7tm4zx7Zd_NhsKcTZjci1QQP6RZaIxkPGhrAQxbwCgrMUEYxh94Nrjl7PlzsYhtBW0KOzopZ-2BBQ8rifkb2jMaMYSgjUI362YuU_D2_E-_-5GS8QcQZUPMtiRktkMoUhlUu58KVNQhrVUEyInZZgBqHWXylFp-t0YKKhIsLb_nMonYmwsCJ1ZLOksqAT5NEKZZQv_DIb96UImnRo4VwitDzfFEPw1u1f0HLYPsbdWHRyWokksr7D7xdVQ8QvTnVuHH9EGQZ3zsUgE_4rAueXcAZGho5pQI5B7IrXZeMu_qOb60x9nJ-9rEnaWxfMLBZIEgWI-U-RAMWxtk1Hv1Som5XdUOcyLuwcEtIqLs3OaEso-UaEWc0_UV1OA485VIAvJwZiVS7TtiMSyz5-EnpVttadThV8d8iEc2vMT6klsbSDseNjHKpHn-AsShxo3rZJ9zoEbrs2QTfilZjDqg0HKST2PbLNhhorvfByt15L3e7COs63N9ekbz_S3BKoaYqFZn4pVequiYM0QnDmf_O0yQg3mMTABxpRpioFlrCwK1G58eQIanB0ZfvhCoqwS4V8X8djcRx7wly-B3AjPXEzhNdcNCoRZowyMDL1kJknLN1vUZeh98ZyivnhwXYloWTSTrQqNr3615YknVId6SfRej_YTp8xMpIV5uOxkD-wTytaIBCMzpW8YOgBxbocjr_P8mOWnhRraz7k61EX8UQs54C8IgQ0St14ezhEwJg7AQPxA7ZAItYrv7MBpQsxvO-q98cFfKF09xZMYzyIMiMix6YxrR5Eyn5HflBewXxtyKghQDwKtcEXuTdmyCWqaUrNY6Uq6DzoX4Q_nNuFt5_F1p8t712xruMG2TzMzHw5OtHN3NynZ8nqhzvSlkk5Devz4nIdgDyS4KkTzL89Vcv4ZgC0-f-xcMp4eUjJjb4Pv1WfHiXfAzd_H-au8fqHUgr_QXru4qJsQEtB_wZsQz8wbl8LfwJReXZpC-YuDwARRvBjm1riXvReroaz0r_2YWxMvrCcGVcdNbTGxmPPYSoGWGarOXtgni52gU1aJPz0aeMWgzPDJMUqcYdhaR0X-YzJ9i1-GMHSLVaouVPC6jWud_YF1uueQpFkGh3ww5Rti2aCoYMYeZ3Bw3WfIMvPt02U4ZGEhbULQ9jbgnfgpX7ymlmtiDk0j5UMMT_tbq4XCQqmFZ5qWlDSIihh-yGztYL_3YAsJUJN3nrSjnKHVRKbrqzqd45gcMI7Jd3kyEkfhHR6dr_6M_R87sGas5tPY2KwRWnT6nq6HIVNXgtOcQJ0ROIkluh34i4i0VGd7lM80VbRX2HM65z6QsYxDWhlhiaH9lN2YP1xE5Qx112WzE9juJydQfL5tfUpBJazPCAYqFAbb62m4k3Ki2RAZqOitqvUQxM1LgZhraBnm8ihv2Bnqnt0XQSatDuVEyvReUHLXSRui7XqMyvzbFX8eM0Pv6lXfWYFVWy6ID0b_tuhKzTcPZwUMDXnEoD-kBFRaEy3wPo1ogMor19cQOTpiELdD21y6GlpsRQHZ4Uvl_mxK86yaHzdKMuOsituJga5KPzbyJmdjhrCs_uXSdu18IPMbxJKWGmfOKperffaStwrgjWMnpEeXOZY2sB2CttXkGlP-5eBt7ZoahSTEV0I36QkTvQPevq0M1CeiLS2AlzdS07lvGNnkI45Z7Bwy07UGVvBSlz60i4MULWlZ_Vl4EVJNz14goWIcKTu7P8tebuh-3CHtLtA7mOZUiOMvkDUHPZBMiRsrW8oH_nDLuJVre6upgC8OJp_W03gFMYeOtZ3rRSUWcOcDi4nbw2bDEYb7dijB2f8GpfnrKRoUTPDYo53B_YoyqzrdouietFkzQgpyzL93-nlD3rX0voBLK2pcjwr8MO2p2nZZ332_hXuCU93YH07L5OsH64XZTkVJZT6dQbHnztipze8lmZtqiQHTPW3HYvMY5fjUgY_MPr0lUge0TrngBwLm0cwjwd9I8a-2pjaLSbWXlEi5egchdLI0fQxlPMZJDwcvDp11CeVFIQPeZeafkuHe42weiTWnwHI_3htrf6d_ounlTiebJdcBkW-5x-XV66sne6Uj7xyCqMDrzp8eqmLci0MBpDZx2lILFKSUeJvZoxs7xShO9n_C2ji5OePVnorbjE-u10WD7bWeB5PxoQPQO9-qcT8yM1eKREFqMNUFhdtMx8x2_auuSYHwJAcXf2PUyrLNsqm8hH48o6BFDG16J2CdWWwDuTpy9uL_1mn4rNk1xiXDuFzbOnGhwPJ1TGv2bmGYZwpqncbqj056D4FhS8xzvFmBfrF2U7EhkJEuMEZwOJfd-lBJXMKsFGvB-4OTuJe-50N7vsku2kOuQb4esrpnOzwQHQQqmj9v703AcQofHSIopE64b_6SIzvHgB9e7BoIxpoTd-m0wlvUuJHaroPoEdS4Qojz9Nn1lD3WyU8geqY_YExA9yQ3poz-BasvyFw7dQAKwzfXocCRi_4gILFhfUPaCMUrhxHj9gu89rRNIO_NT1vdMXjRKnM_WYAyy7wNGPfK1SKp30NQKAQiCLu_-qrpHf49Z7ZfLdumQ7ik0YRrJo5Vmitbga-QZPJQ9qniMayw_gKoI3KCfN6YkekR7KZRaDJzNQW24dUZKBz8XOAwGbAIjtyVCzFt0Z8z4jDVB85ruCkJlYbv2FeTrKHq12EQslXkkxzubAg160Gu7ifi39CJVqAm33e--e7EfDMWeoDyeJLpquLfg_Q1CtvVHoB5k89ygvCQCbfIuOP9Mf0CQWPWg19427Guz84_s_4SitWutGGXjEiwh_9yRBUz3ZASfVzsWvv0ittmlPykcBsPOIk5gmt3CPWleqx1_Okx1jXy6wkw4QrkO__YRyjABlmMsdyxqu41xz5oJt_fwUqOo4LijmOEzfsFNI7AM6NGoXf5L5-VYDQPgQmeC7Dbc3n-EOItsBXbK3qKr-368Lav6qGcr8qODICxS1Z5G9IAbaj2MNBknDJrDqqMczfLJPs2hkiArSnpzYv9ab3GF7fYLqDGwAdrojvpuDJvg6fSO_5PeLiPSEnuVwIDLfzXtPGm5D2AdFe-8TWw1iic8BnPuoIcWGdw_RBXvYWJn7jgzzlNx30T2lGhKhE48ped3_TWuwHxFEUhT_84KuwRIBVELObA0RNsFo6Ok8wpOb6OLBq3Mbr-UYdju__NflSjYtO1_DIygzI34heHEDgWEg5UdrbGeIYQTIkVvx3GDfYpshX9Z0D97AthI7aPdWY6msVGjoOHKGhSqTz2yWluaxxCLRHan6DA8-RUJ9da71JnRxo4oZGxFOgHJ1jS651j9zGNjdNE33jyMheQxcpSoi5R0vpETCgPwU5ShXbwnmz4npUzrg7kTJjwtgvP7uhAJ0Bcwh6sDHOyanR7piqYPZ50GMFF3FL-f1kzAMclQrloI4VN5yuPiuDcURqT-Q0MlY_j0idYP8LqonXIBiyJGtN9xCHmLOIKsX1hhI1ZeUF1K6KXO6J30dJm6AaUCFt9Ityke177d9T6CqCVxB3-2ezB7nBVEeAKuhhcCXSg-th5j1SkJZlF3eeBuLF3OJ8LExSUBSOS-tTKwpvA3hCtYKqmexulzZlSeAEKCi93Xt7iUfti3NQe2LHHaTRzyIM47hqJMGR1DlgNaekWvIQhyI0UWjT7REH3z_TZrHs0iAOfK7rvuUBn_jPPT0jfi_QMgyIO0d0OVKKBC2kw6VhlMQBKnLntzeI0gnfd3DMA0GsMvl7ywGXY0EVI3TKQa50QjoXNd3BzDiaYLsqCkRO2tHjXSljZS_h5ysh3hpk73bUTv6zMKudK5gjve358Adtty7NjjqmWjL9-ZKpq8ncLjMI-e_SDUpljCmInc632oDFLTlYcRIt7iTjV2mRgCqNksnUfO4IZXL18CrozI960rND10Jp56N15VHH3fE6l_3mmBooFZXNHzuh72n8MYp_7TuLTU9bA05MwnRGZSqHy2aCMVgLHc75cQQaYBh2T-UzAY05tl2eo0ZL36tSJ9KtT5Abm_aqRd8O03eQzm1s_kTJGZwmW6uAi35-s60tTim9G1l1Kn1exVEu0yHmDk8XbDgp6O1aSYHtSgN27C8cLXGpgpNmSzNJcAVhz9_EW1qiFYGnoNDxAQULoHnp-PtwX4dd5_uZSe0PEeyLTqtLRZnpHTqftNrEJaYzb8vU0K-kj9USLvxpu_VqXjsPzo2SvqltzTcbnt9TgZhZi45M2WZvY87bckgk6_-6zMs9h88nX-lYnyo9Eaub8XYzgW7Uy4uygBqkako1Y6IOdj92BJHdOYovwsN0mitrsDZdIFGBrRMFpGZ1k7Me2r8oC4l3JciRv6UzS2sEArX4kmAU7Xe0f5lUOR6px1l-OJcb6pBlT5euew__eUDSn1EU75CR92_3VNx3YOcWWD-RVRsPEOZhfNLwqYIqt_JHrEVoHsHF5g8qs86pl4LVxJ4q07K3lMBCy5uHzxVCZLNpdnIXuPNGYH2l7GWntxmwhIfRMPCOFMIyRFDZY08UC6rhxGK3Z96lVNgXCHV1m1nfFtIQTdvIfiV_ERygMGBCnCe_a0rHtRgluP6BjuEMH6Sl4S9w28AxM27DYuIFxxosSDv7CNHZR2vAaGYGuX4ZUJ0Z77TBwZ9LNuRUupiT8NdohoiQj_YC_EW-VWueNQQjV_yjHiQ5A-735D6-ncOFjedfIXmQrHAd5tCqDqmVSUbykWZ3uLRbsaFKMni9WlUX5GokLYquJOEVGZ5rvnB_PrXwrtduhJlzVc1nAa17HoAmu8-sT8D5q6H7khuB0VbF1F_VNO3SDaj_YKiPefpkjH2iyGJh0gXqn7-mOq77usZOdLpxltO7HEu1ODHXXcx4mjTPX6crpE_F10ffqIvb04PdcDhBMuiIhPRPp2twGZKaYt9KjWQ-dDkNwmAAfCP3tCwfhN0lr0o3LB-PpE29Bs2AR7rPQ_lDBuxIqcZRJkrg4Vdjabfd5ETylOthLPI4-2f248nJ2MTYMHtIMqSE6ReeWthcmxyNgTsW5GhfWdF26a0-CxqPwnOnvOOQ_sH1mngpQTJTwMl0KPQ5n4ZmNSBXu7uBVA3joc8jUkHJG2ZcCJqGakuvTIqpZwAaWqumWotryH30lnJ_aPUxsfyVi4aBjW3Mo9psdM1WLq5IQ2i3wkuI9nXSBOCrqxzdtoCL8tdy3XPvLNJjvEJbcZXh8lB4DgXvCzK8CoBGwZVQNzRDV9UBizZ0GW7s7_OB8V2mN8xOydxvRWm6oJdbuvlhwDbSlyDvRtOxc_U7Oa-BkIBckqkswLmt9VdF10awPip6i_Bvl7Lb4STR-8bgpar8fHTwfUGQbq1lZ8sTHd5cm2t8FQOsNNAG6lO-BmZDQDu60yafTyzYhXszprQ-x-0jgZZNxQfeEXPpzJeWM9vd_of71kfHII_LJF3YNbVDfMdMFamqPRXldNy227tn_K46D8z_XbFy9ZmYqrxkdNQiWBI9mgsnAXLY-Gm51bcsZhk6P1OZehStXCa6SJcdbI1NbUIVgj_geiIF-Gzf7uSjSlxJaSELS5qClUsTL0GZDeSMc1PBsbEsbjFvNuoegiyo8aDK-ueghNYHbUiNURrSkQV635ZBNsOTOzYJzIUpMuI0wOgACUGmOOcWZPHOv0luLyIWzvEOfWW0LJE3r2Ccf250S8BZdj_PKDriM_DHsU33Th1VZtgtQ_0tNElGTAoqsPFSlZ4F8OMGTnt8MmcB_x389n38yQBWEyUaH799EtslWPXGMiBa7BmEAa6urcgF2gR_7Gbdf1K8yx70FWcp50yUZz4ygCp3_VrVZB0d84AiF87bl9vx2Eh5VzXnsS0bWdG_5nCbIy-Uhd1iKxi0gXdag0a2XXoKiOKj81eo3J_bWA5pMEoM1WPVkVP-WSkFtRitpSIyA6uhfKFuZUPfai_oiJuVLypk5-0Sq3OrVfYS8cFIORW_CB-RjWuhkOjfrK9INvomVi3Cjm77EvazenloTxvxyk6-vXDBqP7XwwIvsisrJb2jHJFRQC5_uJH-aUjBE3Ybp3eEp-0kXw2vTV4W8wwfr5PcppAt5VbZiwTitTysMW3_rsE7_cLnXFzT3zvIyJLTxUe4KW52q07g0fwqBGfT9o8ORE2NZ0oe3_8mh_hl6mVOt3scaeFr9X6cOJNsfUS5tZG_aERvSWsawmFk9-I0vDxo2ksnHyIMIBVcZQ9llz2dxJqW-UOSYPRMpgqxXMctyt23FxeLqkKg45zYB9f8ms5C9DnZsl5eHuAvEMCrtcWMpNtGJCH3Ae9KOkw4iliuIzJXixI8F5BG9XL_1v3kyZvL_G0avn9W2ybqjMxrZQdPdkxdoeA-30SSjNH6tf_10FSZb_HXK4TASk4PIAu1Vo6N7p-95lD8uvGlYMgiVJIh0cBGvvNvCrlGVEJUnDJPDm_0GVA3zN8vfQD9jgjT2KtirksbzP0mmSdmfmjUC259bthGZW3Rs_U17CmuPvC8uxGvIZvgWMBfhRxvZ3rOtKzs2_EgLJLjn56sJeBwkL2ImvPvpfBkMhRb0I6mmmA9CQdPwXzMHPyf3aINSYA5dTu4D02KOmewY2HJMXPnvLB_2Gy5dgI4iN0eCNm9rXkjrF3drVcQHlUrHVgOASMvwBwBSYS8migsSqMVzWo6RMIaBUabG0RKnmZVScWr5ymsF6GUTKwas0fw0W4eKvfk21EU572xifAwEH2-ziAPzm2mlKB1waNPrAfL5qpFEISv9XbZAWeOZm-O_F8xovrdUBpLJVJgVBS8GKbZkVrMMeoe1z3SmLlHVxTsvBwJjVbiwbRq7LqsJWeOvoGN7d8-KP_XXD-E0Z4u2-RenBX5bvliCGjowHaIbhhSHeYLafSKa_pcOK7uK2ImB0Bb-TEPXAFIfyWRwRim0LvV5qz3deqs77d4FHyIMAOJIfMh8yPVwwzeHPnfA_Tz0oCiFSDomb4UQS_oPIVjE9-HA5LFJ6dGr_upw7UdhUIZ4CHRWrT8QEAkj4shGa4M0pn1dr2st6gjAXF0wykYVNgC5eu1YHRdON27Xs1Jo5MzyPeavf7Q3M6KeDo-Jit2nIUqjEnO7UhrxbODla8cyxSxJSXeAp4aHd_S-05n0MUQtEwCJt806esLyASpc0-oB5UtFHFEUk6w-gBlxG3oqeh_to75IHJLQKdI4XfFcY3Xj-SFN9grd6arHmHinhcJKUOuHt-stpudAmRL-4kV_J-UidMPwi4yBx3PwpPeChjz4oHrYylFD7ifxGmKBO8bhtEkOGuh-czcAx1fRe3AJf8lv9xPuVor_XM3VzZ4k_BR4ltdh4l-vAhv36in2OcXZFAt0jlI1JF_wV90h_25HJyq8DfypF_3LCfGcpRgUzUkKEkkFrNopVlde9S7nMfKqWWSnTF1ubaYys6qwzl2QMgi8PJVEMYjN3ENOASbfGxbOa0yFBjQOlMczx4oJtN9BucZ3aatjou8vXDcFNjl-1p146mh-Hb6cz2xDsZoLWAxglUtxSuD3_Ow9MzmCZbmuI300DflEGyGmAq6UNuy4sMWvXrkyzKuZLo26UdvigrZo2PWPo9rbxha_kipM1POZ24LcEqDXT97iv0Xg1oEWckKGzm-hNAGrppFELVCsE7xBD2Mu8TvpMhPxLdA-rsBysc8zmNHuZ3wCTg8ybQyeIjPylBlcl-hE9z8zEfpLnlRjrmUj2pYqTpjXe4RqB607qN_CusVVo9pdUg2Uy0t07eDjI2qbYWqqP9KcEhSQ6V49YtCEANBQKZ2ofonrlsTPUyYuBSlOSsY8mHY7lkMk_jSQGAE3sbRylUgXJde-pY09DibO2xBTL1CKiKO5cBFDYJmlo0NLMzRLjM6zEyDk6cwCgQo7luytWuhpI-UiPyKxG5a0tHUpH0_kWAzGj2glT3VzQYFFynpXLtPgfBpRVONJ8N-ko687hvQIX-PQ-FVZLM2pbA4VBluzQflChyHRVxCCtFb2VpTynxYqIaXvIvzY-UZO-33zV8i8wVh3Z0MwnMYV6knyl9Zf_1ihtFUjkmJAu7Xyv8cRWWCuFHBUyCBfI2bGicdbGJ316Rj6wQQfnKE69p1U4ePPYVwz0l-yEQwkrZO3aocUOB5EWy0uZiISUcao8s7n7d0_paJOJBhRoHOn3E7436MfOsYq5UoMQUso4JgrDwUgmsrWiZX_JJb8K3xp3XBY1sDRemYS6vlBbLSM34Zp7I2ZY6uqk_H2JwScd_CmJc4zbh8DKCKu12-wGNayjLi-k3AtERgPBaQu2gqI97McIC19MFWVaS1lFQRkm7SRmJeYtIRO3XXP_93s-8QH0aQ-0m4Nm5dKyANfpTPn4WDFAlumhBupQHVBi83Bsmz4uCr2XucOeVnK1W6hSPJ2a7sxWahovaotal2V0bNE0f5h0Hs_KKijHEWzRqkXlAMnM_goWe38_3tsCiMGg2s7uBuLVArIOZd60aRgGd4_EeyN1ET8ZM9JMV6viCL61MJJj2ii0WP4zUI6ixRJjjjCJh0ngscMq8biLsogUKu765jSSZv7Xl1z9cXDF0P3qeSmlNcobaisXr38jhMTfHi6qHwY-8PYdIIU8c0lP4_nW_6P5HITb3nKIDFHjxq-BCyYX4_aqz0thmoTeIfTZOtPcETSApIfWvi0nXL9ZZPWjwcnICa7nQivs8yYPYXs4YpLQvQ0_7fg5sM1l2_NyRJ6xGXnmFBrED7hxV2HEKGPtNHC-1_ff_NRR8DWSKRmAF4ZHy5VMjKs1S-S8pok69yVDRFqhX-ON_5kdYfc5nZS4Uwr8O7IlewG0w6wqjAPjUurpupDJAdRwHoVnX8Vxpv4H9j1AHkXDvFQqe5mPuXdKDlgKlcKhkHTzYGBDRKS55m5jolcI7VwxDoi6RS2O5Pfz5ak4mHn99XBO1BNyAkbCUM4O5LenouqULFK9mIfrj5PPA2EqpDJQsnoQVdr9gvtS1Y6gbziyJkCySM6taYoS2Z33n8Ue1R5Ef1T3_LhOaDT2KrnWBD9yRZR2TyJ&quot;,&quot;signature&quot;:&quot;rs_0683101154fa635a0168df5c2e362c81a1b8530603a5b5c82e&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;I\u0027m going to update the CSS in the WebView HTML for both `EditDocxScreen` and `CreateNewDocxScreen` to match the formatting used in `ViewDocxScreen`, without altering any features or JavaScript behavior.&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;call_AKP4MEa3Fyuu02DPo7o3NqZu&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;apply_patch&quot;,&quot;arguments&quot;:&quot;{\&quot;file_path\&quot;:\&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\&quot;,\&quot;patch\&quot;:\&quot;\u003c\u003c\u0027PATCH\u0027\\n*** Begin Patch\\n*** Update File: AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/EditDocxScreen.kt\\n@@\\n-    html.append(\\\&quot;\u003cstyle\u003e\\\&quot;)\\n-    html.append(\\\&quot;body { font-family: Arial, sans-serif; font-size: 12pt; margin: 0; padding: 20px; background: #f0f0f0; word-wrap: break-word; }\\\&quot;)\\n-    html.append(\\\&quot;.page { background: white; width: 21cm; min-height: 29.7cm; margin: 0 auto 20px auto; padding: 2.54cm; box-shadow: 0 4px 8px rgba(0,0,0,0.1); position: relative; page-break-after: always; overflow-wrap: break-word; }\\\&quot;)\\n-    html.append(\\\&quot;.page:last-child { page-break-after: auto; }\\\&quot;)\\n-    html.append(\\\&quot;p { margin-bottom: 0.5em; }\\\&quot;)\\n-    html.append(\\\&quot;table { border-collapse: collapse; width: 100%; margin-bottom: 1em; table-layout: fixed; }\\\&quot;)\\n-    html.append(\\\&quot;td, th { border: 1px solid #BFBFBF; padding: 6px 8px; vertical-align: top; text-align: left; word-wrap: break-word; font-size: 10pt; }\\\&quot;)\\n-    html.append(\\\&quot;img { max-width: 100%; height: auto; display: block; margin: 0.2em 0; }\\\&quot;)\\n-    html.append(\\\&quot;ul, ol { margin: 0.5em 0; padding-left: 2em; }\\\&quot;)\\n-    html.append(\\\&quot;li { margin-bottom: 0.25em; }\\\&quot;)\\n-    html.append(\\\&quot;h1, h2, h3, h4, h5, h6 { margin-top: 1em; margin-bottom: 0.5em; }\\\&quot;)\\n-    html.append(\\\&quot;.page-number { position: absolute; bottom: 1.27cm; right: 2.54cm; font-size: 10pt; color: #666; pointer-events: none; }\\\&quot;)\\n-    html.append(\\\&quot;\u003c/style\u003e\\\&quot;)\\n+    html.append(\\\&quot;\u003cstyle\u003e\\\&quot;)\\n+    html.append(\\\&quot;body { \\\&quot;)\\n+    html.append(\\\&quot;    font-family: \u0027Times New Roman\u0027, serif; \\\&quot;)\\n+    html.append(\\\&quot;    line-height: 1.6; \\\&quot;)\\n+    html.append(\\\&quot;    background: #f0f0f0; \\\&quot;)\\n+    html.append(\\\&quot;    margin: 0; padding: 20px; }\\\&quot;)\\n+    html.append(\\\&quot;.page { \\\&quot;)\\n+    html.append(\\\&quot;    background: white; \\\&quot;)\\n+    html.append(\\\&quot;    margin: 0 auto 20px auto; \\\&quot;)\\n+    html.append(\\\&quot;    padding-top: 1.00cm; \\\&quot;)\\n+    html.append(\\\&quot;    padding-bottom: 1.00cm; \\\&quot;)\\n+    html.append(\\\&quot;    padding-left: 2.54cm; \\\&quot;)\\n+    html.append(\\\&quot;    padding-right: 2.54cm; \\\&quot;)\\n+    html.append(\\\&quot;    width: 21cm; \\\&quot;)\\n+    html.append(\\\&quot;    min-height: 29.7cm; \\\&quot;)\\n+    html.append(\\\&quot;    box-shadow: 0 4px 8px rgba(0,0,0,0.15); \\\&quot;)\\n+    html.append(\\\&quot;    page-break-after: always; \\\&quot;)\\n+    html.append(\\\&quot;    position: relative; \\\&quot;)\\n+    html.append(\\\&quot;    overflow: visible; }\\\&quot;)\\n+    html.append(\\\&quot;.page:last-child { page-break-after: auto; }\\\&quot;)\\n+    html.append(\\\&quot;.page-number { position: absolute; bottom: 1.27cm; right: 2.54cm; font-size: 10pt; color: #666; }\\\&quot;)\\n+    html.append(\\\&quot;h1, h2, h3, h4, h5 { margin-top: 0.4em; margin-bottom: 0.2em; }\\\&quot;)\\n+    html.append(\\\&quot;p { margin: 0.2em 0; }\\\&quot;)\\n+    html.append(\\\&quot;ul, ol { margin: 0.5em 0 0.5em 1em; }\\\&quot;)\\n+    html.append(\\\&quot;table { border-collapse: collapse; width: 100%; margin: 1em 0; }\\\&quot;)\\n+    html.append(\\\&quot;td, th { border: 1px solid #444; padding: 3px; text-align: left; }\\\&quot;)\\n+    html.append(\\\&quot;img { max-width: 100%; height: auto; display: block; margin: 0.5em auto; }\\\&quot;)\\n+    html.append(\\\&quot;\u003c/style\u003e\\\&quot;)\\n*** End Patch\\nPATCH\&quot;,\&quot;instructions\&quot;:\&quot;I will update the CSS in the HTML template of EditDocxScreen to match the styling used in ViewDocxScreen without changing JS behavior.\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;apply_patch&quot;,&quot;tool_call_id&quot;:&quot;call_AKP4MEa3Fyuu02DPo7o3NqZu&quot;,&quot;content&quot;:&quot;The apply model made the following changes to the file:\n\n```\n@@ -306,15 +306,30 @@\n     html.append(\&quot;\u003cmeta name\u003d\\\&quot;viewport\\\&quot; content\u003d\\\&quot;width\u003ddevice-width, initial-scale\u003d1.0, user-scalable\u003dyes\\\&quot;\u003e\&quot;)\n     html.append(\&quot;\u003cstyle\u003e\&quot;)\n-    html.append(\&quot;body { font-family: Arial, sans-serif; font-size: 12pt; margin: 0; padding: 20px; background: #f0f0f0; word-wrap: break-word; }\&quot;)\n-    html.append(\&quot;.page { background: white; width: 21cm; min-height: 29.7cm; margin: 0 auto 20px auto; padding: 2.54cm; box-shadow: 0 4px 8px rgba(0,0,0,0.1); position: relative; page-break-after: always; overflow-wrap: break-word; }\&quot;)\n+    html.append(\&quot;body { \&quot;)\n+    html.append(\&quot;    font-family: \u0027Times New Roman\u0027, serif; \&quot;)\n+    html.append(\&quot;    line-height: 1.6; \&quot;)\n+    html.append(\&quot;    background: #f0f0f0; \&quot;)\n+    html.append(\&quot;    margin: 0; padding: 20px; }\&quot;)\n+    html.append(\&quot;.page { \&quot;)\n+    html.append(\&quot;    background: white; \&quot;)\n+    html.append(\&quot;    margin: 0 auto 20px auto; \&quot;)\n+    html.append(\&quot;    padding-top: 1.00cm; \&quot;)\n+    html.append(\&quot;    padding-bottom: 1.00cm; \&quot;)\n+    html.append(\&quot;    padding-left: 2.54cm; \&quot;)\n+    html.append(\&quot;    padding-right: 2.54cm; \&quot;)\n+    html.append(\&quot;    width: 21cm; \&quot;)\n+    html.append(\&quot;    min-height: 29.7cm; \&quot;)\n+    html.append(\&quot;    box-shadow: 0 4px 8px rgba(0,0,0,0.15); \&quot;)\n+    html.append(\&quot;    page-break-after: always; \&quot;)\n+    html.append(\&quot;    position: relative; \&quot;)\n+    html.append(\&quot;    overflow: visible; }\&quot;)\n     html.append(\&quot;.page:last-child { page-break-after: auto; }\&quot;)\n-    html.append(\&quot;p { margin-bottom: 0.5em; }\&quot;)\n-    html.append(\&quot;table { border-collapse: collapse; width: 100%; margin-bottom: 1em; table-layout: fixed; }\&quot;)\n-    html.append(\&quot;td, th { border: 1px solid #BFBFBF; padding: 6px 8px; vertical-align: top; text-align: left; word-wrap: break-word; font-size: 10pt; }\&quot;)\n-    html.append(\&quot;img { max-width: 100%; height: auto; display: block; margin: 0.2em 0; }\&quot;)\n-    html.append(\&quot;ul, ol { margin: 0.5em 0; padding-left: 2em; }\&quot;)\n-    html.append(\&quot;li { margin-bottom: 0.25em; }\&quot;)\n-    html.append(\&quot;h1, h2, h3, h4, h5, h6 { margin-top: 1em; margin-bottom: 0.5em; }\&quot;)\n-    html.append(\&quot;.page-number { position: absolute; bottom: 1.27cm; right: 2.54cm; font-size: 10pt; color: #666; pointer-events: none; }\&quot;)\n+    html.append(\&quot;.page-number { position: absolute; bottom: 1.27cm; right: 2.54cm; font-size: 10pt; color: #666; }\&quot;)\n+    html.append(\&quot;h1, h2, h3, h4, h5 { margin-top: 0.4em; margin-bottom: 0.2em; }\&quot;)\n+    html.append(\&quot;p { margin: 0.2em 0; }\&quot;)\n+    html.append(\&quot;ul, ol { margin: 0.5em 0 0.5em 1em; }\&quot;)\n+    html.append(\&quot;table { border-collapse: collapse; width: 100%; margin: 1em 0; }\&quot;)\n+    html.append(\&quot;td, th { border: 1px solid #444; padding: 3px; text-align: left; }\&quot;)\n+    html.append(\&quot;img { max-width: 100%; height: auto; display: block; margin: 0.5em auto; }\&quot;)\n     html.append(\&quot;\u003c/style\u003e\&quot;)\n     html.append(\&quot;\u003cscript\u003e\&quot;)\n```\n\nThe patch was applied successfully with no linter errors.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;call_8FaUeolOBQ8r7yas4tPyujvk&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;apply_patch&quot;,&quot;arguments&quot;:&quot;{\&quot;file_path\&quot;:\&quot;AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/CreateNewDocxScreen.kt\&quot;,\&quot;patch\&quot;:\&quot;\u003c\u003c\u0027PATCH\u0027\\n*** Begin Patch\\n*** Update File: AndroidStudioProjects/Docx/app/src/main/java/com/example/docx/ui/CreateNewDocxScreen.kt\\n@@\\n-            \u003cstyle\u003e\\n-                body { \\n-                    font-family: Arial, sans-serif; \\n-                    font-size: 12pt; \\n-                    margin: 0; \\n-                    padding: 20px; \\n-                    background: #f0f0f0; \\n-                    word-wrap: break-word; \\n-                }\\n-                .page { \\n-                    background: white; \\n-                    width: 21cm; \\n-                    min-height: 29.7cm; \\n-                    margin: 0 auto 20px auto; \\n-                    padding: 2.54cm; \\n-                    box-shadow: 0 4px 8px rgba(0,0,0,0.1); \\n-                    position: relative; \\n-                    page-break-after: always; \\n-                    overflow: hidden;\\n-                }\\n-                .page:last-child { page-break-after: auto; }\\n-                .page-number {\\n-                    position: absolute; \\n-                    bottom: 1.27cm; \\n-                    right: 2.54cm; \\n-                    font-size: 10pt; \\n-                    color: #666; \\n-                    pointer-events: none;\\n-                }\\n-                p { margin-bottom: 0.5em; }\\n-                table { border-collapse: collapse; width: 100%; margin-bottom: 1em; table-layout: fixed; }\\n-                td, th { border: 1px solid #BFBFBF; padding: 6px 8px; vertical-align: top; text-align: left; word-wrap: break-word; font-size: 10pt; }\\n-                img { max-width: 100%; height: auto; display: block; margin: 0.2em 0; }\\n-                ul, ol { margin: 0.5em 0; padding-left: 2em; }\\n-                li { margin-bottom: 0.25em; }\\n-                h1, h2, h3, h4, h5, h6 { margin-top: 1em; margin-bottom: 0.5em; }\\n-            \u003c/style\u003e\\n+            \u003cstyle\u003e\\n+                body {\\n+                    font-family: \u0027Times New Roman\u0027, serif;\\n+                    line-height: 1.6;\\n+                    background: #f0f0f0;\\n+                    margin: 0;\\n+                    padding: 20px;\\n+                }\\n+                .page {\\n+                    background: white;\\n+                    margin: 0 auto 20px auto;\\n+                    padding-top: 1.00cm;\\n+                    padding-bottom: 1.00cm;\\n+                    padding-left: 2.54cm;\\n+                    padding-right: 2.54cm;\\n+                    width: 21cm;\\n+                    min-height: 29.7cm;\\n+                    box-shadow: 0 4px 8px rgba(0,0,0,0.15);\\n+                    page-break-after: always;\\n+                    position: relative;\\n+                    overflow: visible;\\n+                }\\n+                .page:last-child { page-break-after: auto; }\\n+                .page-number {\\n+                    position: absolute;\\n+                    bottom: 1.27cm;\\n+                    right: 2.54cm;\\n+                    font-size: 10pt;\\n+                    color: #666;\\n+                }\\n+                h1, h2, h3, h4, h5 { margin-top: 0.4em; margin-bottom: 0.2em; }\\n+                p { margin: 0.2em 0; }\\n+                ul, ol { margin: 0.5em 0 0.5em 1em; }\\n+                table { border-collapse: collapse; width: 100%; margin: 1em 0; }\\n+                td, th { border: 1px solid #444; padding: 3px; text-align: left; }\\n+                img { max-width: 100%; height: auto; display: block; margin: 0.5em auto; }\\n+            \u003c/style\u003e\\n*** End Patch\\nPATCH\&quot;,\&quot;instructions\&quot;:\&quot;I will update the CSS in the initial HTML for CreateNewDocxScreen to match ViewDocxScreen styling while keeping existing JS behavior intact.\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;apply_patch&quot;,&quot;tool_call_id&quot;:&quot;call_8FaUeolOBQ8r7yas4tPyujvk&quot;,&quot;content&quot;:&quot;The apply model made the following changes to the file:\n\n```\n@@ -54,39 +54,39 @@\n             \u003cmeta name\u003d\&quot;viewport\&quot; content\u003d\&quot;width\u003ddevice-width, initial-scale\u003d1.0\&quot;\u003e\n             \u003cstyle\u003e\n-                body { \n-                    font-family: Arial, sans-serif; \n-                    font-size: 12pt; \n-                    margin: 0; \n-                    padding: 20px; \n-                    background: #f0f0f0; \n-                    word-wrap: break-word; \n+                body {\n+                    font-family: \u0027Times New Roman\u0027, serif;\n+                    line-height: 1.6;\n+                    background: #f0f0f0;\n+                    margin: 0;\n+                    padding: 20px;\n                 }\n-                .page { \n-                    background: white; \n-                    width: 21cm; \n-                    min-height: 29.7cm; \n-                    margin: 0 auto 20px auto; \n-                    padding: 2.54cm; \n-                    box-shadow: 0 4px 8px rgba(0,0,0,0.1); \n-                    position: relative; \n-                    page-break-after: always; \n-                    overflow: hidden;\n+                .page {\n+                    background: white;\n+                    margin: 0 auto 20px auto;\n+                    padding-top: 1.00cm;\n+                    padding-bottom: 1.00cm;\n+                    padding-left: 2.54cm;\n+                    padding-right: 2.54cm;\n+                    width: 21cm;\n+                    min-height: 29.7cm;\n+                    box-shadow: 0 4px 8px rgba(0,0,0,0.15);\n+                    page-break-after: always;\n+                    position: relative;\n+                    overflow: visible;\n                 }\n                 .page:last-child { page-break-after: auto; }\n                 .page-number {\n-                    position: absolute; \n-                    bottom: 1.27cm; \n-                    right: 2.54cm; \n-                    font-size: 10pt; \n-                    color: #666; \n-                    pointer-events: none;\n+                    position: absolute;\n+                    bottom: 1.27cm;\n+                    right: 2.54cm;\n+                    font-size: 10pt;\n+                    color: #666;\n                 }\n-                p { margin-bottom: 0.5em; }\n-                table { border-collapse: collapse; width: 100%; margin-bottom: 1em; table-layout: fixed; }\n-                td, th { border: 1px solid #BFBFBF; padding: 6px 8px; vertical-align: top; text-align: left; word-wrap: break-word; font-size: 10pt; }\n-                img { max-width: 100%; height: auto; display: block; margin: 0.2em 0; }\n-                ul, ol { margin: 0.5em 0; padding-left: 2em; }\n-                li { margin-bottom: 0.25em; }\n-                h1, h2, h3, h4, h5, h6 { margin-top: 1em; margin-bottom: 0.5em; }\n+                h1, h2, h3, h4, h5 { margin-top: 0.4em; margin-bottom: 0.2em; }\n+                p { margin: 0.2em 0; }\n+                ul, ol { margin: 0.5em 0 0.5em 1em; }\n+                table { border-collapse: collapse; width: 100%; margin: 1em 0; }\n+                td, th { border: 1px solid #444; padding: 3px; text-align: left; }\n+                img { max-width: 100%; height: auto; display: block; margin: 0.5em auto; }\n             \u003c/style\u003e\n             \u003cscript\u003e\n```\n\nThe patch was applied successfully with no linter errors.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[]}]}}" />
  </component>
</project>